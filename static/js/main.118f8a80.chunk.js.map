{"version":3,"sources":["components/Sorts/Sort.js","components/utils/utils.js","components/Controls/Controls.module.scss","components/Sorts/InsertionSort.js","components/ArrayAccess/Writes.js","components/classes/Element.js","components/Sorts/HeapSort.js","components/ArrayAccess/Delays.js","components/Sorts/Sorts.js","components/Sorts/BinaryInsertionSort.js","components/Sorts/DualPivotQuickSort.js","components/ArrayWindow/ArrayWindow.module.scss","components/Sorts/BubbleSort.js","components/Stats/Stats.module.scss","components/Sorts sync /^/.*/.js$","components/Sorts/BitonicSort.js","components/Sorts/CombSort.js","components/Sorts/GnomeSort.js","components/Sorts/GrailSort.js","components/Sorts/IntroSort.js","components/Sorts/LLQuickSort.js","components/Sorts/LRQuickSort.js","components/Sorts/LSDRadixSort.js","components/Sorts/MergeSort.js","components/Sorts/PseudoTimSort.js","components/Sorts/SelectionSort.js","components/Sorts/ShellSort.js","components/Sorts/SimpleSort.js","components/Sorts/SlowSort.js","components/Sorts/StoogeSort.js","components/Sorts/TimSort.js","components/Sorts/WikiSort.js","components/ArrayWindow/ArrayWindow.js","components/Stats/Stats.js","components/utils/initFunctions.js","components/utils/shuffles.js","components/Controls/Controls.js","components/ArrayAccess/Sounds.js","components/ArrayAccess/Marks.js","components/ArrayAccess/Reads.js","components/ArrayVisualizer/ArrayVisualizer.js","reportWebVitals.js","index.js"],"names":["Sort","arrayVisualizer","this","state","getState","Reads","getReads","Writes","getWrites","arrLength","getArrLength","sortName","warnLen","isDisabled","isNeedBucketsNum","low","high","bucketsNum","bufferSize","randomInt","a","b","Math","trunc","random","deepArrayCopy","arr","out","i","value","getValue","type","getType","color","getColor","markColor","getMarkColor","push","Element","objLength","obj","undefined","Object","keys","length","HSL2RGB","h","s","l","r","g","hue2rgb","p","q","t","round","module","exports","InsertionSort","start","end","pos","current","get","compareValues","write","Sounds","getSounds","Delays","getDelays","Marks","getMarks","mark","delay","getDelayInc","playSound","setTimeout","swapInArr","updateSortTime","curWrites","mainWrites","setState","incDelay","incOperationsCounter","tmpArr","tmp","copy","markUnmarkMany","arrIndex","getArray","swapWithDelay","index","toWrite","writeInArr","writeWithDelay","srcArray","srcPos","destArray","destPos","copyLen","len","isPseudo","pseudoAuxArrays","getAuxArrays","auxArrIndex","initArray","createAuxArrayWithDelay","console","log","auxArrays","createAuxArray","bind","removeAuxArrayWithDelay","removeAuxArray","swap","to","unMark","toString","HeapSort","root","dist","leaf","compareInArr","siftDown","heapify","heapSort","timeoutArray","delays","Swap","Write","Comp","Unmark","CreateAuxArray","RemoveAuxArray","Other","DELAY_INC_CONST","restoreDelayIncFactor","updateDelayInc","val","delayIncFactor","delayInc","timeout","func","delayName","args","clearTimeout","sortFinishedTime","operationsCounter","name","inc","time","auxWrites","comparisons","sortTime","ms","Promise","resolve","Sorts","sortsPaths","sortPath","require","resetDelays","nullify","sort","getSortObject","getWarnLen","parseInt","prompt","isNaN","alert","max","window","confirm","isNeedBuffer","initPseudoArray","setSortName","getSortName","backupArray","performance","now","runSort","setSortFinishedTime","checkSort","isSorted","array","clearAllMarks","forceMainArrayUpdate","BinaryInsertionSort","lo","hi","pivot","left","right","mid","readValue","n","binaryInsertionSort","DualPivotQuickSort","divisor","third","med1","med2","pivot1","pivot2","less","great","k","dualPivot","BubbleSort","swapped","j","map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","e","Error","code","BitonicSort","sortLength","m","ij","bitonicSort","CombSort","step","GnomeSort","Subarray","GrailSort","blockLen","grailSwap","arrayCopy","leftLen","rightLen","grailBlockSwap","item","target","middle","idealKeys","keysFound","firstKey","currentKey","insertPos","grailBinarySearchLeft","grailRotate","bufferOffset","buffer","currentMerge","bufferLen","mergeLen","mergeIndex","mergeEnd","grailMergeForwards","leftOver","finalBlock","finalOffset","grailMergeBackwards","externLen","arraycopy","externalBuffer","grailPairwiseWrites","grailMergeOutOfPlace","offset","grailBuildInPlace","externalBufferLen","grailBuildOutOfPlace","grailPairwiseSwaps","medianKey","blockCount","block","compare","resetLen","leftOvers","leftBlocks","firstRightBlock","prevLeftBlock","leftOrigin","currentBlockLen","grailInPlaceBufferRewind","currentBlockOrigin","grailBinarySearchRight","grailOutOfPlaceBufferRewind","finalLeftBlocks","finalLen","currentBlock","blockIndex","grailGetSubarray","keyIndex","grailSmartMerge","grailSmartLazyMerge","grailLazyMerge","grailSmartMergeOutOfPlace","subarrayLen","mergeCount","lastSubarray","grailInsertSort","grailBlockSelectSort","grailMergeBlocks","grailLazyMergeBlocks","rightBlocks","lastFragment","grailCountFinalLeftBlocks","leftLength","grailInPlaceBufferReset","grailMergeBlocksOutOfPlace","grailOutOfPlaceBufferReset","grailCombineOutOfPlace","grailCombineInPlace","leftEnd","extBuf","extBufLen","idealBuffer","keyLen","grailCollectKeys","grailLazyStableSort","bufferEnd","grailBuildBlocks","scrollingBuffer","blockKeysSum","minKeys","calcMinKeys","grailCombineBlocks","grailCommonSort","grailSortInPlace","numKeys","IntroSort","sizeThreshold","floor","x","depthLimit","partition","medianof3","introsortLoop","floorLogBaseTwo","LLQuickSort","LRQuickSort","quickSort","LSDRadixSort","highestPower","registers","Array","stabVal","min","tempArray","tempWrite","radix","total","MergeSort","merge","nxt","PseudoTimSort","MIN_MERGE","len1","len2","minRun","minRunLength","size","pseudoTimSort","SelectionSort","minIndex","ShellSort","gap","temp","SimpleSort","a1","a2","b1","b2","first","binaryInsertion","curSize","SlowSort","StoogeSort","TimSort","minGallop","tmpStorageLength","stackLength","runStart","runLength","stackSize","runHi","reverseRun","hint","lastOffset","maxOffset","mergeAt","start1","length1","start2","length2","gallopRight","gallopLeft","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","customCursor","customDest","remaining","makeAscendingRun","force","pushRun","mergeRuns","forceMergeRuns","Range","end1","Pull","range","set","from","count","Iterator","size2","min_level","power_of_two","FloorPowerOfTwo","denominator","numerator_step","decimal_step","begin","numerator","decimal","WikiSort","cache_size","cache","unique","skip","BinaryFirst","BinaryLast","reversal","block_size","amount","use_cache","split","range1","range2","reverseArrayCopy","Reverse","A","B","into","at_index","tempwrite","A_index","B_index","insert_index","A_last","B_last","A_count","B_count","insert","BlockSwap","Rotate","order","y","iterator","finished","nextRange","NetSwap","buffer1","buffer2","blockA","blockB","lastA","lastB","firstA","pull","A1","B1","A2","B2","MergeInto","A3","B3","nextLevel","MergeExternal","sqrt","buffer_size","last","pull_index","reset","find","find_separately","FindLastForward","FindFirstBackward","indexA","B_split","B_remaining","minA","findA","MergeInternal","MergeInPlace","FindFirstForward","FindLastBackward","ArrayWindow","props","mainArray","height","visualProps","borderEnabled","barsStroke","visualStyle","style","arrayLen","sizeStyle","width","updateCounter","canvasRef","React","createRef","containerRef","renderedArray","renderArray","updateInterval","setInterval","cancelAndUpdate","cancelAnimationFrame","updateAnimFrame","canvas","container","containerWidth","clientWidth","containerHeight","clientHeight","getContext","clearRect","requestAnimationFrame","nextProps","nextContext","rem","getComputedStyle","document","documentElement","fontSize","ctx","imageSmoothingEnabled","filter","w","fillStyle","getColorForRender","fillRect","strokeStyle","lineWidth","strokeRect","ref","className","styles","arrayContainer","PureComponent","Stats","statsContainer","toFixed","initFunctions","linear","manySimular","divider","sineWave","sin","PI","shuffles","FullShuffle","randomIndex","AlmostSorted","randomIndexA","randomIndexB","BlockShuffle","GAP_FACTOR","factor","PipeOrgan","InversedPipeOrgan","Heap","QuickSortKiller","GrailSortKiller","currentLen","sorter","bLen","rotate","multiSwap","Controls","isControlShow","updateArrLength","DEFAULT_ARR_LEN","stopSort","slider","getElementById","controlsContainer","controls","btn","showToggleBtn","display","innerHTML","setDelayIncFactor","shuffleArray","onClick","sortsNames","getSortsPaths","sortArray","element","setShowAuxArrays","checked","setEnableBarsStroke","setEnableMarks","setVisualStyle","setRainbow","setShowStats","restoreArray","sectionHeader","defaultValue","onChange","justifyContent","textAlign","checkBoxContainer","toggleShowAuxArrays","defaultChecked","htmlFor","toggleBarsStroke","toggleEnableMarks","toggleShowStats","toggleRainbow","toggleVisualStyle","genInitFunctions","getShuffles","abortSort","getSorts","AudioContext","webkitAudioContext","osc","createOscillator","frequency","gainNode","createGain","gain","connect","destination","linearRampToValueAtTime","currentTime","stop","colors","saveArr","getEnableMarks","setType","setMarkColor","indexes","saveOnce","unmark","hsl","rgb","setColor","markIndexes","markArgs","markMany","unmarkMany","Mark","marks","checkObj","tmpVal","elementIndex","findIndex","parseMark","tmpA","tmpB","compareWithDelay","compareStub","curComparisons","ArrayVisualizer","pseudoArray","prevArray","showAuxArrays","showStats","enableBarsStroke","enableMarks","setToState","writes","genStats","genArrayWindows","Component","MAIN_ARRAY","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render"],"mappings":"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","file":"static/js/main.118f8a80.chunk.js","sourcesContent":["export class Sort {\r\n    arrayVisualizer;\r\n\r\n    Reads\r\n    Writes\r\n\r\n    arrLength;\r\n\r\n    sortName;\r\n    warnLen;\r\n    isDisabled;\r\n    isNeedBucketsNum;\r\n    isNeedBuffer;\r\n\r\n\r\n\r\n\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.state = this.arrayVisualizer.getState()\r\n\r\n        this.Reads = this.arrayVisualizer.getReads()\r\n        this.Writes = this.arrayVisualizer.getWrites()\r\n\r\n        \r\n        this.arrLength = this.arrayVisualizer.getArrLength();\r\n        this.sortName = \"\"\r\n        this.warnLen = -1;\r\n        this.isDisabled = false;\r\n        this.isNeedBucketsNum = false;\r\n    }\r\n\r\n    getSortName(){\r\n        return this.sortName\r\n    }\r\n\r\n    getWarnLen(){\r\n        return this.warnLen\r\n    }\r\n\r\n    runSort(low, high, bucketsNum, bufferSize){\r\n    }\r\n}","import {Element} from \"../classes/Element\";\r\nexport function random(a, b) {\r\n    return Math.random() * (b - a) + a;\r\n}\r\n\r\nexport function randomInt(a, b) {\r\n    return Math.trunc(random(a, b))\r\n}\r\n\r\nexport function swapObj(json) {\r\n    let ret = {};\r\n    for (let key in json) {\r\n        ret[json[key]] = key;\r\n    }\r\n    return ret;\r\n}\r\n\r\nexport function sleep(ms) {\r\n    ms += new Date().getTime();\r\n    while (new Date() < ms) {\r\n    }\r\n}\r\n\r\nexport function getAllMethods(toCheck) {\r\n    const props = [];\r\n    let obj = toCheck;\r\n    do {\r\n        props.push(...Object.getOwnPropertyNames(obj));\r\n    } while (obj = Object.getPrototypeOf(obj));\r\n\r\n    return props.sort().filter((e, i, arr) => {\r\n        if (e!=arr[i+1] && typeof toCheck[e] == 'function') return true;\r\n    });\r\n}\r\n\r\nexport function deepArrayCopy(arr){\r\n    let out = [];\r\n    for(let i of arr){\r\n        let value = i.getValue();\r\n        let type = i.getType();\r\n        let color = i.getColor();\r\n        let markColor = i.getMarkColor();\r\n        out.push(new Element(value, type, color, markColor))\r\n    }\r\n    return out;\r\n}\r\n\r\nexport function arraysEquals(a, b){\r\n    return a.length === b.length &&\r\n    a.every((v, i) => v === b[i]);\r\n}\r\n\r\nexport function objLength(obj){\r\n    return (obj!==undefined) ? Object.keys(obj).length: 0\r\n}\r\n\r\nexport function HSL2RGB(h, s, l){\r\n    let r, g, b;\r\n\r\n    if(s === 0){\r\n        r = g = b = l;\r\n    }else{\r\n        let hue2rgb = function hue2rgb(p, q, t){\r\n            if(t < 0) t += 1;\r\n            if(t > 1) t -= 1;\r\n            if(t < 1/6) return p + (q - p) * 6 * t;\r\n            if(t < 1/2) return q;\r\n            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\r\n            return p;\r\n        }\r\n\r\n        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n        let p = 2 * l - q;\r\n        r = hue2rgb(p, q, h + 1/3);\r\n        g = hue2rgb(p, q, h);\r\n        b = hue2rgb(p, q, h - 1/3);\r\n    }\r\n\r\n    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\r\n}","// extracted by mini-css-extract-plugin\nmodule.exports = {\"textCenter\":\"Controls_textCenter__3_8jn\",\"controls\":\"Controls_controls__3X5vt\",\"showToggleBtn\":\"Controls_showToggleBtn__2CbSs\",\"slider\":\"Controls_slider__3IxWj\",\"sectionHeader\":\"Controls_sectionHeader__2EvBB\"};","import {Sort} from \"./Sort\";\r\n\r\nexport class InsertionSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"InsertionSort\"\r\n        this.warnLen = 350\r\n    }\r\n\r\n    InsertionSort(start, end) {\r\n        let pos;\r\n        let current;\r\n\r\n        for(let i = start; i < end; i++) {\r\n            current = this.Reads.get(i);\r\n            pos = i - 1;\r\n\r\n            while(pos >= start && this.Reads.compareValues(this.Reads.get(pos), current) > 0){\r\n                this.Writes.write(pos + 1,this.Reads.get(pos));\r\n                pos--;\r\n            }\r\n            this.Writes.write(pos + 1, current);\r\n        }\r\n    }\r\n\r\n\r\n    runSort(low, high) {\r\n        this.InsertionSort(low, high)\r\n    }\r\n}","import {objLength} from \"../utils/utils\";\r\n\r\nexport class Writes {\r\n    arrayVisualizer;\r\n    Sounds\r\n    Delays\r\n    Marks\r\n    Reads\r\n\r\n\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.Sounds = arrayVisualizer.getSounds()\r\n        this.Delays = arrayVisualizer.getDelays()\r\n        this.Marks = arrayVisualizer.getMarks()\r\n        this.Reads = arrayVisualizer.getReads()\r\n    }\r\n\r\n    //TODO refactoring\r\n    //-1 is main array\r\n\r\n    swapWithDelay(a, b, arr, mark, delay = this.Delays.getDelayInc(), playSound) {\r\n        // this.Delays.push(setTimeout(this.swapInArr.bind(this), this.Delays.incDelay(\"Write\", delay), a, b, arr, mark, playSound))\r\n        this.Delays.push(setTimeout(() => {\r\n            this.swapInArr(a, b, arr, mark, playSound)\r\n            this.Delays.updateSortTime()\r\n            let curWrites = this.arrayVisualizer.getState().mainWrites + 2;\r\n            this.arrayVisualizer.setState({\r\n                mainWrites: curWrites\r\n            })\r\n        }, this.Delays.incDelay(\"Write\", delay)))\r\n    }\r\n\r\n\r\n    swapInArr(a, b, arr, mark = true, playSound = false) {\r\n        if (playSound) {\r\n            this.Sounds.playSound(arr[b].getValue());\r\n        } else {\r\n            this.Delays.incOperationsCounter(2)\r\n        }\r\n        let tmpArr = arr\r\n        let tmp = tmpArr[a]\r\n        tmpArr[a] = tmpArr[b].copy(true)\r\n        tmpArr[b] = tmp.copy(true)\r\n        if (mark) {\r\n            this.Marks.markUnmarkMany([a, b], {type: \"Default\"})\r\n        }\r\n    }\r\n\r\n    swap(a, b, arrIndex = -1) {\r\n        this.swapInArr(a, b, this.arrayVisualizer.getArray(arrIndex, true), false, false)\r\n        this.swapWithDelay(a, b, this.arrayVisualizer.getArray(arrIndex, false), true, this.Delays.getDelayInc(), true)\r\n    }\r\n\r\n\r\n    writeInArr(index, toWrite, arr = this.arrayVisualizer.getArray(-1, true), mark = true, playSound = false) {\r\n        if (playSound) {\r\n            this.Sounds.playSound(toWrite.getValue())\r\n        } else {\r\n            this.Delays.incOperationsCounter(1)\r\n        }\r\n        arr[index] = toWrite.copy(true)\r\n        if (mark) {\r\n            this.Marks.markUnmarkMany([index], {type: \"Default\"})\r\n        }\r\n    }\r\n\r\n    writeWithDelay(index, toWrite, arrIndex, mark, delay = this.Delays.getDelayInc(), playSound = true) {\r\n        // this.Delays.push(setTimeout(this.writeInArr.bind(this), this.Delays.incDelay(\"Write\", delay), index, toWrite, arr, mark, playSound))\r\n        this.Delays.push(setTimeout(() => {\r\n            let arr = this.arrayVisualizer.getArray(arrIndex, false)\r\n            this.Delays.updateSortTime()\r\n            this.writeInArr(index, toWrite, arr, mark, playSound)\r\n            let curWrites = this.arrayVisualizer.getState().mainWrites + 1;\r\n            this.arrayVisualizer.setState({\r\n                mainWrites: curWrites\r\n            })\r\n        }, this.Delays.incDelay(\"Write\", delay)))\r\n    }\r\n\r\n    write(index, toWrite, arrIndex = -1) {\r\n        this.writeInArr(index, toWrite, this.arrayVisualizer.getArray(arrIndex, true), false, false)\r\n        this.writeWithDelay(index, toWrite, arrIndex, arrIndex === -1, this.Delays.getDelayInc(), true)\r\n    }\r\n\r\n\r\n    arrayCopy(srcArray, srcPos, destArray, destPos, copyLen) {\r\n        for (let i = 0; i < copyLen; i++) {\r\n            this.write(destPos + i, this.Reads.get(srcPos + i, srcArray), destArray)\r\n        }\r\n    }\r\n\r\n    reverseArrayCopy(srcArray, srcPos, destArray, destPos, copyLen) {\r\n        for (let i = copyLen - 1; i >= 0; i--) {\r\n            this.write(destPos + i, this.Reads.get(srcPos + i, srcArray), destArray)\r\n        }\r\n    }\r\n\r\n    createAuxArray(len, isPseudo = true) {\r\n        if (isPseudo) {\r\n            let pseudoAuxArrays = this.arrayVisualizer.getAuxArrays(true)\r\n            let auxArrIndex = objLength(pseudoAuxArrays)\r\n            pseudoAuxArrays[auxArrIndex] = (this.arrayVisualizer.initArray(() => -1, len, false))\r\n            this.createAuxArrayWithDelay(len, this.Delays.getDelayInc(), false)\r\n            return auxArrIndex\r\n        } else {\r\n            let tmpArr = this.arrayVisualizer.getAuxArrays(false)\r\n            let auxArrIndex = objLength(tmpArr)\r\n            tmpArr[auxArrIndex] = (this.arrayVisualizer.initArray(() => -1, len, false))\r\n            console.log(tmpArr)\r\n            this.arrayVisualizer.setState({\r\n                    auxArrays: tmpArr\r\n                }\r\n            )\r\n            console.log(this.arrayVisualizer.getAuxArrays(false))\r\n        }\r\n    }\r\n\r\n    createAuxArrayWithDelay(len, delay, isPseudo = false) {\r\n        this.Delays.push(setTimeout(this.createAuxArray.bind(this), this.Delays.incDelay(\"Write\", delay), len, isPseudo))\r\n    }\r\n\r\n    removeAuxArray(index, isPseudo = true) {\r\n        if (isPseudo) {\r\n            // this.arrayVisualizer.getPseudoAuxArrays().splice(index, 1)\r\n            delete this.arrayVisualizer.getAuxArrays(true)[index]\r\n            this.removeAuxArrayWithDelay(index, this.Delays.getDelayInc(), false)\r\n        } else {\r\n            let tmp = this.arrayVisualizer.getAuxArrays(false)\r\n            // tmp.splice(index, 1)\r\n            delete tmp[index]\r\n            this.arrayVisualizer.setState({\r\n                auxArrays: tmp\r\n            })\r\n        }\r\n    }\r\n\r\n    removeAuxArrayWithDelay(index, delay, isPseudo = false) {\r\n        this.Delays.push(setTimeout(this.removeAuxArray.bind(this), this.Delays.incDelay(\"Write\", delay), index, isPseudo))\r\n    }\r\n\r\n    reversal(start, length, arrIndex = -1) {\r\n        for (let i = start; i < start + Math.trunc((length - start + 1) / 2); i++) {\r\n            this.swap(i, start + length - i, arrIndex);\r\n        }\r\n    }\r\n\r\n    multiSwap(pos, to, arrIndex) {\r\n        if (to - pos > 0) {\r\n            for (let i = pos; i < to; i++) {\r\n                this.swap(i, i + 1, arrIndex);\r\n            }\r\n        } else {\r\n            for (let i = pos; i > to; i--) {\r\n                this.swap(i, i - 1, arrIndex);\r\n            }\r\n        }\r\n    }\r\n}\r\n","const types = {\r\n\r\n}\r\n\r\nconst colors = {\r\n\r\n}\r\n\r\nexport class Element{\r\n\r\n    value;\r\n    type;\r\n    color;\r\n    markColor;\r\n\r\n    // constructor(args){\r\n    //     this.value = args.value;\r\n    //     this.type = args.type;\r\n    //     this.color = args.color || colors[args.type];\r\n    // }\r\n\r\n    constructor(value, type, color, markColor) {\r\n        this.value = value;\r\n        this.type = type;\r\n        this.color = color;\r\n        this.markColor = markColor;\r\n    }\r\n\r\n\r\n    getValue(){\r\n        return this.value;\r\n    }\r\n    setValue(value){\r\n        this.value = value;\r\n    }\r\n\r\n    getColor(){\r\n        return this.color;\r\n    }\r\n\r\n    setColor(color){\r\n        this.color = color;\r\n    }\r\n\r\n    getMarkColor(){\r\n        return this.markColor;\r\n    }\r\n    setMarkColor(markColor){\r\n        this.markColor = markColor;\r\n    }\r\n\r\n    getColorForRender(){\r\n        // if(this.type === \"Default\"){\r\n        //     return this.markColor\r\n        // }else{\r\n        //     return this.color\r\n        // }\r\n        if(this.type === \"Unmarked\"){\r\n            return this.color\r\n        }else {\r\n            return this.markColor\r\n        }\r\n    }\r\n\r\n    getType(){\r\n        return this.type;\r\n    }\r\n    setType(type){\r\n        this.type = type;\r\n    }\r\n\r\n    copy(unMark = true){\r\n        if(unMark){\r\n            return new Element(this.value, \"Unmarked\", this.color, [0,0,0])\r\n        }else{\r\n            return new Element(this.value, this.type, this.color, this.markColor)\r\n        }\r\n    }\r\n\r\n    toString(){\r\n        return this.value.toString()\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class HeapSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"HeapSort\"\r\n    }\r\n\r\n    siftDown(root, dist, start) {\r\n\r\n\r\n        while (root <= dist / 2) {\r\n            let leaf = 2 * root;\r\n            if (leaf < dist && this.Reads.compareInArr(start + leaf - 1, start + leaf) < 0) {\r\n                leaf++;\r\n            }\r\n\r\n            if (this.Reads.compareInArr(start + root - 1, start + leaf - 1) < 0) {\r\n                this.Writes.swap(start + root - 1, start + leaf - 1,);\r\n                root = leaf;\r\n            } else break;\r\n        }\r\n    }\r\n\r\n    heapify(low, high) {\r\n        let length = high - low;\r\n        for (let i = length / 2; i >= 1; i--) {\r\n            this.siftDown(i, length, low);\r\n        }\r\n    }\r\n\r\n// This version of heap sort works for max and min variants, alongside sorting\r\n// partial ranges of an array.\r\n    heapSort(start, length) {\r\n        this.heapify(start, length);\r\n\r\n        for (let i = length - start; i > 1; i--) {\r\n            this.Writes.swap(start, start + i - 1);\r\n            this.siftDown(1, i - 1, start);\r\n        }\r\n\r\n        // if(!isMax) {\r\n        //     this.Writes.reversal(arr, start, start + length - 1, 1, true, false);\r\n        // }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.heapSort(low, high + 1)\r\n    }\r\n}\r\n","export class Delays {\r\n    arrayVisualizer\r\n    timeoutArray\r\n    delays\r\n    delayIncFactor\r\n    delayInc\r\n    DELAY_INC_CONST\r\n    sortFinishedTime\r\n    operationsCounter\r\n\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.timeoutArray = []\r\n        this.delays = {\r\n            Swap: 0,\r\n            Write: 0,\r\n            Comp: 0,\r\n            Unmark: 0,\r\n            CreateAuxArray: 0,\r\n            RemoveAuxArray: 0,\r\n            Other: 0\r\n        }\r\n        this.DELAY_INC_CONST = 3000\r\n        this.restoreDelayIncFactor()\r\n        this.updateDelayInc()\r\n        // this.delayIncFactor = this.DELAY_INC_CONST-arrayVisualizer.getArrLength()*3\r\n        // this.delayInc = this.delayIncFactor/arrayVisualizer.getArrLength()\r\n    }\r\n\r\n    setDelayIncFactor(val){\r\n        this.delayIncFactor = val\r\n        this.updateDelayInc()\r\n    }\r\n\r\n    // setDelay\r\n\r\n    restoreDelayIncFactor(){\r\n        this.delayIncFactor = this.DELAY_INC_CONST\r\n        this.updateDelayInc()\r\n    }\r\n\r\n    updateDelayInc(){\r\n        // this.delayIncFactor = this.DELAY_INC_CONST\r\n        this.delayInc = this.delayIncFactor/this.arrayVisualizer.getArrLength()\r\n    }\r\n\r\n    push(timeout){\r\n        this.timeoutArray.push(timeout)\r\n    }\r\n\r\n    pushFunc(func, obj, delayName, delay, args) {\r\n        this.timeoutArray.push(setTimeout(func.bind(obj), this.delays[delayName] += delay, args))\r\n    }\r\n\r\n    resetDelays() {\r\n        this.delays = {\r\n            Swap: 0,\r\n            Write: 0,\r\n            Comp: 0,\r\n            Unmark: 0,\r\n            CreateAuxArray: 0,\r\n            RemoveAuxArray: 0,\r\n            Other: 0\r\n        }\r\n        for (let i of this.timeoutArray) {\r\n            clearTimeout(i);\r\n        }\r\n        this.timeoutArray = []\r\n        this.sortFinishedTime = 0\r\n        this.operationsCounter = 0\r\n    }\r\n\r\n    setDelay(name, value){\r\n        this.delays[name] = value\r\n    }\r\n\r\n    incDelay(name, inc=this.delayInc){\r\n        return this.delays[name]+=inc\r\n    }\r\n\r\n    getDelayInc(){\r\n        return this.delayInc\r\n    }\r\n\r\n    getDelays(){\r\n        return this.delays\r\n    }\r\n\r\n    setSortFinishedTime(time){\r\n        this.sortFinishedTime = time\r\n    }\r\n\r\n    incOperationsCounter(val=1){\r\n        this.operationsCounter+=val;\r\n    }\r\n\r\n    updateSortTime(){\r\n        let state = this.arrayVisualizer.getState()\r\n        let mainWrites = state.mainWrites\r\n        let auxWrites = state.auxWrites\r\n        let comparisons = state.comparisons\r\n        this.arrayVisualizer.setState({\r\n            sortTime: (mainWrites+auxWrites+comparisons)/this.operationsCounter*this.sortFinishedTime\r\n        })\r\n    }\r\n\r\n    sleep(ms){\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n\r\n}","import {Delays} from \"../ArrayAccess/Delays\";\r\n\r\nexport class Sorts {\r\n    arrayVisualizer;\r\n    sortsPaths\r\n    Delays\r\n    Sounds\r\n    Marks\r\n\r\n\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n\r\n        this.Delays = arrayVisualizer.getDelays()\r\n        this.Sounds = arrayVisualizer.getSounds()\r\n        this.Marks = arrayVisualizer.getMarks()\r\n\r\n        this.sortsPaths = [\"BubbleSort\", \"CombSort\", \"MergeSort\", \"LLQuickSort\", \"LRQuickSort\", \"HeapSort\",\r\n            \"DualPivotQuickSort\", \"GnomeSort\", \"InsertionSort\", \"BinaryInsertionSort\", \"ShellSort\", \"SelectionSort\", \"TimSort\", \"PseudoTimSort\",\r\n            \"IntroSort\", \"LSDRadixSort\", \"BitonicSort\", \"SlowSort\", \"StoogeSort\", \"GrailSort\", \"WikiSort\", \"SimpleSort\"]\r\n\r\n    }\r\n\r\n    getSortsPaths() {\r\n        return this.sortsPaths;\r\n    }\r\n\r\n    getSortObject(sortPath) {\r\n        let Sort = require(\"./\" + sortPath + \".js\")[sortPath]\r\n        return new Sort(this.arrayVisualizer)\r\n    }\r\n\r\n    runSort(sortName, low, high) {\r\n        this.Delays.resetDelays()\r\n        this.arrayVisualizer.nullify()\r\n        let sort = this.getSortObject(sortName)\r\n        let warnLen = sort.getWarnLen()\r\n        let bucketsNum = 4\r\n        if (sort.isNeedBucketsNum) {\r\n            bucketsNum = parseInt(prompt(\"Enter the buckets num:\", \"4\"))\r\n            if (isNaN(bucketsNum)) {\r\n                return;\r\n            }\r\n            if (bucketsNum < 2){\r\n                alert(\"WARNING!!!\\nUncorrected buckets num was entered!\\nThe buckets num will be set to 2\")\r\n            }\r\n        }\r\n        bucketsNum = Math.max(2, bucketsNum)\r\n\r\n        if (warnLen !== -1 && this.arrayVisualizer.getArrLength() > warnLen &&\r\n            !window.confirm(\"WARNING!!!\\nThe array size(\" + this.arrayVisualizer.getArrLength() + \") \" +\r\n                \"more than recommended(\" + warnLen + \")\\nApplication may freeze\\nDo you want continue?\")) {\r\n            return\r\n\r\n        }\r\n\r\n        let bufferSize = 0\r\n        if (sort.isNeedBuffer) {\r\n            bufferSize = parseInt(prompt(\"Enter the buffer size:\", \"0\"))\r\n            if (isNaN(bufferSize)) {\r\n                return;\r\n            }\r\n        }\r\n        bufferSize = Math.max(0, bufferSize)\r\n\r\n        this.arrayVisualizer.initPseudoArray()\r\n        this.arrayVisualizer.setSortName(sort.getSortName())\r\n        this.arrayVisualizer.backupArray()\r\n\r\n        let start = performance.now()\r\n        sort.runSort(low, high, bucketsNum, bufferSize)\r\n        let end = performance.now()\r\n\r\n        // console.log(\"Sort time: \" + (end-start).toFixed(2)+\" ms\")\r\n\r\n        this.Delays.setSortFinishedTime(end-start)\r\n\r\n        // this.arrayVisualizer.sortClickEvent()\r\n        // console.log(this.Delays.getDelays().Write)\r\n        this.Delays.push(setTimeout(() => (this.checkSort()), this.Delays.getDelays().Write + this.Delays.getDelayInc() * 5))\r\n    }\r\n\r\n    checkSort() {\r\n        let isSorted = true\r\n        let array = this.arrayVisualizer.getArray(-1, false)\r\n        for (let i = 1; i < array.length; ++i) {\r\n            if (array[i - 1].getValue() > array[i].getValue()) {\r\n                isSorted = false\r\n                break;\r\n            }\r\n        }\r\n        for (let i = 0; i < array.length; ++i) {\r\n            this.Delays.push(setTimeout(() => {\r\n                if (isSorted) {\r\n                    this.Sounds.playSound(array[i].getValue())\r\n                    this.Marks.mark(i, {type: \"Sorted\", color: [0, 255, 0]}, -1, true)\r\n                } else {\r\n                    this.Marks.mark(i, {type: \"Default\", color: [255, 0, 0]}, -1, true)\r\n                }\r\n            }, this.Delays.incDelay(\"Other\", this.Delays.getDelayInc() / 3)))\r\n        }\r\n        this.Delays.push(setTimeout(() => {\r\n            this.Marks.clearAllMarks()\r\n            this.Delays.resetDelays()\r\n            this.arrayVisualizer.forceMainArrayUpdate()\r\n        }, (this.Delays.getDelayInc()) * (array.length + 2) / 3))\r\n\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class BinaryInsertionSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"BinaryInsertionSort\"\r\n        this.warnLen = 200\r\n    }\r\n\r\n    binaryInsertionSort(lo, hi, start) {\r\n        if (start === lo) {\r\n            start++\r\n        }\r\n\r\n        for (; start < hi; start++) {\r\n            const pivot = this.Reads.get(start)\r\n\r\n            let left = lo\r\n            let right = start\r\n\r\n            while (left < right) {\r\n                const mid = (left + right) >>> 1\r\n\r\n                if (this.Reads.compareValues(pivot.getValue(), this.Reads.readValue(mid)) < 0) {\r\n                    right = mid\r\n                } else {\r\n                    left = mid + 1\r\n                }\r\n            }\r\n\r\n            let n = start - left\r\n            while (n > 0) {\r\n                this.Writes.write(left + n, this.Reads.get(left + n - 1))\r\n                n--\r\n            }\r\n\r\n            this.Writes.write(left, pivot)\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.binaryInsertionSort(low, high+1, 0)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\nimport {InsertionSort} from \"./InsertionSort\";\r\n\r\nexport class DualPivotQuickSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"Dual Pivot QuickSort\"\r\n    }\r\n\r\n    dualPivot(left, right, divisor) {\r\n        let length = right - left;\r\n\r\n        // insertion sort for tiny array\r\n        if (length < 4) {\r\n            let insertSorter = new InsertionSort(this.arrayVisualizer)\r\n            insertSorter.runSort(left, right+1)\r\n            return;\r\n        }\r\n        // if(length === 1){\r\n        //     return\r\n        // }\r\n\r\n        let third = Math.trunc(length / divisor);\r\n\r\n// \"medians\"\r\n        let med1 = left + third;\r\n        let med2 = right - third;\r\n\r\n        if (med1 <= left) {\r\n            med1 = left + 1;\r\n        }\r\n        if (med2 >= right) {\r\n            med2 = right - 1;\r\n        }\r\n\r\n\r\n        // if(Reads.compareValues(array[med1], array[med2]) == -1) {\r\n        if (this.Reads.compareInArr(med1, med2) < 0) {\r\n            this.Writes.swap(med1, left);\r\n            this.Writes.swap(med2, right);\r\n        } else {\r\n            this.Writes.swap(med1, right);\r\n            this.Writes.swap(med2, left);\r\n        }\r\n\r\n// pivots\r\n        let pivot1 = this.Reads.readValue(left);\r\n        let pivot2 = this.Reads.readValue(right);\r\n\r\n// pointers\r\n        let less = left + 1;\r\n        let great = right - 1;\r\n\r\n// sorting\r\n        for (let k = less; k <= great; k++) {\r\n\r\n            // if (this.Reads.read(k) < pivot1) {\r\n            if (this.Reads.compareValues(this.Reads.get(k), pivot1) < 0) {\r\n\r\n                this.Writes.swap(k, less++);\r\n            // } else if (this.Reads.read(k) > pivot2) {\r\n            } else if (this.Reads.compareValues(this.Reads.get(k), pivot2) > 0) {\r\n                // while (k < great && this.Reads.read(great) > pivot2) {\r\n                while (k < great && this.Reads.compareValues(this.Reads.get(great), pivot2) > 0) {\r\n                    great--;\r\n                }\r\n                this.Writes.swap(k, great--);\r\n\r\n                // if (this.Reads.read(k) < pivot1) {\r\n                if (this.Reads.compareValues(this.Reads.get(k), pivot1) < 0) {\r\n                    this.Writes.swap(k, less++);\r\n                }\r\n            }\r\n        }\r\n\r\n// swaps\r\n        let dist = great - less;\r\n\r\n        if (dist < 13) {\r\n            divisor++;\r\n        }\r\n        this.Writes.swap(less - 1, left);\r\n        this.Writes.swap(great + 1, right);\r\n\r\n// subarrays\r\n        this.dualPivot(left, less - 2, divisor);\r\n        if (pivot1 < pivot2) {\r\n            this.dualPivot(less, great, divisor);\r\n        }\r\n        this.dualPivot(great + 2, right, divisor);\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.dualPivot(low, high, 3)\r\n    }\r\n}","// extracted by mini-css-extract-plugin\nmodule.exports = {\"arrayContainer\":\"ArrayWindow_arrayContainer__jfaB8\",\"bar\":\"ArrayWindow_bar__30QYB\",\"dotContainer\":\"ArrayWindow_dotContainer__3porX\",\"dot\":\"ArrayWindow_dot__29TqH\",\"canvas\":\"ArrayWindow_canvas__3rwEz\"};","import {Sort} from \"./Sort\";\r\n\r\nexport class BubbleSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"BubbleSort\"\r\n        this.warnLen = 200\r\n    }\r\n    BubbleSort(low, high) {\r\n        let len = high-low+1\r\n        let swapped = false\r\n        for(let i = 0; i < len; ++i){\r\n            swapped = false\r\n            for(let j = low; j < high-i-1;++j){\r\n                if(this.Reads.compareInArr(j, j+1) > 0){\r\n                    this.Writes.swap(j, j+1)\r\n                    swapped=true\r\n                }\r\n            }\r\n            if(!swapped){\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.BubbleSort(low, high+1)\r\n    }\r\n}","// extracted by mini-css-extract-plugin\nmodule.exports = {\"statsContainer\":\"Stats_statsContainer__1qOnq\"};","var map = {\n\t\"./BinaryInsertionSort.js\": 20,\n\t\"./BitonicSort.js\": 33,\n\t\"./BubbleSort.js\": 23,\n\t\"./CombSort.js\": 34,\n\t\"./DualPivotQuickSort.js\": 21,\n\t\"./GnomeSort.js\": 35,\n\t\"./GrailSort.js\": 36,\n\t\"./HeapSort.js\": 14,\n\t\"./InsertionSort.js\": 11,\n\t\"./IntroSort.js\": 37,\n\t\"./LLQuickSort.js\": 38,\n\t\"./LRQuickSort.js\": 39,\n\t\"./LSDRadixSort.js\": 40,\n\t\"./MergeSort.js\": 41,\n\t\"./PseudoTimSort.js\": 42,\n\t\"./SelectionSort.js\": 43,\n\t\"./ShellSort.js\": 44,\n\t\"./SimpleSort.js\": 45,\n\t\"./SlowSort.js\": 46,\n\t\"./Sort.js\": 5,\n\t\"./Sorts.js\": 19,\n\t\"./StoogeSort.js\": 47,\n\t\"./TimSort.js\": 48,\n\t\"./WikiSort.js\": 49\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 32;","import {Sort} from \"./Sort\";\r\n\r\nexport class BitonicSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"BitonicSort\"\r\n    }\r\n    // kernel(p, q) {\r\n    //     const d = 1 << (p - q);\r\n    //\r\n    //     for (let i = 0; i < this.arrLength; i++) {\r\n    //         const up = ((i >> p) & 2) === 0;\r\n    //         // if ((i & d) === 0 && (x[i] > x[i | d]) === up) {\r\n    //         if ((i & d) === 0 && ((this.Reads.compare(i, i | d, \">\")) === up)) {\r\n    //             // const tmp = x[i];\r\n    //             // x[i] = x[i | d];\r\n    //             // x[i | d] = tmp;\r\n    //             this.Writes.swap(i, i | d)\r\n    //         }\r\n    //     }\r\n    // }\r\n    //\r\n    // bitonicSort(n) {\r\n    //     for (let i = 0; i < n; i++) {\r\n    //         for(let j = 0; j <= i; j++) {\r\n    //             this.kernel(i, j);\r\n    //         }\r\n    //     }\r\n    // }\r\n    bitonicSort(sortLength){\r\n        let i, j, k;\r\n\r\n        for(k = 2; k < sortLength*2; k = 2 * k) {\r\n            let m = (Math.trunc((sortLength + (k - 1)) / k) % 2) !== 0;\r\n\r\n            for(j = k >> 1; j > 0; j = j >> 1) {\r\n                for(i = 0; i < sortLength; i++) {\r\n                    let ij = i ^ j;\r\n\r\n                    if((ij) > i && ij < sortLength) {\r\n                        if((((i & k) === 0) === m) && this.Reads.compareInArr(i, ij) > 0)\r\n                            this.Writes.swap(i, ij);\r\n                        if((((i & k) !== 0) === m) && this.Reads.compareInArr(i, ij) < 0)\r\n                            this.Writes.swap(i, ij);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    runSort(low, high, bucketsNum) {\r\n        // this.bitonicSort(Math.trunc(Math.log2(high-1)))\r\n        this.bitonicSort(high+1)\r\n    }\r\n\r\n}\r\n","import {Sort} from \"./Sort\";\r\n\r\nexport class CombSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"CombSort\"\r\n    }\r\n    CombSort() {\r\n        let len = this.arrLength;\r\n        let factor = 1.2473309\r\n        let step = len - 1\r\n        while(step>=1){\r\n            for (let i = 0; i + step < len; i++) {\r\n                if (this.Reads.compareInArr(i, i+step)>0)\r\n                {\r\n                    this.Writes.swap(i, i+step)\r\n                }\r\n            }\r\n            step = Math.trunc(step/factor);\r\n        }\r\n\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.CombSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\nimport {Writes} from \"../ArrayAccess/Writes\";\r\n\r\nexport class GnomeSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"GnomeSort\"\r\n        this.warnLen = 250\r\n    }\r\n\r\n    GnomeSort() {\r\n        let len = this.arrLength;\r\n        for (let i = 1; i < len;) {\r\n            if (this.Reads.compareInArr(i, i - 1) >= 0) {\r\n                i++\r\n            } else {\r\n                this.Writes.swap(i, i - 1)\r\n                if (i > 1) {\r\n                    i--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.GnomeSort(low, high)\r\n    }\r\n}","/*\r\n * MIT License\r\n * \r\n * Copyright (c) 2013 Andrey Astrelin\r\n * Copyright (c) 2020 The Holy Grail Sort Project\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n/*\r\n * The Holy Grail Sort Project\r\n * Project Manager:      Summer Dragonfly\r\n * Project Contributors: 666666t\r\n *                       Anonymous0726\r\n *                       aphitorite\r\n *                       dani_dlg\r\n *                       EilrahcF\r\n *                       Enver\r\n *                       lovebuny\r\n *                       MP\r\n *                       phoenixbound\r\n *                       thatsOven\r\n *                       \r\n * Special thanks to \"The Studio\" Discord community!\r\n */\r\n\r\n// Credit to phoenixbound for this clever idea\r\n\r\nimport {Sort} from \"./Sort\";\r\n\r\nconst Subarray = {\r\n    LEFT: 1,\r\n    RIGHT: 2,\r\n};\r\n\r\n// REWRITTEN GRAILSORT FOR JAVASCRIPT - A heavily refactored C/C++-to-JavaScript version of\r\n//                                      Andrey Astrelin's GrailSort.h, aiming to be as\r\n//                                      readable and intuitive as possible.\r\n//\r\n// ** Written and maintained by The Holy Grail Sort Project\r\n//\r\n// Primary author: Enver\r\n//\r\n// Current status: Finished. Potentially 100% working... Passing most tests, some tests capped by V8 Engine memory allocation limits\r\n\r\nexport class GrailSort extends Sort {\r\n    // static GRAIL_STATIC_EXT_BUF_LEN = 512;\r\n\r\n    externalBuffer\r\n    externalBufferLen\r\n\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"GrailSort\"\r\n        this.isNeedBuffer = true;\r\n    }\r\n\r\n    grailSwap(a, b) {\r\n        // let temp = array[a];\r\n        // array[a] = array[b];\r\n        // array[b] = temp;\r\n        this.Writes.swap(a, b)\r\n    }\r\n\r\n    grailBlockSwap(a, b, blockLen) {\r\n        for (let i = 0; i < blockLen; i++) {\r\n            this.grailSwap(a + i, b + i);\r\n        }\r\n    }\r\n\r\n    // Object src, int srcPos, Object dest, int destPos, int length\r\n    // Custom method for copying parts of the array either:\r\n    //      within itself to a different destination, or\r\n    //      to another array\r\n    arraycopy(srcArray, srcPos, destArray, destPos, copyLen) {\r\n        this.Writes.arrayCopy(srcArray, srcPos, destArray, destPos, copyLen)\r\n    }\r\n\r\n    grailRotate(start, leftLen, rightLen) {\r\n        while (leftLen > 0 && rightLen > 0) {\r\n            if (leftLen <= rightLen) {\r\n                this.grailBlockSwap(start, start + leftLen, leftLen);\r\n                start += leftLen;\r\n                rightLen -= leftLen;\r\n            } else {\r\n                this.grailBlockSwap(start + leftLen - rightLen, start + leftLen, rightLen);\r\n                leftLen -= rightLen;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Variant of Insertion Sort that utilizes swaps instead of overwrites.\r\n    // Also known as \"Optimized Gnomesort\".\r\n    grailInsertSort(start, length) {\r\n        for (let item = 1; item < length; item++) {\r\n            let left = start + item - 1;\r\n            let right = start + item;\r\n\r\n            while (left >= start && this.Reads.compareInArr(left,\r\n                right) > 0) {\r\n                this.grailSwap(left, right);\r\n                left--;\r\n                right--;\r\n            }\r\n        }\r\n    }\r\n\r\n    grailBinarySearchLeft(start, length, target) {\r\n        let left = 0;\r\n        let right = length;\r\n        while (left < right) {\r\n            let middle = left + parseInt((right - left) / 2);\r\n            if (this.Reads.compareValues(this.Reads.readValue(start + middle), target) < 0) {\r\n                left = middle + 1;\r\n            } else {\r\n                right = middle;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n\r\n    // Credit to Anonymous0726 for debugging\r\n    grailBinarySearchRight(start, length, target) {\r\n        let left = 0;\r\n        let right = length;\r\n        while (left < right) {\r\n            let middle = left + parseInt((right - left) / 2);\r\n            if (this.Reads.compareValues(this.Reads.readValue(start + middle), target) > 0) {\r\n                right = middle;\r\n            } else {\r\n                left = middle + 1;\r\n            }\r\n        }\r\n        // OFF-BY-ONE BUG FIXED: used to be `return right - 1;`\r\n        return right;\r\n    }\r\n\r\n    // cost: 2 * length + idealKeys^2 / 2\r\n    grailCollectKeys(start, length, idealKeys) {\r\n        let keysFound = 1; // by itself, the first item in the array is our first unique key\r\n        let firstKey = 0; // the first item in the array is at the first position in the array\r\n        let currentKey = 1; // the index used for finding potentially unique items (\"keys\") in the array\r\n\r\n        while (currentKey < length && keysFound < idealKeys) {\r\n\r\n            // Find the location in the key-buffer where our current key can be inserted in sorted order.\r\n            // If the key at insertPos is equal to currentKey, then currentKey isn't unique and we move on.\r\n            let insertPos = this.grailBinarySearchLeft(start + firstKey, keysFound, this.Reads.readValue(start + currentKey));\r\n\r\n            // The second part of this conditional does the equal check we were just talking about; however,\r\n            // if currentKey is larger than everything in the key-buffer (meaning insertPos == keysFound),\r\n            // then that also tells us it wasn't *equal* to anything in the key-buffer. Magic! :) \r\n            if (insertPos === keysFound || this.Reads.compareInArr(start + currentKey,\r\n                start + firstKey + insertPos) !== 0) {\r\n\r\n                // First, rotate the key-buffer over to currentKey's immediate left...\r\n                // (this helps save a TON of swaps/writes!!!)\r\n                this.grailRotate(start + firstKey, keysFound, currentKey - (firstKey + keysFound));\r\n\r\n                // Update the new position of firstKey...\r\n                firstKey = currentKey - keysFound;\r\n\r\n                // Then, \"insertion sort\" currentKey to its spot in the key-buffer!\r\n                this.grailRotate(start + firstKey + insertPos, keysFound - insertPos, 1);\r\n\r\n                // One step closer to idealKeys.\r\n                keysFound++;\r\n            }\r\n            // Move on and test the next key...\r\n            currentKey++;\r\n        }\r\n\r\n        // Bring however many keys we found back to the beginning of our array,\r\n        // and return the number of keys collected.\r\n        this.grailRotate(start, firstKey, keysFound);\r\n        return keysFound;\r\n    }\r\n\r\n    grailPairwiseSwaps(start, length) {\r\n        let index;\r\n        for (index = 1; index < length; index += 2) {\r\n            let left = start + index - 1;\r\n            let right = start + index;\r\n\r\n            if (this.Reads.compareInArr(left, right) > 0) {\r\n                this.grailSwap(left - 2, right);\r\n                this.grailSwap(right - 2, left);\r\n            } else {\r\n                this.grailSwap(left - 2, left);\r\n                this.grailSwap(right - 2, right);\r\n            }\r\n        }\r\n\r\n        let left = start + index - 1;\r\n        if (left < start + length) {\r\n            this.grailSwap(left - 2, left);\r\n        }\r\n    }\r\n\r\n    grailPairwiseWrites(start, length) {\r\n        let index;\r\n        for (index = 1; index < length; index += 2) {\r\n            let left = start + index - 1;\r\n            let right = start + index;\r\n\r\n            if (this.Reads.compareInArr(left, right) > 0) {\r\n                this.Writes.write(left - 2, this.Reads.get(right))\r\n                this.Writes.write(right - 2, this.Reads.get(left))\r\n            } else {\r\n                this.Writes.write(left - 2, this.Reads.get(left))\r\n                this.Writes.write(right - 2, this.Reads.get(right))\r\n            }\r\n        }\r\n\r\n        let left = start + index - 1;\r\n        if (left < start + length) {\r\n            this.Writes.write(left - 2, this.Reads.get(left))\r\n        }\r\n    }\r\n\r\n    // array[buffer .. start - 1] <=> \"scrolling buffer\"\r\n    // \r\n    // \"scrolling buffer\" + array[start, middle - 1] + array[middle, end - 1]\r\n    // --> array[buffer, buffer + end - 1] + \"scrolling buffer\"\r\n    grailMergeForwards(start, leftLen, rightLen, bufferOffset) {\r\n        let left = start;\r\n        let middle = start + leftLen;\r\n        let right = middle;\r\n        let end = middle + rightLen;\r\n        let buffer = start - bufferOffset;\r\n\r\n        while (right < end) {\r\n            if (left === middle || this.Reads.compareInArr(left,\r\n                right) > 0) {\r\n\r\n                this.grailSwap(buffer, right);\r\n                right++;\r\n            } else {\r\n                this.grailSwap(buffer, left);\r\n                left++;\r\n            }\r\n            buffer++;\r\n        }\r\n\r\n        if (buffer !== left) {\r\n            this.grailBlockSwap(buffer, left, middle - left);\r\n        }\r\n    }\r\n\r\n    // credit to 666666t for thorough bug-checking/fixing\r\n    grailMergeBackwards(start, leftLen, rightLen, bufferOffset) {\r\n        let left = start + leftLen - 1;\r\n        let middle = left;\r\n        // OFF-BY-ONE BUG FIXED: used to be `let  right = middle + rightLen - 1;`\r\n        let right = middle + rightLen;\r\n        let end = start;\r\n        // OFF-BY-ONE BUG FIXED: used to be `let buffer = right  + bufferOffset - 1;`\r\n        let buffer = right + bufferOffset;\r\n\r\n        while (left >= end) {\r\n            if (right === middle || this.Reads.compareInArr(left,\r\n                right) > 0) {\r\n\r\n                this.grailSwap(buffer, left);\r\n                left--;\r\n            } else {\r\n                this.grailSwap(buffer, right);\r\n                right--;\r\n            }\r\n            buffer--;\r\n        }\r\n\r\n        if (right !== buffer) {\r\n            while (right > middle) {\r\n                this.grailSwap(buffer, right);\r\n                buffer--;\r\n                right--;\r\n            }\r\n        }\r\n    }\r\n\r\n    // array[buffer .. start - 1] <=> \"free space\"    \r\n    //\r\n    // \"free space\" + array[start, middle - 1] + array[middle, end - 1]\r\n    // --> array[buffer, buffer + end - 1] + \"free space\"\r\n    //\r\n    // FUNCTION RENAMED: More consistent with \"out-of-place\" being at the end\r\n    grailMergeOutOfPlace(start, leftLen, rightLen, bufferOffset) {\r\n        let left = start;\r\n        let middle = start + leftLen;\r\n        let right = middle;\r\n        let end = middle + rightLen;\r\n        let buffer = start - bufferOffset;\r\n\r\n        while (right < end) {\r\n            if (left === middle || this.Reads.compareInArr(left,\r\n                right) > 0) {\r\n\r\n                this.Writes.write(buffer, this.Reads.get(right))\r\n                right++;\r\n            } else {\r\n                this.Writes.write(buffer, this.Reads.get(left))\r\n                left++;\r\n            }\r\n            buffer++;\r\n        }\r\n\r\n        if (buffer !== left) {\r\n            while (left < middle) {\r\n                this.Writes.write(buffer, this.Reads.get(left))\r\n                buffer++;\r\n                left++;\r\n            }\r\n        }\r\n    }\r\n\r\n    grailBuildInPlace(start, length, currentMerge, bufferLen) {\r\n        for (let mergeLen = currentMerge; mergeLen < bufferLen; mergeLen *= 2) {\r\n            let mergeIndex;\r\n            let mergeEnd = start + length - (2 * mergeLen);\r\n            let bufferOffset = mergeLen;\r\n\r\n            for (mergeIndex = start; mergeIndex <= mergeEnd; mergeIndex += (2 * mergeLen)) {\r\n                this.grailMergeForwards(mergeIndex, mergeLen, mergeLen, bufferOffset);\r\n            }\r\n\r\n            let leftOver = length - (mergeIndex - start);\r\n\r\n            if (leftOver > mergeLen) {\r\n                this.grailMergeForwards(mergeIndex, mergeLen, leftOver - mergeLen, bufferOffset);\r\n            } else {\r\n                this.grailRotate(mergeIndex - mergeLen, mergeLen, leftOver);\r\n            }\r\n\r\n            start -= mergeLen;\r\n        }\r\n\r\n        let finalBlock = length % (2 * bufferLen);\r\n        let finalOffset = start + length - finalBlock;\r\n\r\n        if (finalBlock <= bufferLen) {\r\n            this.grailRotate(finalOffset, finalBlock, bufferLen);\r\n        } else {\r\n            this.grailMergeBackwards(finalOffset, bufferLen, finalBlock - bufferLen, bufferLen);\r\n        }\r\n\r\n        for (let mergeIndex = finalOffset - (2 * bufferLen); mergeIndex >= start; mergeIndex -= (2 * bufferLen)) {\r\n            this.grailMergeBackwards(mergeIndex, bufferLen, bufferLen, bufferLen);\r\n        }\r\n    }\r\n\r\n    grailBuildOutOfPlace(start, length, bufferLen, externLen) {\r\n        this.arraycopy(-1, start - externLen, this.externalBuffer, 0, externLen);\r\n\r\n        this.grailPairwiseWrites(start, length);\r\n        start -= 2;\r\n\r\n        let mergeLen;\r\n        for (mergeLen = 2; mergeLen < externLen; mergeLen *= 2) {\r\n            let mergeIndex;\r\n            let mergeEnd = start + length - (2 * mergeLen);\r\n            let bufferOffset = mergeLen;\r\n\r\n            for (mergeIndex = start; mergeIndex <= mergeEnd; mergeIndex += (2 * mergeLen)) {\r\n                this.grailMergeOutOfPlace(mergeIndex, mergeLen, mergeLen, bufferOffset);\r\n            }\r\n\r\n            let leftOver = length - (mergeIndex - start);\r\n\r\n            if (leftOver > mergeLen) {\r\n                this.grailMergeOutOfPlace(mergeIndex, mergeLen, leftOver - mergeLen, bufferOffset);\r\n            } else {\r\n                // TODO: Is this correct??\r\n                for (let offset = 0; offset < leftOver; offset++) {\r\n                    // array[mergeIndex + offset - mergeLen] = array[mergeIndex + offset];\r\n                    this.Writes.write(mergeIndex + offset - mergeLen, this.Reads.get(mergeIndex + offset))\r\n                }\r\n            }\r\n\r\n            start -= mergeLen;\r\n        }\r\n\r\n        this.arraycopy(this.externalBuffer, 0, -1, start + length, externLen);\r\n        this.grailBuildInPlace(start, length, mergeLen, bufferLen);\r\n    }\r\n\r\n    // build blocks of length 'bufferLen'\r\n    // input: [start - mergeLen, start - 1] elements are buffer\r\n    // output: first 'bufferLen' elements are buffer, blocks (2 * bufferLen) and last subblock sorted\r\n    grailBuildBlocks(start, length, bufferLen) {\r\n        if (this.externalBuffer != null) {\r\n            let externLen;\r\n\r\n            if (bufferLen < this.externalBufferLen) {\r\n                externLen = bufferLen;\r\n            } else {\r\n                // max power of 2 -- just in case\r\n                externLen = 1;\r\n                while ((externLen * 2) <= this.externalBufferLen) {\r\n                    externLen *= 2;\r\n                }\r\n            }\r\n\r\n            this.grailBuildOutOfPlace(start, length, bufferLen, externLen);\r\n        } else {\r\n            this.grailPairwiseSwaps(start, length);\r\n            this.grailBuildInPlace(start - 2, length, 2, bufferLen);\r\n        }\r\n    }\r\n\r\n    // Returns the final position of 'medianKey'.\r\n    grailBlockSelectSort(keys, start, medianKey, blockCount, blockLen) {\r\n        for (let block = 1; block < blockCount; block++) {\r\n            let left = block - 1;\r\n            let right = left;\r\n\r\n            for (let index = block; index < blockCount; index++) {\r\n                let compare = this.Reads.compareInArr(start + (right * blockLen),\r\n                    start + (index * blockLen));\r\n\r\n                if (compare > 0 || (compare == 0 && this.Reads.compareInArr(keys + right,\r\n                    keys + index) > 0)) {\r\n                    right = index;\r\n                }\r\n            }\r\n\r\n            if (right != left) {\r\n                // Swap the left and right selected blocks...\r\n                this.grailBlockSwap(start + (left * blockLen), start + (right * blockLen), blockLen);\r\n\r\n                // Swap the keys...\r\n                this.grailSwap(keys + left, keys + right);\r\n\r\n                // ...and follow the 'medianKey' if it was swapped\r\n\r\n                // ORIGINAL LOC: if(midkey==u-1 || midkey==p) midkey^=(u-1)^p;\r\n                // MASSIVE, MASSIVE credit to lovebuny for figuring this one out!\r\n                if (medianKey == left) {\r\n                    medianKey = right;\r\n                } else if (medianKey == right) {\r\n                    medianKey = left;\r\n                }\r\n            }\r\n        }\r\n\r\n        return medianKey;\r\n    }\r\n\r\n    // Swaps Grailsort's \"scrolling buffer\" from the right side of the array all the way back to 'start'.\r\n    // Costs O(n) operations.\r\n    //\r\n    // OFF-BY-ONE BUG FIXED: used to be `int index = start + resetLen`; credit to 666666t for debugging\r\n    grailInPlaceBufferReset(start, resetLen, bufferLen) {\r\n        for (let index = start + resetLen - 1; index >= start; index--) {\r\n            this.grailSwap(index, index - bufferLen);\r\n        }\r\n    }\r\n\r\n    // Shifts entire array over 'bufferSize' spaces to make room for the out-of-place merging buffer.\r\n    // Costs O(n) operations.\r\n    //\r\n    // OFF-BY-ONE BUG FIXED: used to be `int index = start + resetLen`; credit to 666666t for debugging\r\n    grailOutOfPlaceBufferReset(start, resetLen, bufferLen) {\r\n        for (let index = start + resetLen - 1; index >= start; index--) {\r\n            this.Writes.write(index, this.Reads.get(index - bufferLen))\r\n        }\r\n    }\r\n\r\n    // Rewinds Grailsort's \"scrolling buffer\" such that any items from a left subarray block left over by a \"smart merge\" are moved to\r\n    // the right of the buffer. This is used to maintain stability and to continue an ongoing merge that has run out of buffer space.\r\n    // Costs O(sqrt n) swaps in the *absolute* worst-case. \r\n    //\r\n    // NAMING IMPROVED: the left over items are in the middle of the merge while the buffer is at the end\r\n    grailInPlaceBufferRewind(start, leftOvers, buffer) {\r\n        while (leftOvers > start) {\r\n            leftOvers--;\r\n            buffer--;\r\n            this.grailSwap(buffer, leftOvers);\r\n        }\r\n    }\r\n\r\n    // Rewinds Grailsort's out-of-place buffer such that any items from a left subarray block left over by a \"smart merge\" are moved to\r\n    // the right of the buffer. This is used to maintain stability and to continue an ongoing merge that has run out of buffer space.\r\n    // Costs O(sqrt n) writes in the *absolute* worst-case.\r\n    //\r\n    // INCORRECT ORDER OF PARAMETERS BUG FIXED: `leftOvers` should be the middle, and `buffer` should be the end\r\n    grailOutOfPlaceBufferRewind(start, leftOvers, buffer) {\r\n        while (leftOvers > start) {\r\n            leftOvers--;\r\n            buffer--;\r\n            // array[buffer] = array[leftOvers];\r\n            this.Writes.write(buffer, this.Reads.get(leftOvers))\r\n        }\r\n    }\r\n\r\n    grailGetSubarray(currentKey, medianKey) {\r\n        if (this.Reads.compareInArr(currentKey, medianKey) < 0) {\r\n            return Subarray.LEFT;\r\n        } else {\r\n            return Subarray.RIGHT;\r\n        }\r\n    }\r\n\r\n    // FUNCTION RENAMED: more clear *which* left blocks are being counted\r\n    grailCountFinalLeftBlocks(offset, blockCount, blockLen) {\r\n        let leftBlocks = 0;\r\n\r\n        let firstRightBlock = offset + (blockCount * blockLen);\r\n        let prevLeftBlock = firstRightBlock - blockLen;\r\n\r\n        while (leftBlocks < blockCount && this.Reads.compareInArr(firstRightBlock,\r\n            prevLeftBlock) < 0) {\r\n            leftBlocks++;\r\n            prevLeftBlock -= blockLen;\r\n        }\r\n\r\n        return leftBlocks;\r\n    }\r\n\r\n    grailSmartMerge(start, leftLen, leftOrigin, rightLen, bufferOffset) {\r\n        let left = start;\r\n        let middle = start + leftLen;\r\n        let right = middle;\r\n        let end = middle + rightLen;\r\n        let buffer = start - bufferOffset;\r\n\r\n        if (leftOrigin == Subarray.LEFT) {\r\n            while (left < middle && right < end) {\r\n                if (this.Reads.compareInArr(left, right) <= 0) {\r\n                    this.grailSwap(buffer, left);\r\n                    left++;\r\n                } else {\r\n                    this.grailSwap(buffer, right);\r\n                    right++;\r\n                }\r\n                buffer++;\r\n            }\r\n        } else {\r\n            while (left < middle && right < end) {\r\n                if (this.Reads.compareInArr(left, right) < 0) {\r\n                    this.grailSwap(buffer, left);\r\n                    left++;\r\n                } else {\r\n                    this.grailSwap(buffer, right);\r\n                    right++;\r\n                }\r\n                buffer++;\r\n            }\r\n        }\r\n\r\n        if (left < middle) {\r\n            this.currentBlockLen = middle - left;\r\n            this.grailInPlaceBufferRewind(left, middle, end);\r\n        } else {\r\n            this.currentBlockLen = end - right;\r\n            if (leftOrigin == Subarray.LEFT) {\r\n                this.currentBlockOrigin = Subarray.RIGHT;\r\n            } else {\r\n                this.currentBlockOrigin = Subarray.LEFT;\r\n            }\r\n        }\r\n    }\r\n\r\n    grailSmartLazyMerge(start, leftLen, leftOrigin, rightLen) {\r\n        if (leftOrigin == Subarray.LEFT) {\r\n            if (this.Reads.compareInArr(start + leftLen - 1, start + leftLen) > 0) {\r\n                while (leftLen != 0) {\r\n                    let insertPos = this.grailBinarySearchLeft(start + leftLen, rightLen, this.Reads.readValue(start));\r\n\r\n                    if (insertPos != 0) {\r\n                        this.grailRotate(start, leftLen, insertPos);\r\n                        start += insertPos;\r\n                        rightLen -= insertPos;\r\n                    }\r\n\r\n                    if (rightLen == 0) {\r\n                        this.currentBlockLen = leftLen;\r\n                        return;\r\n                    } else {\r\n                        do {\r\n                            start++;\r\n                            leftLen--;\r\n                        } while (leftLen != 0 && this.Reads.compareInArr(start,\r\n                            start + leftLen) <= 0);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (this.Reads.compareInArr(start + leftLen - 1, start + leftLen) >= 0) {\r\n                while (leftLen != 0) {\r\n                    let insertPos = this.grailBinarySearchRight(start + leftLen, rightLen, this.Reads.readValue(start));\r\n\r\n                    if (insertPos != 0) {\r\n                        this.grailRotate(start, leftLen, insertPos);\r\n                        start += insertPos;\r\n                        rightLen -= insertPos;\r\n                    }\r\n\r\n                    if (rightLen == 0) {\r\n                        this.currentBlockLen = leftLen;\r\n                        return;\r\n                    } else {\r\n                        do {\r\n                            start++;\r\n                            leftLen--;\r\n                        } while (leftLen != 0 && this.Reads.compareInArr(start,\r\n                            start + leftLen) < 0);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.currentBlockLen = rightLen;\r\n        if (leftOrigin == Subarray.LEFT) {\r\n            this.currentBlockOrigin = Subarray.RIGHT;\r\n        } else {\r\n            this.currentBlockOrigin = Subarray.LEFT;\r\n        }\r\n    }\r\n\r\n    // FUNCTION RENAMED: more consistent with other \"out-of-place\" merges\r\n    grailSmartMergeOutOfPlace(start, leftLen, leftOrigin, rightLen, bufferOffset) {\r\n        let left = start;\r\n        let middle = start + leftLen;\r\n        let right = middle;\r\n        let end = middle + rightLen;\r\n        let buffer = start - bufferOffset;\r\n\r\n        if (leftOrigin == Subarray.LEFT) {\r\n            while (left < middle && right < end) {\r\n                if (this.Reads.compareInArr(left, right) <= 0) {\r\n                    this.Writes.write(buffer, this.Reads.get(left))\r\n                    left++;\r\n                } else {\r\n                    this.Writes.write(buffer, this.Reads.get(right))\r\n                    right++;\r\n                }\r\n                buffer++;\r\n            }\r\n        } else {\r\n            while (left < middle && right < end) {\r\n                if (this.Reads.compareInArr(left, right) < 0) {\r\n                    this.Writes.write(buffer, this.Reads.get(left))\r\n                    left++;\r\n                } else {\r\n                    this.Writes.write(buffer, this.Reads.get(right))\r\n                    right++;\r\n                }\r\n                buffer++;\r\n            }\r\n        }\r\n\r\n        if (left < middle) {\r\n            this.currentBlockLen = middle - left;\r\n            this.grailOutOfPlaceBufferRewind(left, middle, end);\r\n        } else {\r\n            this.currentBlockLen = end - right;\r\n            if (leftOrigin == Subarray.LEFT) {\r\n                this.currentBlockOrigin = Subarray.RIGHT;\r\n            } else {\r\n                this.currentBlockOrigin = Subarray.LEFT;\r\n            }\r\n        }\r\n    }\r\n\r\n    grailMergeBlocks(keys, medianKey, start, blockCount, blockLen, finalLeftBlocks, finalLen) {\r\n        let currentBlock;\r\n        let blockIndex = blockLen;\r\n\r\n        this.currentBlockLen = blockLen;\r\n        this.currentBlockOrigin = this.grailGetSubarray(keys, medianKey);\r\n\r\n        for (let keyIndex = 1; keyIndex < blockCount; keyIndex++, blockIndex += blockLen) {\r\n            currentBlock = blockIndex - this.currentBlockLen;\r\n\r\n            let nextBlockOrigin = this.grailGetSubarray(keys + keyIndex, medianKey);\r\n\r\n            if (nextBlockOrigin == this.currentBlockOrigin) {\r\n                this.grailBlockSwap(start + currentBlock - blockLen, start + currentBlock, this.currentBlockLen);\r\n                currentBlock = blockIndex;\r\n\r\n                this.currentBlockLen = blockLen;\r\n            } else {\r\n                this.grailSmartMerge(start + currentBlock, this.currentBlockLen, this.currentBlockOrigin, blockLen, blockLen);\r\n            }\r\n        }\r\n\r\n        currentBlock = blockIndex - this.currentBlockLen;\r\n\r\n        if (finalLen != 0) {\r\n            if (this.currentBlockOrigin == Subarray.RIGHT) {\r\n                this.grailBlockSwap(start + currentBlock - blockLen, start + currentBlock, this.currentBlockLen);\r\n                currentBlock = blockIndex;\r\n\r\n                this.currentBlockLen = blockLen * finalLeftBlocks;\r\n                this.currentBlockOrigin = Subarray.LEFT;\r\n            } else {\r\n                this.currentBlockLen += blockLen * finalLeftBlocks;\r\n            }\r\n\r\n            this.grailMergeForwards(start + currentBlock, this.currentBlockLen, finalLen, blockLen);\r\n        } else {\r\n            this.grailBlockSwap(start + currentBlock, start + currentBlock - blockLen, this.currentBlockLen);\r\n        }\r\n    }\r\n\r\n    grailLazyMergeBlocks(keys, medianKey, start, blockCount, blockLen, finalLeftBlocks, finalLen) {\r\n        let currentBlock;\r\n        let blockIndex = blockLen;\r\n\r\n        this.currentBlockLen = blockLen;\r\n        this.currentBlockOrigin = this.grailGetSubarray(keys, medianKey);\r\n\r\n        for (let keyIndex = 1; keyIndex < blockCount; keyIndex++, blockIndex += blockLen) {\r\n            currentBlock = blockIndex - this.currentBlockLen;\r\n\r\n            let nextBlockOrigin = this.grailGetSubarray(keys + keyIndex, medianKey);\r\n\r\n            if (nextBlockOrigin == this.currentBlockOrigin) {\r\n                currentBlock = blockIndex;\r\n\r\n                this.currentBlockLen = blockLen;\r\n            } else {\r\n                // These checks were included in the original code... but why???\r\n                if (blockLen != 0 && this.currentBlockLen != 0) {\r\n                    this.grailSmartLazyMerge(start + currentBlock, this.currentBlockLen, this.currentBlockOrigin, blockLen);\r\n                }\r\n            }\r\n        }\r\n\r\n        currentBlock = blockIndex - this.currentBlockLen;\r\n\r\n        if (finalLen != 0) {\r\n            if (this.currentBlockOrigin == Subarray.RIGHT) {\r\n                currentBlock = blockIndex;\r\n\r\n                this.currentBlockLen = blockLen * finalLeftBlocks;\r\n                this.currentBlockOrigin = Subarray.LEFT;\r\n            } else {\r\n                this.currentBlockLen += blockLen * finalLeftBlocks;\r\n            }\r\n\r\n            this.grailLazyMerge(start + currentBlock, this.currentBlockLen, finalLen);\r\n        }\r\n    }\r\n\r\n    grailMergeBlocksOutOfPlace(keys, medianKey, start, blockCount, blockLen, finalLeftBlocks, finalLen) {\r\n        let currentBlock;\r\n        let blockIndex = blockLen;\r\n\r\n        this.currentBlockLen = blockLen;\r\n        this.currentBlockOrigin = this.grailGetSubarray(keys, medianKey);\r\n\r\n        for (let keyIndex = 1; keyIndex < blockCount; keyIndex++, blockIndex += blockLen) {\r\n            currentBlock = blockIndex - this.currentBlockLen;\r\n\r\n            let nextBlockOrigin = this.grailGetSubarray(keys + keyIndex, medianKey);\r\n\r\n            if (nextBlockOrigin == this.currentBlockOrigin) {\r\n                this.arraycopy(-1, start + currentBlock, -1, start + currentBlock - blockLen, this.currentBlockLen);\r\n                currentBlock = blockIndex;\r\n\r\n                this.currentBlockLen = blockLen;\r\n            } else {\r\n                this.grailSmartMergeOutOfPlace(start + currentBlock, this.currentBlockLen, this.currentBlockOrigin, blockLen, blockLen);\r\n            }\r\n        }\r\n\r\n        currentBlock = blockIndex - this.currentBlockLen;\r\n\r\n        if (finalLen != 0) {\r\n            if (this.currentBlockOrigin == Subarray.RIGHT) {\r\n                this.arraycopy(-1, start + currentBlock, -1, start + currentBlock - blockLen, this.currentBlockLen);\r\n                currentBlock = blockIndex;\r\n\r\n                this.currentBlockLen = blockLen * finalLeftBlocks;\r\n                this.currentBlockOrigin = Subarray.LEFT;\r\n            } else {\r\n                this.currentBlockLen += blockLen * finalLeftBlocks;\r\n            }\r\n\r\n            this.grailMergeOutOfPlace(start + currentBlock, this.currentBlockLen, finalLen, blockLen);\r\n        } else {\r\n            this.arraycopy(-1, start + currentBlock, -1, start + currentBlock - blockLen, this.currentBlockLen);\r\n        }\r\n    }\r\n\r\n    //TODO: Double-check \"Merge Blocks\" arguments\r\n    grailCombineInPlace(keys, start, length, subarrayLen, blockLen, mergeCount, lastSubarray, buffer) {\r\n        for (let mergeIndex = 0; mergeIndex < mergeCount; mergeIndex++) {\r\n            let offset = start + (mergeIndex * (2 * subarrayLen));\r\n            let blockCount = parseInt((2 * subarrayLen) / blockLen);\r\n\r\n            this.grailInsertSort(keys, blockCount);\r\n\r\n            // INCORRECT PARAMETER BUG FIXED: `block select sort` should be using `offset`, not `start`\r\n            let medianKey = parseInt(subarrayLen / blockLen);\r\n            medianKey = this.grailBlockSelectSort(keys, offset, medianKey, blockCount, blockLen);\r\n\r\n            if (buffer) {\r\n                this.grailMergeBlocks(keys, keys + medianKey, offset, blockCount, blockLen, 0, 0);\r\n            } else {\r\n                this.grailLazyMergeBlocks(keys, keys + medianKey, offset, blockCount, blockLen, 0, 0);\r\n            }\r\n        }\r\n\r\n        // INCORRECT CONDITIONAL/PARAMETER BUG FIXED: Credit to 666666t for debugging.\r\n        if (lastSubarray != 0) {\r\n            let offset = start + (mergeCount * (2 * subarrayLen));\r\n            let rightBlocks = parseInt(lastSubarray / blockLen);\r\n\r\n            this.grailInsertSort(keys, rightBlocks + 1);\r\n\r\n            // INCORRECT PARAMETER BUG FIXED: `block select sort` should be using `offset`, not `start`\r\n            let medianKey = parseInt(subarrayLen / blockLen);\r\n            medianKey = this.grailBlockSelectSort(keys, offset, medianKey, rightBlocks, blockLen);\r\n\r\n            // MISSING BOUNDS CHECK BUG FIXED: `lastFragment` *can* be 0 if the `lastSubarray` is evenly\r\n            //                                 divided into blocks. This prevents Grailsort from going\r\n            //                                 out of bounds.\r\n            let lastFragment = lastSubarray % blockLen;\r\n            let leftBlocks;\r\n            if (lastFragment != 0) {\r\n                leftBlocks = this.grailCountFinalLeftBlocks(offset, rightBlocks, blockLen);\r\n            } else {\r\n                leftBlocks = 0;\r\n            }\r\n\r\n            let blockCount = rightBlocks - leftBlocks;\r\n\r\n            //TODO: Double-check if this micro-optimization works correctly like the original\r\n            if (blockCount == 0) {\r\n                let leftLength = leftBlocks * blockLen;\r\n\r\n                // INCORRECT PARAMETER BUG FIXED: these merges should be using `offset`, not `start`\r\n                if (buffer) {\r\n                    this.grailMergeForwards(offset, leftLength, lastFragment, blockLen);\r\n                } else {\r\n                    this.grailLazyMerge(offset, leftLength, lastFragment);\r\n                }\r\n            } else {\r\n                if (buffer) {\r\n                    this.grailMergeBlocks(keys, keys + medianKey, offset, blockCount, blockLen, leftBlocks, lastFragment);\r\n                } else {\r\n                    this.grailLazyMergeBlocks(keys, keys + medianKey, offset, blockCount, blockLen, leftBlocks, lastFragment);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (buffer) {\r\n            this.grailInPlaceBufferReset(start, length, blockLen);\r\n        }\r\n    }\r\n\r\n    grailCombineOutOfPlace(keys, start, length, subarrayLen, blockLen, mergeCount, lastSubarray) {\r\n        this.arraycopy(-1, start - blockLen, this.externalBuffer, 0, blockLen);\r\n\r\n        for (let mergeIndex = 0; mergeIndex < mergeCount; mergeIndex++) {\r\n            let offset = start + (mergeIndex * (2 * subarrayLen));\r\n            let blockCount = parseInt((2 * subarrayLen) / blockLen);\r\n\r\n            this.grailInsertSort(keys, blockCount);\r\n\r\n            // INCORRECT PARAMETER BUG FIXED: `block select sort` should be using `offset`, not `start`\r\n            let medianKey = parseInt(subarrayLen / blockLen);\r\n            medianKey = this.grailBlockSelectSort(keys, offset, medianKey, blockCount, blockLen);\r\n\r\n            this.grailMergeBlocksOutOfPlace(keys, keys + medianKey, offset, blockCount, blockLen, 0, 0);\r\n        }\r\n\r\n        // INCORRECT CONDITIONAL/PARAMETER BUG FIXED: Credit to 666666t for debugging.\r\n        if (lastSubarray != 0) {\r\n            let offset = start + (mergeCount * (2 * subarrayLen));\r\n            let rightBlocks = parseInt(lastSubarray / blockLen);\r\n\r\n            this.grailInsertSort(keys, rightBlocks + 1);\r\n\r\n            // INCORRECT PARAMETER BUG FIXED: `block select sort` should be using `offset`, not `start`\r\n            let medianKey = subarrayLen / blockLen;\r\n            medianKey = this.grailBlockSelectSort(keys, offset, medianKey, rightBlocks, blockLen);\r\n\r\n            // MISSING BOUNDS CHECK BUG FIXED: `lastFragment` *can* be 0 if the `lastSubarray` is evenly\r\n            //                                 divided into blocks. This prevents Grailsort from going\r\n            //                                 out of bounds.\r\n            let lastFragment = lastSubarray % blockLen;\r\n            let leftBlocks;\r\n            if (lastFragment != 0) {\r\n                leftBlocks = this.grailCountFinalLeftBlocks(offset, rightBlocks, blockLen);\r\n            } else {\r\n                leftBlocks = 0;\r\n            }\r\n\r\n            let blockCount = rightBlocks - leftBlocks;\r\n\r\n            if (blockCount == 0) {\r\n                // INCORRECT PARAMETER BUG FIXED: this merge should be using `offset`, not `start`\r\n                let leftLength = leftBlocks * blockLen;\r\n                this.grailMergeOutOfPlace(offset, leftLength, lastFragment, blockLen);\r\n            } else {\r\n                this.grailMergeBlocksOutOfPlace(keys, keys + medianKey, offset, blockCount, blockLen, leftBlocks, lastFragment);\r\n            }\r\n        }\r\n\r\n        this.grailOutOfPlaceBufferReset(start, length, blockLen);\r\n        this.arraycopy(this.externalBuffer, 0, -1, start - blockLen, blockLen);\r\n    }\r\n\r\n    // 'keys' are on the left side of array. Blocks of length 'subarrayLen' combined. We'll combine them in pairs\r\n    // 'subarrayLen' is a power of 2. (2 * subarrayLen / blockLen) keys are guaranteed\r\n    grailCombineBlocks(keys, start, length, subarrayLen, blockLen, buffer) {\r\n        let mergeCount = parseInt(length / (2 * subarrayLen));\r\n        let lastSubarray = parseInt(length % (2 * subarrayLen));\r\n\r\n        if (lastSubarray <= subarrayLen) {\r\n            length -= lastSubarray;\r\n            lastSubarray = 0;\r\n        }\r\n\r\n        // INCOMPLETE CONDITIONAL BUG FIXED: In order to combine blocks out-of-place, we must check if a full-sized\r\n        //                                   block fits into our external buffer.\r\n        if (buffer && blockLen <= this.externalBufferLen) {\r\n            this.grailCombineOutOfPlace(keys, start, length, subarrayLen, blockLen, mergeCount, lastSubarray);\r\n        } else {\r\n            this.grailCombineInPlace(keys, start, length, subarrayLen, blockLen, mergeCount, lastSubarray, buffer);\r\n        }\r\n    }\r\n\r\n    // \"Classic\" in-place merge sort using binary searches and rotations\r\n    //\r\n    // cost: min(leftLen, rightLen)^2 + max(leftLen, rightLen)\r\n    grailLazyMerge(start, leftLen, rightLen) {\r\n        if (leftLen < rightLen) {\r\n            while (leftLen != 0) {\r\n                let insertPos = this.grailBinarySearchLeft(start + leftLen, rightLen, this.Reads.readValue(start));\r\n\r\n                if (insertPos != 0) {\r\n                    this.grailRotate(start, leftLen, insertPos);\r\n                    start += insertPos;\r\n                    rightLen -= insertPos;\r\n                }\r\n\r\n                if (rightLen == 0) {\r\n                    break;\r\n                } else {\r\n                    do {\r\n                        start++;\r\n                        leftLen--;\r\n                    } while (leftLen != 0 && this.Reads.compareInArr(start,\r\n                        start + leftLen) <= 0);\r\n                }\r\n            }\r\n        } else {\r\n            let end = start + leftLen + rightLen - 1;\r\n            while (rightLen != 0) {\r\n                let insertPos = this.grailBinarySearchRight(start, leftLen, this.Reads.readValue(end));\r\n\r\n                if (insertPos != leftLen) {\r\n                    this.grailRotate(start + insertPos, leftLen - insertPos, rightLen);\r\n                    end -= leftLen - insertPos;\r\n                    leftLen = insertPos;\r\n                }\r\n\r\n                if (leftLen == 0) {\r\n                    break;\r\n                } else {\r\n                    let leftEnd = start + leftLen - 1;\r\n                    do {\r\n                        rightLen--;\r\n                        end--;\r\n                    } while (rightLen != 0 && this.Reads.compareInArr(leftEnd,\r\n                        end) <= 0);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    grailLazyStableSort(start, length) {\r\n        for (let index = 1; index < length; index += 2) {\r\n            let left = start + index - 1;\r\n            let right = start + index;\r\n\r\n            if (this.Reads.compareInArr(left, right) > 0) {\r\n                this.grailSwap(left, right);\r\n            }\r\n        }\r\n        for (let mergeLen = 2; mergeLen < length; mergeLen *= 2) {\r\n            let mergeIndex;\r\n            let mergeEnd = length - (2 * mergeLen);\r\n\r\n            for (mergeIndex = 0; mergeIndex <= mergeEnd; mergeIndex += (2 * mergeLen)) {\r\n                this.grailLazyMerge(start + mergeIndex, mergeLen, mergeLen);\r\n            }\r\n\r\n            let leftOver = length - mergeIndex;\r\n            if (leftOver > mergeLen) {\r\n                this.grailLazyMerge(start + mergeIndex, mergeLen, leftOver - mergeLen);\r\n            }\r\n        }\r\n    }\r\n\r\n    static calcMinKeys(numKeys, blockKeysSum) {\r\n        let minKeys = 1;\r\n        while (minKeys < numKeys && blockKeysSum != 0) {\r\n            minKeys *= 2;\r\n            blockKeysSum = parseInt(blockKeysSum / 8);\r\n        }\r\n        return minKeys;\r\n    }\r\n\r\n    grailCommonSort(start, length, extBuf, extBufLen) {\r\n        if (length < 16) {\r\n            this.grailInsertSort(start, length);\r\n            return;\r\n        } else {\r\n            let blockLen = 1;\r\n\r\n            // find the smallest power of two greater than or equal to\r\n            // the square root of the input's length\r\n            while ((blockLen * blockLen) < length) {\r\n                blockLen *= 2;\r\n            }\r\n\r\n            // '((a - 1) / b) + 1' is actually a clever and very efficient\r\n            // formula for the ceiling of (a / b)\r\n            //\r\n            // credit to Anonymous0726 for figuring this out!\r\n            let keyLen = parseInt((length - 1) / blockLen) + 1;\r\n\r\n            // Grailsort is hoping to find `2 * sqrt(n)` unique items\r\n            // throughout the array\r\n            let idealKeys = keyLen + blockLen;\r\n\r\n            //TODO: Clean up `start +` offsets\r\n            let keysFound = this.grailCollectKeys(start, length, idealKeys);\r\n\r\n            let idealBuffer;\r\n            if (keysFound < idealKeys) {\r\n                if (keysFound < 4) {\r\n                    // GRAILSORT STRATEGY 3 -- No block swaps or scrolling buffer; resort to Lazy Stable Sort\r\n                    this.grailLazyStableSort(start, length);\r\n                    return;\r\n                } else {\r\n                    // GRAILSORT STRATEGY 2 -- Block swaps with small scrolling buffer and/or lazy merges\r\n                    keyLen = blockLen;\r\n                    blockLen = 0;\r\n                    idealBuffer = false;\r\n\r\n                    while (keyLen > keysFound) {\r\n                        keyLen = parseInt(keyLen / 2);\r\n                    }\r\n                }\r\n            } else {\r\n                // GRAILSORT STRATEGY 1 -- Block swaps with scrolling buffer\r\n                idealBuffer = true;\r\n            }\r\n\r\n            let bufferEnd = blockLen + keyLen;\r\n            let bufferLen;\r\n            if (idealBuffer) {\r\n                bufferLen = blockLen;\r\n            } else {\r\n                bufferLen = keyLen;\r\n            }\r\n\r\n            if (idealBuffer && extBuf != null) {\r\n                // GRAILSORT + EXTRA SPACE\r\n                this.externalBuffer = extBuf;\r\n                this.externalBufferLen = extBufLen;\r\n            }\r\n\r\n            this.grailBuildBlocks(start + bufferEnd, length - bufferEnd, bufferLen);\r\n\r\n            while ((length - bufferEnd) > (2 * bufferLen)) {\r\n                bufferLen *= 2;\r\n\r\n                let currentBlockLen = blockLen;\r\n                let scrollingBuffer = idealBuffer;\r\n\r\n                if (!scrollingBuffer) {\r\n                    if (keyLen > 4 && (parseInt(keyLen / 8) * keyLen) >= bufferLen) {\r\n                        currentBlockLen = parseInt(keyLen / 2);\r\n                        scrollingBuffer = true;\r\n                    } else {\r\n                        let blockKeysSum = parseInt(bufferLen * keysFound) / 2;\r\n                        let minKeys = GrailSort.calcMinKeys(keyLen, blockKeysSum);\r\n\r\n                        currentBlockLen = parseInt(2 * bufferLen) / minKeys;\r\n                    }\r\n                }\r\n\r\n                this.grailCombineBlocks(start, start + bufferEnd, length - bufferEnd, bufferLen, currentBlockLen, scrollingBuffer);\r\n            }\r\n\r\n            this.grailInsertSort(start, bufferEnd);\r\n            this.grailLazyMerge(start, bufferEnd, length - bufferEnd);\r\n        }\r\n    }\r\n\r\n    grailSortInPlace(start, length) {\r\n        this.grailCommonSort(start, length, null, 0);\r\n    }\r\n\r\n    /*\r\n    grailSortStaticOOP(array, start, length) {\r\n        let buffer = Array.newInstance(array[0].getClass(), GRAIL_STATIC_EXT_BUF_LEN);\r\n        this.grailCommonSort(array, start, length, buffer, GRAIL_STATIC_EXT_BUF_LEN);\r\n    }\r\n    \r\n    grailSortDynamicOOP(array, start, length) {\r\n        let bufferLen = 1;\r\n        while((bufferLen * bufferLen) < length) {\r\n            bufferLen *= 2;\r\n        }\r\n\r\n        let buffer = Array.newInstance(array[0].getClass(), bufferLen);\r\n\r\n        this.grailCommonSort(array, start, length, buffer, bufferLen);\r\n    }*/\r\n    runSort(low, high, bucketsNum, bufferSize) {\r\n        // this.grailSortInPlace(low, high + 1)\r\n        if(bufferSize === 0){\r\n            this.grailSortInPlace(low, high + 1)\r\n        }else{\r\n            let buffer = this.Writes.createAuxArray(bufferSize)\r\n            console.log(\"WITH BUFFER!!!\")\r\n            this.grailCommonSort(low, high + 1, buffer, bufferSize)\r\n            this.Writes.removeAuxArray(buffer)\r\n        }\r\n    }\r\n}\r\n\r\n","import {Sort} from \"./Sort\";\r\nimport {HeapSort} from \"./HeapSort\";\r\nimport {InsertionSort} from \"./InsertionSort\";\r\n\r\nexport class IntroSort extends Sort {\r\n    middle\r\n    sizeThreshold = 16;\r\n\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"IntroSort\"\r\n    }\r\n\r\n    floorLogBaseTwo(a) {\r\n        return (Math.floor(Math.log(a) / Math.log(2)));\r\n    }\r\n\r\n// Swaps the median of arr[left], arr[mid], and arr[right] to index left.\r\n// taken from gcc source code found here: https://gcc.gnu.org/onlinedocs/gcc-4.7.2/libstdc++/api/a01462_source.html\r\n// gccmedianof3(left, mid, right) {\r\n//     if (this.Reads.compareInArr(left, mid) < 0) {\r\n//         if (this.Reads.compareInArr(mid, right)  < 0) {\r\n//             this.Writes.swap(left, mid);\r\n//         }\r\n//         else if (this.Reads.compareInArr(left, right) < 0) {\r\n//             this.Writes.swap(left, right);\r\n//         }\r\n//     }\r\n//     else if (this.Reads.compareInArr(left, right) < 0) {\r\n//         this.middle = left;\r\n//         // return arr[left];\r\n//         return this.Reads.getValue(left);\r\n//     }\r\n//     else if (this.Reads.compareInArr(mid, right)  < 0) {\r\n//         this.Writes.swap(left, right);\r\n//     }\r\n//     else {\r\n//         this.Writes.swap(left, mid);\r\n//     }\r\n//     this.middle = left;\r\n//     // Highlights.markArray(3, left);\r\n//     return this.Reads.readValue(left);\r\n// }\r\n\r\n    medianof3(left, mid, right) {\r\n        if (this.Reads.compareInArr(right, left) < 0) {\r\n            this.Writes.swap(left, right);\r\n        }\r\n        if (this.Reads.compareInArr(mid, left) < 0) {\r\n            this.Writes.swap(mid, left);\r\n        }\r\n        if (this.Reads.compareInArr(right, mid) < 0) {\r\n            this.Writes.swap(right, mid);\r\n        }\r\n        this.middle = mid;\r\n        return this.Reads.readValue(mid);\r\n    }\r\n\r\n    partition(lo, hi, x) {\r\n        let i = lo, j = hi;\r\n        while (true) {\r\n            // console.log(\"PARTITION LOOP!\")\r\n            // while (Reads.compareValues(a[i], x) == -1) {\r\n            while (this.Reads.compareValues(this.Reads.get(i), x) < 0) {\r\n                i++;\r\n            }\r\n\r\n            j--;\r\n\r\n            // while (Reads.compareValues(x, a[j]) == -1) {\r\n            while (this.Reads.compareValues(x, this.Reads.get(j)) < 0) {\r\n                // Highlights.markArray(2, j);\r\n                // Delays.sleep(0.5);\r\n                j--;\r\n            }\r\n\r\n            if (!(i < j)) {\r\n                // Highlights.markArray(1, i);\r\n                // Delays.sleep(0.5);\r\n                return i;\r\n            }\r\n\r\n            // Follow the pivot and highlight it.\r\n            // if(i == middle) {\r\n            //     Highlights.markArray(3, j);\r\n            // }\r\n            // if(j == middle) {\r\n            //     Highlights.markArray(3, i);\r\n            // }\r\n\r\n            this.Writes.swap(i, j);\r\n            i++;\r\n        }\r\n    }\r\n\r\n    introsortLoop(lo, hi, depthLimit) {\r\n        while (hi - lo > this.sizeThreshold) {\r\n            // console.log(\"INTROSORT LOOP!!!\")\r\n            // while (hi - lo > 1) {\r\n            if (depthLimit === 0) {\r\n                // this.Marks.clearAllMarks();\r\n                let heapSort = new HeapSort(this.arrayVisualizer)\r\n\r\n                heapSort.heapSort(lo, hi);\r\n                return;\r\n            }\r\n            depthLimit--;\r\n            let p = this.partition(lo, hi, this.medianof3(lo, lo + Math.trunc((hi - lo) / 2), hi - 1));\r\n            this.introsortLoop(p, hi, depthLimit);\r\n            hi = p;\r\n        }\r\n        return;\r\n    }\r\n\r\n\r\n    runSort(low, high) {\r\n        this.introsortLoop(low, high + 1, this.floorLogBaseTwo(high-low+1))\r\n        let insertionSort = new InsertionSort(this.arrayVisualizer)\r\n        insertionSort.runSort(low, high + 1)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class LLQuickSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"LLQuickSort\"\r\n    }\r\n    partition(lo, hi) {\r\n        let pivot = hi;\r\n        let i = lo;\r\n        for (let j = lo; j < hi; j++) {\r\n            if (this.Reads.compareInArr(j, pivot) < 0) {\r\n                this.Writes.swap(i, j);\r\n                i++;\r\n            }\r\n        }\r\n        this.Writes.swap(i, hi);\r\n        return i;\r\n    }\r\n\r\n    LLQuickSort(lo, hi) {\r\n        if (lo < hi) {\r\n            let p = this.partition(lo, hi);\r\n            this.LLQuickSort(lo, p - 1);\r\n            this.LLQuickSort(p + 1, hi);\r\n        }\r\n    }\r\n    runSort(low, high) {\r\n        this.LLQuickSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class LRQuickSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName=\"LRQuickSort\"\r\n    }\r\n\r\n    quickSort(p, r){\r\n        let pivot = Math.trunc(p + (r - p + 1) / 2);\r\n        let x = this.Reads.readValue(pivot);\r\n\r\n        let i = p;\r\n        let j = r;\r\n\r\n        while (i <= j) {\r\n            // while (this.Reads.readValue(i) < x){\r\n            while (this.Reads.compareValues(this.Reads.get(i), x) < 0){\r\n                i++;\r\n            }\r\n            // while (this.Reads.get(j) > x){\r\n            while (this.Reads.compareValues(this.Reads.get(j), x) > 0){\r\n                j--;\r\n            }\r\n\r\n            if (i <= j) {\r\n                this.Writes.swap(i, j);\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n\r\n        if(p < j) {\r\n            this.quickSort(p, j);\r\n        }\r\n        if(i < r) {\r\n            this.quickSort(i, r);\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.quickSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\nimport {Element} from \"../classes/Element\";\r\n\r\nexport class LSDRadixSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"LSD RadixSort\"\r\n        this.isNeedBucketsNum = true;\r\n    }\r\n\r\n    LSDRadixSort(bucketsNum) {\r\n        let len = this.arrayVisualizer.getArrLength()\r\n        let max = this.Reads.readValue(0);\r\n        for (let i = 1; i < len; ++i) {\r\n            let tmp = this.Reads.readValue(i)\r\n            if (max < tmp) {\r\n                max = tmp\r\n            }\r\n        }\r\n        let highestPower = Math.log(max) / Math.log(bucketsNum);\r\n\r\n        let registers = new Array(bucketsNum)\r\n        for (let i = 0; i < bucketsNum; i++) {\r\n            registers[i] = [];\r\n        }\r\n\r\n        for (let p = 0; p <= highestPower; p++) {\r\n            for (let i = 0; i < len; i++) {\r\n                let stabVal = Math.max(0, Math.min(this.Reads.readValue(i), len - 1))\r\n                let digit = Math.trunc(stabVal / (bucketsNum ** p) % bucketsNum)\r\n                // console.log(digit)\r\n                registers[digit].push(this.Reads.get(i))\r\n                //PseudoWrite\r\n            }\r\n\r\n\r\n            let tempArray = this.Writes.createAuxArray(len)\r\n            let tempWrite = new Array(len)\r\n            let radix = registers.length\r\n\r\n\r\n            let total = 0;\r\n            for (let index = 0; index < registers.length; index++) {\r\n                for (let i = 0; i < registers[index].length; i++) {\r\n                    this.Writes.write(total++, registers[index][i], tempArray)\r\n                }\r\n                registers[index] = []\r\n            }\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                let register = i % radix\r\n                let pos = (register * Math.trunc(len / radix) + Math.trunc(i / radix))\r\n\r\n                this.Writes.write(pos, this.Reads.get(pos, tempArray))\r\n                tempWrite[pos] = true\r\n            }\r\n            for (let i = 0; i < len; i++) {\r\n                if (!tempWrite[i]) {\r\n                    this.Writes.write(i, this.Reads.get(i, tempArray))\r\n                }\r\n            }\r\n\r\n            this.Writes.removeAuxArray(tempArray)\r\n\r\n        }\r\n\r\n    }\r\n\r\n    runSort(low, high, bucketsNum) {\r\n        this.LSDRadixSort(bucketsNum)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\nimport {Writes} from \"../ArrayAccess/Writes\";\r\n\r\nexport class MergeSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"MergeSort\"\r\n    }\r\n\r\n    merge(tmp, start, mid, end) {\r\n        if (start === mid) {\r\n            return\r\n        }\r\n\r\n        this.merge(tmp, start, Math.trunc((mid + start) / 2), mid);\r\n        this.merge(tmp, mid, Math.trunc((mid + end) / 2), end);\r\n\r\n        let low = start\r\n        let high = mid\r\n\r\n        for (let nxt = 0; nxt < end - start; nxt++) {\r\n            if (low >= mid && high >= end) break;\r\n\r\n            if (low < mid && high >= end) {\r\n                this.Writes.write(nxt, this.Reads.get(low++), tmp)\r\n            } else if (low >= mid && high < end) {\r\n                this.Writes.write(nxt, this.Reads.get(high++), tmp)\r\n            } else if (this.Reads.compareInArr(low, high, -1) <= 0) {\r\n                this.Writes.write(nxt, this.Reads.get(low++), tmp)\r\n            } else {\r\n                this.Writes.write(nxt, this.Reads.get(high++), tmp)\r\n            }\r\n        }\r\n        for (let i = 0; i < end - start; i++) {\r\n            this.Writes.write(start + i, this.Reads.get(i, tmp))\r\n        }\r\n\r\n    }\r\n\r\n    MergeSort(low, high) {\r\n        let tmp = this.Writes.createAuxArray(0)\r\n\r\n        let mid = low + (Math.trunc((high - low) / 2))\r\n\r\n        this.merge(tmp, low, mid, high+1)\r\n\r\n        this.Writes.removeAuxArray(tmp)\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.MergeSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\nimport {InsertionSort} from \"./InsertionSort\";\r\n\r\nexport class PseudoTimSort extends Sort {\r\n    MIN_MERGE\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"PseudoTimSort\"\r\n        this.MIN_MERGE = 32\r\n    }\r\n\r\n    minRunLength(n) {\r\n        let r = 0;\r\n        while (n >= this.MIN_MERGE)\r\n        {\r\n            r |= (n & 1);\r\n            n >>= 1;\r\n        }\r\n        return n + r;\r\n    }\r\n    merge(l, m, r) {\r\n        let len1 = m - l + 1, len2 = r - m;\r\n        let left = this.Writes.createAuxArray(len1);\r\n        let right = this.Writes.createAuxArray(len2);\r\n        for(let x = 0; x < len1; x++)\r\n        {\r\n            // left[x] = arr[l + x];\r\n            this.Writes.write(x, this.Reads.get(l + x), left)\r\n        }\r\n        for(let x = 0; x < len2; x++)\r\n        {\r\n            // right[x] = arr[m + 1 + x];\r\n            this.Writes.write(x, this.Reads.get(m + 1 + x), right)\r\n        }\r\n\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = l;\r\n\r\n        while (i < len1 && j < len2)\r\n        {\r\n            // if (left[i] <= right[j])\r\n            if(this.Reads.compareValues(this.Reads.get(i, left), this.Reads.get(j, right))<=0)\r\n            {\r\n                // arr[k] = left[i];\r\n                this.Writes.write(k, this.Reads.get(i, left))\r\n                i++;\r\n            }\r\n            else\r\n            {\r\n                // arr[k] = right[j];\r\n                this.Writes.write(k, this.Reads.get(j, right))\r\n                j++;\r\n            }\r\n            k++;\r\n        }\r\n\r\n        while (i < len1) {\r\n            // arr[k] = left[i];\r\n            this.Writes.write(k, this.Reads.get(i, left))\r\n            k++;\r\n            i++;\r\n        }\r\n\r\n        while (j < len2) {\r\n            this.Writes.write(k, this.Reads.get(j, right))\r\n            k++;\r\n            j++;\r\n        }\r\n        this.Writes.removeAuxArray(right)\r\n        this.Writes.removeAuxArray(left)\r\n    }\r\n\r\n    pseudoTimSort(n)\r\n    {\r\n        let minRun = this.minRunLength(this.MIN_MERGE);\r\n\r\n        for(let i = 0; i < n; i += minRun)\r\n        {\r\n            let insertionSort = new InsertionSort(this.arrayVisualizer)\r\n\r\n            insertionSort.runSort(i, 1+Math.min(\r\n                (i + this.MIN_MERGE - 1), (n - 1)));\r\n        }\r\n\r\n        for(let size = minRun; size < n; size = 2 * size) {\r\n            for(let left = 0; left < n; left += 2 * size) {\r\n                let mid = left + size - 1;\r\n                let right = Math.min((left + 2 * size - 1), (n - 1));\r\n                if(mid < right) {\r\n                    this.merge(left, mid, right);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.pseudoTimSort(high+1)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class SelectionSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"SelectionSort\"\r\n    }\r\n\r\n    SelectionSort() {\r\n        for (let i=0; i < this.arrLength; i++) {\r\n            let minIndex = i\r\n            for (let j=i; j < this.arrLength; j++) {\r\n                if (this.Reads.compareInArr(j, minIndex) < 0) {\r\n                    minIndex = j\r\n                }\r\n            }\r\n\r\n            if (this.Reads.compareInArr(i, minIndex) > 0) {\r\n                this.Writes.swap(i, minIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.SelectionSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class ShellSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"ShellSort\"\r\n    }\r\n\r\n    ShellSort() {\r\n        let n = this.arrLength;\r\n\r\n        for (let gap = Math.trunc(n / 2); gap > 0; gap = Math.trunc(gap / 2)) {\r\n            for (let i = gap; i < n; i++) {\r\n                let temp = this.Reads.get(i);\r\n\r\n                let j;\r\n                for (j = i; j >= gap && (this.Reads.compareValues(this.Reads.get(j - gap), temp) > 0); j -= gap) {\r\n                    this.Writes.write(j, this.Reads.get(j - gap))\r\n                }\r\n\r\n                this.Writes.write(j, temp)\r\n\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.ShellSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\nimport {BinaryInsertionSort} from \"./BinaryInsertionSort\";\r\nimport {BubbleSort} from \"./BubbleSort\";\r\n\r\nexport class SimpleSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"SimpleSort\"\r\n        this.warnLen = 200\r\n    }\r\n\r\n    minRunLength(n) {\r\n        let r = 0\r\n\r\n        while (n >= 16) {\r\n            r |= (n & 1)\r\n            n >>= 1\r\n        }\r\n\r\n        return n + r\r\n    }\r\n\r\n    merge(a1, a2, b1, b2){\r\n        let start = Math.min(a1, b1)\r\n        let end = Math.max(a2, b2)\r\n        let mid = b1\r\n        for(let i = start; i < b1; ++i){\r\n            if(this.Reads.compareValues(this.Reads.get(i), this.Reads.get(mid)) > 0){\r\n                this.Writes.swap(i, mid)\r\n\r\n                let first = this.Reads.get(mid)\r\n\r\n                let k = 1\r\n\r\n                while(this.Reads.compareValues(this.Reads.get(k+mid), first.getValue()) < 0 && k+mid < end){\r\n                    this.Writes.write(mid+k-1 , this.Reads.get(mid+k))\r\n                    k++\r\n                }\r\n\r\n\r\n                this.Writes.write(mid+k-1, first)\r\n            }\r\n        }\r\n    }\r\n\r\n    SimpleSort(low, high) {\r\n\r\n        let len = high - low\r\n\r\n\r\n        let minRun = this.minRunLength(len)\r\n\r\n        let binaryInsertion = new BinaryInsertionSort(this.arrayVisualizer)\r\n\r\n        for (let i = 0; i < len/minRun;++i){\r\n            binaryInsertion.binaryInsertionSort(i*minRun, Math.min((i+1)*minRun-1, len)+1, i*minRun)\r\n        }\r\n\r\n        let curSize = minRun\r\n\r\n        while(curSize < len){\r\n            for(let i = 0; i < len/curSize;i+=2) {\r\n                this.merge(curSize*i, curSize*(i+1), curSize*(i+1), curSize*(i+2))\r\n\r\n            }\r\n            curSize*=2\r\n        }\r\n\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.SimpleSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class SlowSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"SlowSort\"\r\n        this.warnLen = 50\r\n    }\r\n\r\n    SlowSort(i, j) {\r\n        if (i >= j) {\r\n            return;\r\n        }\r\n        let m = Math.floor((i + j) / 2);\r\n        this.SlowSort(i, m);\r\n        this.SlowSort(m + 1, j);\r\n        if (this.Reads.compareInArr(j, m) < 0) {\r\n            this.Writes.swap(j, m)\r\n        }\r\n        this.SlowSort(i, j - 1)\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.SlowSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class StoogeSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"StoogeSort\"\r\n        this.warnLen = 60\r\n    }\r\n\r\n    StoogeSort(i, j) {\r\n        if (this.Reads.compareInArr(i, j) > 0) {\r\n            this.Writes.swap(i, j)\r\n        }\r\n        if (j - i > 1) {\r\n            let t = Math.trunc((j - i + 1) / 3)\r\n            this.StoogeSort(i, j - t)\r\n            this.StoogeSort(i + t, j)\r\n            this.StoogeSort(i, j - t)\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.StoogeSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\n/**\r\n * Default minimum size of a run.\r\n */\r\nconst DEFAULT_MIN_MERGE = 32\r\n\r\n/**\r\n * Minimum ordered subsequece required to do galloping.\r\n */\r\nconst DEFAULT_MIN_GALLOPING = 7\r\n\r\n/**\r\n * Default tmp storage length. Can increase depending on the size of the\r\n * smallest run to merge.\r\n */\r\nconst DEFAULT_TMP_STORAGE_LENGTH = 256\r\n\r\n/**\r\n * Pre-computed powers of 10 for efficient lexicographic comparison of\r\n * small integers.\r\n */\r\nconst POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9]\r\n\r\nlet results\r\n\r\n/**\r\n * Estimate the logarithm base 10 of a small integer.\r\n *\r\n * @param {number} x - The integer to estimate the logarithm of.\r\n * @return {number} - The estimated logarithm of the integer.\r\n */\r\nconst log10 = x => x < 1e5\r\n    ? x < 1e2\r\n        ? x < 1e1\r\n            ? 0\r\n            : 1\r\n        : x < 1e4\r\n            ? x < 1e3\r\n                ? 2\r\n                : 3\r\n            : 4\r\n    : x < 1e7\r\n        ? x < 1e6\r\n            ? 5\r\n            : 6\r\n        : x < 1e9\r\n            ? x < 1e8\r\n                ? 7\r\n                : 8\r\n            : 9\r\n\r\n/**\r\n * Default alphabetical comparison of items.\r\n *\r\n * @param {string|object|number} a - First element to compare.\r\n * @param {string|object|number} b - Second element to compare.\r\n * @return {number} - A positive number if a.toString() > b.toString(), a\r\n * negative number if .toString() < b.toString(), 0 otherwise.\r\n */\r\nfunction alphabeticalCompare(a, b) {\r\n    if (a === b) {\r\n        return 0\r\n    }\r\n\r\n    if (~~a === a && ~~b === b) {\r\n        if (a === 0 || b === 0) {\r\n            return a < b ? -1 : 1\r\n        }\r\n\r\n        if (a < 0 || b < 0) {\r\n            if (b >= 0) {\r\n                return -1\r\n            }\r\n\r\n            if (a >= 0) {\r\n                return 1\r\n            }\r\n\r\n            a = -a\r\n            b = -b\r\n        }\r\n\r\n        const al = log10(a)\r\n        const bl = log10(b)\r\n\r\n        let t = 0\r\n\r\n        if (al < bl) {\r\n            a *= POWERS_OF_TEN[bl - al - 1]\r\n            b /= 10\r\n            t = -1\r\n        } else if (al > bl) {\r\n            b *= POWERS_OF_TEN[al - bl - 1]\r\n            a /= 10\r\n            t = 1\r\n        }\r\n\r\n        if (a === b) {\r\n            return t\r\n        }\r\n\r\n        return a < b ? -1 : 1\r\n    }\r\n\r\n    const aStr = String(a)\r\n    const bStr = String(b)\r\n\r\n    if (aStr === bStr) {\r\n        return 0\r\n    }\r\n\r\n    return aStr < bStr ? -1 : 1\r\n}\r\n\r\n/**\r\n * Compute minimum run length for TimSort\r\n *\r\n * @param {number} n - The size of the array to sort.\r\n */\r\nfunction minRunLength(n) {\r\n    let r = 0\r\n\r\n    while (n >= DEFAULT_MIN_MERGE) {\r\n        r |= (n & 1)\r\n        n >>= 1\r\n    }\r\n\r\n    return n + r\r\n}\r\n\r\n/**\r\n * Counts the length of a monotonically ascending or strictly monotonically\r\n * descending sequence (run) starting at array[lo] in the range [lo, hi). If\r\n * the run is descending it is made ascending.\r\n *\r\n * @param {array} array - The array to reverse.\r\n * @param {number} lo - First element in the range (inclusive).\r\n * @param {number} hi - Last element in the range.\r\n * @param {function} compare - Item comparison function.\r\n * @return {number} - The length of the run.\r\n */\r\n\r\nexport class TimSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n\r\n        this.minGallop = DEFAULT_MIN_GALLOPING\r\n\r\n        this.tmpStorageLength = this.arrLength < 2 * DEFAULT_TMP_STORAGE_LENGTH\r\n            ? this.arrLength >>> 1\r\n            : DEFAULT_TMP_STORAGE_LENGTH\r\n\r\n        // this.tmp = new Array(this.tmpStorageLength)\r\n        this.tmp = this.Writes.createAuxArray(this.tmpStorageLength)\r\n\r\n        this.stackLength = this.arrLength < 120\r\n            ? 5\r\n            : this.arrLength < 1542\r\n                ? 10\r\n                : this.arrLength < 119151\r\n                    ? 19\r\n                    : 40\r\n\r\n        this.runStart = new Array(this.stackLength)\r\n        this.runLength = new Array(this.stackLength)\r\n\r\n        this.stackSize = 0\r\n        this.sortName = \"TimSort\"\r\n    }\r\n\r\n    makeAscendingRun(lo, hi) {\r\n        let runHi = lo + 1\r\n\r\n        if (runHi === hi) {\r\n            return 1\r\n        }\r\n\r\n        // Descending\r\n        // if (compare(array[runHi++], array[lo]) < 0) {\r\n        if (this.Reads.compareInArr(runHi++, lo)<0) {\r\n            // while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\r\n            while (runHi < hi && this.Reads.compareInArr(runHi, runHi - 1)<0) {\r\n                runHi++\r\n            }\r\n\r\n            // this.reverseRun(array, lo, runHi)\r\n            this.reverseRun(lo, runHi)\r\n            // reverseRun(results, lo, runHi)\r\n            // Ascending\r\n        } else {\r\n            // while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\r\n            while (runHi < hi && this.Reads.compareInArr(runHi, runHi - 1)>=0) {\r\n                runHi++\r\n            }\r\n        }\r\n\r\n        return runHi - lo\r\n    }\r\n\r\n    /**\r\n     * Reverse an array in the range [lo, hi).\r\n     *\r\n     * @param {array} array - The array to reverse.\r\n     * @param {number} lo - First element in the range (inclusive).\r\n     * @param {number} hi - Last element in the range.\r\n     */\r\n\r\n\r\n    reverseRun(lo, hi) {\r\n        hi--\r\n\r\n        while (lo < hi) {\r\n            // const t = array[lo]\r\n            // array[lo++] = array[hi]\r\n            // array[hi--] = t\r\n            const t = this.Reads.get(lo)\r\n            this.Writes.write(lo++, this.Reads.get(hi))\r\n            this.Writes.write(hi--, t)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Perform the binary sort of the array in the range [lo, hi) where start is\r\n     * the first element possibly out of order.\r\n     *\r\n     * @param {array} array - The array to sort.\r\n     * @param {number} lo - First element in the range (inclusive).\r\n     * @param {number} hi - Last element in the range.\r\n     * @param {number} start - First element possibly out of order.\r\n     * @param {} compare - Item comparison function.\r\n     */\r\n\r\n\r\n    binaryInsertionSort(lo, hi, start) {\r\n        if (start === lo) {\r\n            start++\r\n        }\r\n\r\n        for (; start < hi; start++) {\r\n            // const pivot = array[start]\r\n            const pivot = this.Reads.get(start)\r\n\r\n            // const pivotIndex = results[start]\r\n\r\n            // Ranges of the array where pivot belongs\r\n            let left = lo\r\n            let right = start\r\n\r\n            /*\r\n             *   pivot >= array[i] for i in [lo, left)\r\n             *   pivot <  array[i] for i in  in [right, start)\r\n             */\r\n            while (left < right) {\r\n                const mid = (left + right) >>> 1\r\n\r\n                // if (compare(pivot, array[mid]) < 0) {\r\n                if (pivot.getValue() < this.Reads.readValue(mid)) {\r\n                    right = mid\r\n                } else {\r\n                    left = mid + 1\r\n                }\r\n            }\r\n\r\n            /*\r\n             * Move elements right to make room for the pivot. If there are elements\r\n             * equal to pivot, left points to the first slot after them: this is also\r\n             * a reason for which TimSort is stable\r\n             */\r\n            let n = start - left\r\n            // Switch is just an optimization for small arrays\r\n            switch (n) {\r\n                case 3:\r\n                    // array[left + 3] = array[left + 2]\r\n                    this.Writes.write(left + 3, this.Reads.get(left + 2))\r\n                /* falls through */\r\n                case 2:\r\n                    // array[left + 2] = array[left + 1]\r\n                    this.Writes.write(left + 2, this.Reads.get(left + 1))\r\n                /* falls through */\r\n                case 1:\r\n                    // array[left + 1] = array[left]\r\n                    this.Writes.write(left + 1, this.Reads.get(left))\r\n                    break\r\n                default:\r\n                    while (n > 0) {\r\n                        // array[left + n] = array[left + n - 1]\r\n                        this.Writes.write(left + n, this.Reads.get(left + n - 1))\r\n                        n--\r\n                    }\r\n            }\r\n\r\n            // array[left] = pivot\r\n            this.Writes.write(left, pivot)\r\n            // results[left] = pivotIndex\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find the position at which to insert a value in a sorted range. If the range\r\n     * contains elements equal to the value the leftmost element index is returned\r\n     * (for stability).\r\n     *\r\n     * @param {number} value - Value to insert.\r\n     * @param {array} array - The array in which to insert value.\r\n     * @param {number} start - First element in the range.\r\n     * @param {number} length - Length of the range.\r\n     * @param {number} hint - The index at which to begin the search.\r\n     * @param {function} compare - Item comparison function.\r\n     * @return {number} - The index where to insert value.\r\n     */\r\n\r\n\r\n    gallopLeft(value, arrIndex, start, length, hint) {\r\n        let lastOffset = 0\r\n        let maxOffset = 0\r\n        let offset = 1\r\n            // if (compare(value, array[start + hint]) > 0) {\r\n            if (value > this.Reads.readValue(start + hint, arrIndex)) {\r\n                maxOffset = length - hint\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint + offset]) > 0\r\n                    && value > this.Reads.readValue(start + hint + offset, arrIndex)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint\r\n                offset += hint\r\n\r\n                // value <= array[start + hint]\r\n            } else {\r\n                maxOffset = hint + 1\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint - offset]) <= 0\r\n                    // && value <= this.Reads.readValue(start + hint + offset)\r\n                    && value <= this.Reads.readValue(start + hint - offset, arrIndex)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                const tmp = lastOffset\r\n                lastOffset = hint - offset\r\n                offset = hint - tmp\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++\r\n            while (lastOffset < offset) {\r\n                const m = lastOffset + ((offset - lastOffset) >>> 1)\r\n\r\n                // if (compare(value, array[start + m]) > 0) {\r\n                if (value > this.Reads.readValue(start + m, arrIndex)) {\r\n                    lastOffset = m + 1\r\n                } else {\r\n                    offset = m\r\n                }\r\n            }\r\n\r\n        return offset\r\n    }\r\n\r\n    /**\r\n     * Find the position at which to insert a value in a sorted range. If the range\r\n     * contains elements equal to the value the rightmost element index is returned\r\n     * (for stability).\r\n     *\r\n     * @param {number} value - Value to insert.\r\n     * @param {array} array - The array in which to insert value.\r\n     * @param {number} start - First element in the range.\r\n     * @param {number} length - Length of the range.\r\n     * @param {number} hint - The index at which to begin the search.\r\n     * @param {function} compare - Item comparison function.\r\n     * @return {number} - The index where to insert value.\r\n     */\r\n\r\n\r\n    gallopRight(value, arrIndex, start, length, hint) {\r\n        let lastOffset = 0\r\n        let maxOffset = 0\r\n        let offset = 1\r\n\r\n            // if (compare(value, array[start + hint]) < 0) {\r\n            if (value < this.Reads.readValue(start + hint, arrIndex)) {\r\n                maxOffset = hint + 1\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint - offset]) < 0\r\n                    && value < this.Reads.readValue(start + hint - offset, arrIndex)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                const tmp = lastOffset\r\n                lastOffset = hint - offset\r\n                offset = hint - tmp\r\n\r\n                // value >= array[start + hint]\r\n            } else {\r\n                maxOffset = length - hint\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint + offset]) >= 0\r\n                    && value >= this.Reads.readValue(start + hint + offset, arrIndex)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint\r\n                offset += hint\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++\r\n\r\n            while (lastOffset < offset) {\r\n                const m = lastOffset + ((offset - lastOffset) >>> 1)\r\n\r\n                // if (compare(value, array[start + m]) < 0) {\r\n                if (value < this.Reads.readValue(start + m, arrIndex)) {\r\n                    offset = m\r\n                } else {\r\n                    lastOffset = m + 1\r\n                }\r\n            }\r\n\r\n        \r\n\r\n        return offset\r\n    }\r\n\r\n\r\n    /**\r\n     * Push a new run on TimSort's stack.\r\n     *\r\n     * @param {number} runStart - Start index of the run in the original array.\r\n     * @param {number} runLength - Length of the run;\r\n     */\r\n    pushRun(runStart, runLength) {\r\n        this.runStart[this.stackSize] = runStart\r\n        this.runLength[this.stackSize] = runLength\r\n        this.stackSize += 1\r\n    }\r\n\r\n    /**\r\n     * Merge runs on TimSort's stack so that the following holds for all i:\r\n     * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]\r\n     * 2) runLength[i - 2] > runLength[i - 1]\r\n     */\r\n    mergeRuns() {\r\n        while (this.stackSize > 1) {\r\n            let n = this.stackSize - 2\r\n\r\n            if (\r\n                (\r\n                    n >= 1\r\n                    && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1]\r\n                )\r\n                || (\r\n                    n >= 2\r\n                    && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]\r\n                )\r\n            ) {\r\n                if (this.runLength[n - 1] < this.runLength[n + 1]) {\r\n                    n--\r\n                }\r\n            } else if (this.runLength[n] > this.runLength[n + 1]) {\r\n                break\r\n            }\r\n            this.mergeAt(n)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge all runs on TimSort's stack until only one remains.\r\n     */\r\n    forceMergeRuns() {\r\n        while (this.stackSize > 1) {\r\n            let n = this.stackSize - 2\r\n\r\n            if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {\r\n                n--\r\n            }\r\n\r\n            this.mergeAt(n)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge the runs on the stack at positions i and i+1. Must be always be called\r\n     * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).\r\n     *\r\n     * @param {number} i - Index of the run to merge in TimSort's stack.\r\n     */\r\n    mergeAt(i) {\r\n        let start1 = this.runStart[i]\r\n        let length1 = this.runLength[i]\r\n        const start2 = this.runStart[i + 1]\r\n        let length2 = this.runLength[i + 1]\r\n\r\n        this.runLength[i] = length1 + length2\r\n\r\n        if (i === this.stackSize - 3) {\r\n            this.runStart[i + 1] = this.runStart[i + 2]\r\n            this.runLength[i + 1] = this.runLength[i + 2]\r\n        }\r\n\r\n        this.stackSize--\r\n\r\n        /*\r\n         * Find where the first element in the second run goes in run1. Previous\r\n         * elements in run1 are already in place\r\n         */\r\n        // const k = gallopRight(array[start2], array, start1, length1, 0, compare)\r\n        const k = this.gallopRight(this.Reads.readValue(start2), -1, start1, length1, 0)\r\n        start1 += k\r\n        length1 -= k\r\n\r\n        if (length1 === 0) {\r\n            return\r\n        }\r\n\r\n        /*\r\n         * Find where the last element in the first run goes in run2. Next elements\r\n         * in run2 are already in place\r\n         */\r\n        // length2 = gallopLeft(\r\n        //     array[start1 + length1 - 1],\r\n        //     array,\r\n        //     start2,\r\n        //     length2,\r\n        //     length2 - 1,\r\n        //     compare\r\n        // )\r\n        length2 = this.gallopLeft(\r\n            // array[start1 + length1 - 1],\r\n            this.Reads.readValue(start1 + length1 - 1),\r\n            -1,\r\n            start2,\r\n            length2,\r\n            length2 - 1,\r\n        )\r\n\r\n        if (length2 === 0) {\r\n            return\r\n        }\r\n\r\n        /*\r\n         * Merge remaining runs. A tmp array with length = min(length1, length2) is\r\n         * used\r\n         */\r\n        if (length1 <= length2) {\r\n            this.mergeLow(start1, length1, start2, length2)\r\n        } else {\r\n            this.mergeHigh(start1, length1, start2, length2)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge two adjacent runs in a stable way. The runs must be such that the\r\n     * first element of run1 is bigger than the first element in run2 and the\r\n     * last element of run1 is greater than all the elements in run2.\r\n     * The method should be called when run1.length <= run2.length as it uses\r\n     * TimSort temporary array to store run1. Use mergeHigh if run1.length >\r\n     * run2.length.\r\n     *\r\n     * @param {number} start1 - First element in run1.\r\n     * @param {number} length1 - Length of run1.\r\n     * @param {number} start2 - First element in run2.\r\n     * @param {number} length2 - Length of run2.\r\n     */\r\n    mergeLow(start1, length1, start2, length2) {\r\n        // const {compare} = this\r\n        // const {array} = this\r\n        // const {tmp} = this\r\n        // const {tmpIndex} = this\r\n        // const {compare} = this\r\n        // const {array} = this\r\n        // const {tmp} = this\r\n        // const {tmpIndex} = this\r\n        let i = 0\r\n\r\n        for (i = 0; i < length1; i++) {\r\n            // tmp[i] = array[start1 + i]\r\n            this.Writes.write(i, this.Reads.get(start1 + i), this.tmp)\r\n        }\r\n\r\n        let cursor1 = 0\r\n        let cursor2 = start2\r\n        let dest = start1\r\n\r\n\r\n        // array[dest] = array[cursor2]\r\n        this.Writes.write(dest, this.Reads.get(cursor2))\r\n\r\n\r\n        dest++\r\n        cursor2++\r\n\r\n        if (--length2 === 0) {\r\n            for (i = 0; i < length1; i++) {\r\n                // array[dest + i] = tmp[cursor1 + i]\r\n                this.Writes.write(dest + i, this.Reads.get(cursor1 + i, this.tmp))\r\n            }\r\n            return\r\n        }\r\n\r\n        if (length1 === 1) {\r\n            for (i = 0; i < length2; i++) {\r\n                // array[dest + i] = array[cursor2 + i]\r\n\r\n                this.Writes.write(dest + i, this.Reads.get(cursor2 + i))\r\n            }\r\n            // array[dest + length2] = tmp[cursor1]\r\n            this.Writes.write(dest + length2, this.Reads.get(cursor1, this.tmp))\r\n            return\r\n        }\r\n\r\n        let {minGallop} = this\r\n\r\n        while (true) {\r\n            let count1 = 0\r\n            let count2 = 0\r\n            let exit = false\r\n\r\n            do {\r\n                // if (compare(array[cursor2], tmp[cursor1]) < 0) {\r\n                if (this.Reads.readValue(cursor2) < this.Reads.readValue(cursor1, this.tmp)) {\r\n                    // array[dest] = array[cursor2]\r\n                    this.Writes.write(dest, this.Reads.get(cursor2))\r\n                    dest++\r\n                    cursor2++\r\n                    count2++\r\n                    count1 = 0\r\n\r\n                    if (--length2 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                } else {\r\n                    // array[dest] = tmp[cursor1]\r\n                    this.Writes.write(dest, this.Reads.get(cursor1, this.tmp))\r\n\r\n                    dest++\r\n                    cursor1++\r\n                    count1++\r\n                    count2 = 0\r\n                    if (--length1 === 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n            } while ((count1 | count2) < minGallop)\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            do {\r\n                // count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare)\r\n                count1 = this.gallopRight(this.Reads.readValue(cursor2), this.tmp, cursor1, length1, 0)\r\n\r\n                if (count1 !== 0) {\r\n                    for (i = 0; i < count1; i++) {\r\n                        // array[dest + i] = tmp[cursor1 + i]\r\n                        // results[dest + i] = tmpIndex[cursor1 + i]\r\n                        this.Writes.write(dest + i, this.Reads.get(cursor1 + i, this.tmp))\r\n                    }\r\n\r\n                    dest += count1\r\n                    cursor1 += count1\r\n                    length1 -= count1\r\n                    if (length1 <= 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n\r\n                // array[dest] = array[cursor2]\r\n                // results[dest] = results[cursor2]\r\n                this.Writes.write(dest, this.Reads.get(cursor2))\r\n\r\n                dest++\r\n                cursor2++\r\n\r\n                if (--length2 === 0) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                // count2 = this.gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare)\r\n                count2 = this.gallopLeft(this.Reads.readValue(cursor1, this.tmp), -1, cursor2, length2, 0)\r\n\r\n                if (count2 !== 0) {\r\n                    for (i = 0; i < count2; i++) {\r\n                        // array[dest + i] = array[cursor2 + i]\r\n                        // results[dest + i] = results[cursor2 + i]\r\n                        this.Writes.write(dest + i, this.Reads.get(cursor2 + i))\r\n                    }\r\n\r\n                    dest += count2\r\n                    cursor2 += count2\r\n                    length2 -= count2\r\n\r\n                    if (length2 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n                // array[dest] = tmp[cursor1]\r\n                // results[dest] = tmpIndex[cursor1]\r\n\r\n                this.Writes.write(dest, this.Reads.get(cursor1, this.tmp))\r\n\r\n                dest++\r\n                cursor1++\r\n\r\n                if (--length1 === 1) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                minGallop--\r\n            } while (\r\n                count1 >= DEFAULT_MIN_GALLOPING\r\n                || count2 >= DEFAULT_MIN_GALLOPING\r\n                )\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            if (minGallop < 0) {\r\n                minGallop = 0\r\n            }\r\n\r\n            minGallop += 2\r\n        }\r\n\r\n        this.minGallop = minGallop\r\n\r\n        if (minGallop < 1) {\r\n            this.minGallop = 1\r\n        }\r\n\r\n        if (length1 === 1) {\r\n            for (i = 0; i < length2; i++) {\r\n                // array[dest + i] = array[cursor2 + i]\r\n                // results[dest + i] = results[cursor2 + i]\r\n                this.Writes.write(dest + i, this.Reads.get(cursor2 + i))\r\n            }\r\n            // array[dest + length2] = tmp[cursor1]\r\n            // results[dest + length2] = tmpIndex[cursor1]\r\n            this.Writes.write(dest + length2, this.Reads.get(cursor1, this.tmp))\r\n        } else if (length1 === 0) {\r\n            throw new Error('mergeLow preconditions were not respected')\r\n        } else {\r\n            for (i = 0; i < length1; i++) {\r\n                // array[dest + i] = tmp[cursor1 + i]\r\n                // results[dest + i] = tmpIndex[cursor1 + i]\r\n                this.Writes.write(dest + i, this.Reads.get(cursor1 + i, this.tmp))\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge two adjacent runs in a stable way. The runs must be such that the\r\n     * first element of run1 is bigger than the first element in run2 and the\r\n     * last element of run1 is greater than all the elements in run2.\r\n     * The method should be called when run1.length > run2.length as it uses\r\n     * TimSort temporary array to store run2. Use mergeLow if run1.length <=\r\n     * run2.length.\r\n     *\r\n     * @param {number} start1 - First element in run1.\r\n     * @param {number} length1 - Length of run1.\r\n     * @param {number} start2 - First element in run2.\r\n     * @param {number} length2 - Length of run2.\r\n     */\r\n    mergeHigh(start1, length1, start2, length2) {\r\n        // const {compare} = this\r\n        // const {array} = this\r\n        // const {tmp} = this\r\n        // const {tmpIndex} = this\r\n        let i = 0\r\n\r\n        for (i = 0; i < length2; i++) {\r\n            // tmp[i] = array[start2 + i]\r\n            this.Writes.write(i, this.Reads.get(start2 + i), this.tmp)\r\n        }\r\n\r\n        let cursor1 = start1 + length1 - 1\r\n        let cursor2 = length2 - 1\r\n        let dest = start2 + length2 - 1\r\n        let customCursor = 0\r\n        let customDest = 0\r\n\r\n        // array[dest] = array[cursor1]\r\n        this.Writes.write(dest, this.Reads.get(cursor1))\r\n\r\n        dest--\r\n        cursor1--\r\n\r\n        if (--length1 === 0) {\r\n            customCursor = dest - (length2 - 1)\r\n\r\n            for (i = 0; i < length2; i++) {\r\n                // array[customCursor + i] = tmp[i]\r\n                this.Writes.write(customCursor + i, this.Reads.get(i, this.tmp))\r\n            }\r\n\r\n            return\r\n        }\r\n\r\n        if (length2 === 1) {\r\n            dest -= length1\r\n            cursor1 -= length1\r\n            customDest = dest + 1\r\n            customCursor = cursor1 + 1\r\n\r\n            for (i = length1 - 1; i >= 0; i--) {\r\n                // array[customDest + i] = array[customCursor + i]\r\n                this.Writes.write(customDest + i, this.Reads.get(customCursor + i))\r\n            }\r\n\r\n            // array[dest] = tmp[cursor2]\r\n            this.Writes.write(dest, this.Reads.get(cursor2, this.tmp))\r\n            return\r\n        }\r\n\r\n        let {minGallop} = this\r\n\r\n        while (true) {\r\n            let count1 = 0\r\n            let count2 = 0\r\n            let exit = false\r\n\r\n            do {\r\n                // if (compare(tmp[cursor2], array[cursor1]) < 0) {\r\n                if (this.Reads.readValue(cursor2, this.tmp) < this.Reads.readValue(cursor1)) {\r\n                    // array[dest] = array[cursor1]\r\n                    this.Writes.write(dest, this.Reads.get(cursor1))\r\n                    dest--\r\n                    cursor1--\r\n                    count1++\r\n                    count2 = 0\r\n                    if (--length1 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                } else {\r\n                    // array[dest] = tmp[cursor2]\r\n                    this.Writes.write(dest, this.Reads.get(cursor2, this.tmp))\r\n                    dest--\r\n                    cursor2--\r\n                    count2++\r\n                    count1 = 0\r\n                    if (--length2 === 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n            } while ((count1 | count2) < minGallop)\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            do {\r\n                // count1 = length1 - gallopRight(\r\n                //     tmp[cursor2],\r\n                //     array,\r\n                //     start1,\r\n                //     length1,\r\n                //     length1 - 1,\r\n                //     compare\r\n                // )\r\n                count1 = length1 - this.gallopRight(\r\n                    this.Reads.readValue(cursor2, this.tmp),\r\n                    -1,\r\n                    start1,\r\n                    length1,\r\n                    length1 - 1\r\n                )\r\n\r\n                if (count1 !== 0) {\r\n                    dest -= count1\r\n                    cursor1 -= count1\r\n                    length1 -= count1\r\n                    customDest = dest + 1\r\n                    customCursor = cursor1 + 1\r\n\r\n                    for (i = count1 - 1; i >= 0; i--) {\r\n                        // array[customDest + i] = array[customCursor + i]\r\n                        this.Writes.write(customDest + i, this.Reads.get(customCursor + i))\r\n                    }\r\n\r\n                    if (length1 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n\r\n                // array[dest] = tmp[cursor2]\r\n                this.Writes.write(dest, this.Reads.get(cursor2, this.tmp))\r\n\r\n                dest--\r\n                cursor2--\r\n\r\n                if (--length2 === 1) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                // count2 = length2 - gallopLeft(\r\n                //     array[cursor1],\r\n                //     tmp,\r\n                //     0,\r\n                //     length2,\r\n                //     length2 - 1,\r\n                //     compare\r\n                // )\r\n\r\n                count2 = length2 - this.gallopLeft(\r\n                    this.Reads.readValue(cursor1),\r\n                    this.tmp,\r\n                    0,\r\n                    length2,\r\n                    length2 - 1\r\n                )\r\n\r\n                if (count2 !== 0) {\r\n                    dest -= count2\r\n                    cursor2 -= count2\r\n                    length2 -= count2\r\n                    customDest = dest + 1\r\n                    customCursor = cursor2 + 1\r\n\r\n                    for (i = 0; i < count2; i++) {\r\n                        // array[customDest + i] = tmp[customCursor + i]\r\n                        this.Writes.write(customDest + i, this.Reads.get(customCursor + i, this.tmp))\r\n                    }\r\n\r\n                    if (length2 <= 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n\r\n                // array[dest] = array[cursor1]\r\n                this.Writes.write(dest, this.Reads.get(cursor1))\r\n\r\n                dest--\r\n                cursor1--\r\n\r\n                if (--length1 === 0) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                minGallop--\r\n            } while (\r\n                count1 >= DEFAULT_MIN_GALLOPING\r\n                || count2 >= DEFAULT_MIN_GALLOPING\r\n                )\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            if (minGallop < 0) {\r\n                minGallop = 0\r\n            }\r\n\r\n            minGallop += 2\r\n        }\r\n\r\n        this.minGallop = minGallop\r\n\r\n        if (minGallop < 1) {\r\n            this.minGallop = 1\r\n        }\r\n\r\n        if (length2 === 1) {\r\n            dest -= length1\r\n            cursor1 -= length1\r\n            customDest = dest + 1\r\n            customCursor = cursor1 + 1\r\n\r\n            for (i = length1 - 1; i >= 0; i--) {\r\n                // array[customDest + i] = array[customCursor + i]\r\n                this.Writes.write(customDest + i, this.Reads.get(customCursor + i))\r\n            }\r\n\r\n            // array[dest] = tmp[cursor2]\r\n            // results[dest] = tmpIndex[cursor2]\r\n\r\n            this.Writes.write(dest, this.Reads.get(cursor2, this.tmp))\r\n\r\n\r\n        } else if (length2 === 0) {\r\n            throw new Error('mergeHigh preconditions were not respected')\r\n        } else {\r\n            customCursor = dest - (length2 - 1)\r\n            for (i = 0; i < length2; i++) {\r\n                // array[customCursor + i] = tmp[i]\r\n                this.Writes.write(customCursor + i, this.Reads.get(i, this.tmp))\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Sort an array in the range [lo, hi) using TimSort.\r\n     *\r\n     * @param {array} array - The array to sort.\r\n     * @param {function=} compare - Item comparison function. Default is\r\n     *     alphabetical\r\n     * @param {number} lo - First element in the range (inclusive).\r\n     * @param {number} hi - Last element in the range.\r\n     *     comparator.\r\n     */\r\n    runSort(low, high) {\r\n        this.sort(low, high+1)\r\n    }\r\n\r\n    sort(lo, hi) {\r\n\r\n        let i = 0\r\n\r\n        let remaining = hi - lo\r\n\r\n        // The array is already sorted\r\n        if (remaining < 2) {\r\n            return results\r\n        }\r\n\r\n        let runLength = 0\r\n        // On small arrays binary sort can be used directly\r\n        if (remaining < DEFAULT_MIN_MERGE) {\r\n            runLength = this.makeAscendingRun(lo, hi)\r\n            this.binaryInsertionSort(lo, hi, lo + runLength)\r\n        }\r\n\r\n\r\n        const minRun = minRunLength(remaining)\r\n\r\n        do {\r\n            runLength = this.makeAscendingRun(lo, hi)\r\n            if (runLength < minRun) {\r\n                let force = remaining\r\n                if (force > minRun) {\r\n                    force = minRun\r\n                }\r\n\r\n                this.binaryInsertionSort(lo, lo + force, lo + runLength)\r\n                runLength = force\r\n            }\r\n            // Push new run and merge if necessary\r\n            this.pushRun(lo, runLength)\r\n            this.mergeRuns()\r\n\r\n            // Go find next run\r\n            remaining -= runLength\r\n            lo += runLength\r\n        } while (remaining !== 0)\r\n\r\n        // Force merging of remaining runs\r\n        this.forceMergeRuns()\r\n        this.Writes.removeAuxArray(this.tmp)\r\n    }\r\n}","/*\r\n *\r\nThis is free and unencumbered software released into the public domain.\r\n\r\nAnyone is free to copy, modify, publish, use, compile, sell, or\r\ndistribute this software, either in source code form or as a compiled\r\nbinary, for any purpose, commercial or non-commercial, and by any\r\nmeans.\r\n\r\nIn jurisdictions that recognize copyright laws, the author or authors\r\nof this software dedicate any and all copyright interest in the\r\nsoftware to the public domain. We make this dedication for the benefit\r\nof the public at large and to the detriment of our heirs and\r\nsuccessors. We intend this dedication to be an overt act of\r\nrelinquishment in perpetuity of all present and future rights to this\r\nsoftware under copyright law.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\r\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\r\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\nOTHER DEALINGS IN THE SOFTWARE.\r\n\r\nFor more information, please refer to <http://unlicense.org>\r\n *\r\n */\r\n\r\n// structure to represent ranges within the array\r\nimport {Writes} from \"../ArrayAccess/Writes\";\r\n\r\nconst {InsertionSort} = require(\"./InsertionSort\");\r\nconst {Sort} = require(\"./Sort\");\r\n\r\nclass Range {\r\n    start;\r\n    end;\r\n\r\n    constructor(start1 = 0, end1 = 0) {\r\n        this.start = start1;\r\n        this.end = end1;\r\n    }\r\n\r\n    set(start1, end1) {\r\n        this.start = start1;\r\n        this.end = end1;\r\n    }\r\n\r\n    length() {\r\n        return this.end - this.start;\r\n    }\r\n}\r\n\r\nclass Pull {\r\n    from\r\n    to\r\n    count;\r\n    range;\r\n\r\n    constructor() {\r\n        this.range = new Range(0, 0);\r\n    }\r\n\r\n    reset() {\r\n        this.range.set(0, 0);\r\n        this.from = 0;\r\n        this.to = 0;\r\n        this.count = 0;\r\n    }\r\n}\r\n\r\n// calculate how to scale the index value to the range within the array\r\n// the bottom-up merge sort only operates on values that are powers of two,\r\n// so scale down to that power of two, then use a fraction to scale back again\r\nclass Iterator {\r\n    size;\r\n    power_of_two;\r\n    numerator;\r\n    decimal;\r\n    denominator;\r\n    decimal_step;\r\n    numerator_step;\r\n\r\n    // 63 -> 32, 64 -> 64, etc.\r\n    // this comes from Hacker's Delight\r\n    FloorPowerOfTwo(value) {\r\n        let x = value;\r\n        x = x | (x >> 1);\r\n        x = x | (x >> 2);\r\n        x = x | (x >> 4);\r\n        x = x | (x >> 8);\r\n        x = x | (x >> 16);\r\n        return Math.trunc(x - (x >> 1));\r\n    }\r\n\r\n    constructor(size2, min_level) {\r\n        this.size = size2;\r\n        this.power_of_two = this.FloorPowerOfTwo(this.size);\r\n        // this.denominator = this.power_of_two / min_level;\r\n        this.denominator = Math.trunc(this.power_of_two / min_level);\r\n        this.numerator_step = this.size % this.denominator;\r\n        // this.decimal_step = this.size / this.denominator;\r\n        this.decimal_step = Math.trunc(this.size / this.denominator);\r\n        this.begin();\r\n    }\r\n\r\n    begin() {\r\n        this.numerator = this.decimal = 0;\r\n    }\r\n\r\n    nextRange() {\r\n        let start = this.decimal;\r\n\r\n        this.decimal += this.decimal_step;\r\n        this.numerator += this.numerator_step;\r\n        if (this.numerator >= this.denominator) {\r\n            this.numerator -= this.denominator;\r\n            this.decimal++;\r\n        }\r\n\r\n        return new Range(start, this.decimal);\r\n    }\r\n\r\n    finished() {\r\n        return (this.decimal >= this.size);\r\n    }\r\n\r\n    nextLevel() {\r\n        this.decimal_step += this.decimal_step;\r\n        this.numerator_step += this.numerator_step;\r\n        if (this.numerator_step >= this.denominator) {\r\n            this.numerator_step -= this.denominator;\r\n            this.decimal_step++;\r\n        }\r\n\r\n        return (this.decimal_step < this.size);\r\n    }\r\n\r\n    length() {\r\n        return this.decimal_step;\r\n    }\r\n}\r\n\r\nexport class WikiSort extends Sort {\r\n    // use a small cache to speed up some of the operations\r\n    // since the cache size is fixed, it's still O(1) memory!\r\n    // just keep in mind that making it too small ruins the point (nothing will fit into it),\r\n    // and making it too large also ruins the point (so much for \"low memory\"!)\r\n\r\n    cache_size = 0;\r\n    cache = null;\r\n    // note that you can easily modify the above to allocate a dynamically sized cache\r\n    // good choices for the cache size are:\r\n\r\n    // (size + 1)/2  turns into a full-speed standard merge sort since everything fits into the cache\r\n    // sqrt((size + 1)/2) + 1  this will be the size of the A blocks at the largest level of merges,\r\n    // so a buffer of this size would allow it to skip using internal or in-place merges for anything\r\n\r\n    // Original static buffer = 512  chosen from careful testing as a good balance between fixed-size memory use and run time\r\n    // ArrayVisualizer static buffer = 32, as the numbers of items we use for visual purposes is relatively small\r\n\r\n    // 0  if the system simply cannot allocate any extra memory whatsoever, no memory works just fine\r\n\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer)\r\n        this.sortName = \"WikiSort\"\r\n        this.isNeedBuffer = true\r\n    }\r\n\r\n    // if(cache_size != 0) this.cache = Writes.createExternalArray(cache_size);\r\n    // else this.cache = null;\r\n\r\n\r\n// public static void sort(WikiSorting WikiSort, int[] array, int currentLen) {\r\n//     WikiSort.Sort(array, currentLen);\r\n//     if (WikiSort.cache != null) WikiSort.Writes.deleteExternalArray(WikiSort.cache);\r\n// }\r\n\r\n// toolbox functions used by the sorter\r\n\r\n// find the index of the first value within the range that is equal to array[index]\r\n    BinaryFirst(value, range) {\r\n        let start = range.start, end = range.end - 1;\r\n        while (start < end) {\r\n            let mid = Math.trunc(start + (end - start) / 2);\r\n            // if (Reads.compareValues(array[mid], value) < 0)\r\n            if (this.Reads.compareValues(this.Reads.get(mid), value) < 0)\r\n                start = mid + 1;\r\n            else\r\n                end = mid;\r\n        }\r\n        // if (start === range.end - 1 && Reads.compareValues(array[start], value) < 0) start++;\r\n        if (start === range.end - 1 && (this.Reads.compareValues(this.Reads.get(start), value) < 0)) start++;\r\n        return start;\r\n    }\r\n\r\n// find the index of the last value within the range that is equal to array[index], plus 1\r\n    BinaryLast(value, range) {\r\n        let start = range.start, end = range.end - 1;\r\n        while (start < end) {\r\n            let mid = Math.trunc(start + (end - start) / 2);\r\n            if (this.Reads.compareValues(value, this.Reads.get(mid)) >= 0)\r\n                start = mid + 1;\r\n            else\r\n                end = mid;\r\n        }\r\n        if (start === range.end - 1 && this.Reads.compareValues(value, this.Reads.get(start)) >= 0) start++;\r\n        return start;\r\n    }\r\n\r\n// combine a linear search with a binary search to reduce the number of comparisons in situations\r\n// where have some idea as to how many unique values there are and where the next value might be\r\n    FindFirstForward(value, range, unique) {\r\n        if (range.length() === 0) return range.start;\r\n        let index = Math.trunc(Math.max(range.length() / unique, 1));\r\n        // let skip = index\r\n        let skip = index\r\n\r\n        for (index = range.start + skip; this.Reads.compareValues(this.Reads.get(index - 1), value) < 0; index += skip) {\r\n            if (index >= range.end - skip)\r\n                return this.BinaryFirst(value, new Range(index, range.end));\r\n        }\r\n        return this.BinaryFirst(value, new Range(index - skip, index));\r\n    }\r\n\r\n    FindLastForward(value, range, unique) {\r\n        if (range.length() === 0) return range.start;\r\n        let index = Math.trunc(Math.max(range.length() / unique, 1));\r\n        // let skip;\r\n        let skip = index\r\n\r\n        for (index = range.start + skip; this.Reads.compareValues(value, this.Reads.get(index - 1)) >= 0; index += skip)\r\n            if (index >= range.end - skip)\r\n                return this.BinaryLast(value, new Range(index, range.end));\r\n\r\n        return this.BinaryLast(value, new Range(index - skip, index));\r\n    }\r\n\r\n    FindFirstBackward(value, range, unique) {\r\n        if (range.length() === 0) return range.start;\r\n        let index = Math.trunc(Math.max(range.length() / unique, 1));\r\n        let skip = index\r\n\r\n        for (index = range.end - skip; index > range.start && this.Reads.compareValues(this.Reads.get(index - 1), value) >= 0; index -= skip)\r\n            if (index < range.start + skip)\r\n                return this.BinaryFirst(value, new Range(range.start, index));\r\n\r\n        return this.BinaryFirst(value, new Range(index, index + skip));\r\n    }\r\n\r\n    FindLastBackward(value, range, unique) {\r\n        if (range.length() === 0) return range.start;\r\n        let index = Math.trunc(Math.max(range.length() / unique, 1));\r\n        let skip = index\r\n\r\n        for (index = range.end - skip; index > range.start && this.Reads.compareValues(value, this.Reads.get(index - 1)) < 0; index -= skip)\r\n            if (index < range.start + skip)\r\n                return this.BinaryLast(value, new Range(range.start, index));\r\n\r\n        return this.BinaryLast(value, new Range(index, index + skip));\r\n    }\r\n\r\n// n^2 sorting algorithm used to sort tiny chunks of the full array\r\n    InsertionSort(range) {\r\n        // InsertSort.customInsertSort(array, range.start, range.end, 0.5, false);\r\n        let insertionSort = new InsertionSort(this.arrayVisualizer)\r\n        insertionSort.runSort(range.start, range.end)\r\n    }\r\n\r\n// reverse a range of values within the array\r\n    Reverse(range) {\r\n        // Writes.reversal(array, range.start, range.end - 1, 1, true, false);\r\n        let start = range.start\r\n        let length = range.end - 1\r\n        // for (let i = start; i < start + ((length - start + 1) / 2); i++) {\r\n        //     this.Writes.swap(i, start + length - i);\r\n        // }\r\n        this.Writes.reversal(start, length, -1)\r\n    }\r\n\r\n// swap a series of values in the array\r\n    BlockSwap(start1, start2, block_size) {\r\n        for (let index = 0; index < block_size; index++) {\r\n            this.Writes.swap(start1 + index, start2 + index);\r\n        }\r\n    }\r\n\r\n// rotate the values in an array ([0 1 2 3] becomes [1 2 3 0] if we rotate by 1)\r\n// this assumes that 0 <= amount <= range.length()\r\n    Rotate(amount, range, use_cache) {\r\n        if (range.length() === 0) return;\r\n\r\n        let split;\r\n        if (amount >= 0)\r\n            split = range.start + amount;\r\n        else\r\n            split = range.end + amount;\r\n\r\n        let range1 = new Range(range.start, split);\r\n        let range2 = new Range(split, range.end);\r\n\r\n        if (use_cache) {\r\n            // if the smaller of the two ranges fits into the cache, it's *slightly* faster copying it there and shifting the elements over\r\n            if (range1.length() <= range2.length()) {\r\n                if (range1.length() <= this.cache_size) {\r\n                    if (this.cache != null) {\r\n                        this.Writes.arrayCopy(-1, range1.start, this.cache, 0, range1.length());\r\n                        this.Writes.arrayCopy(-1, range2.start, -1, range1.start, range2.length());\r\n                        this.Writes.arrayCopy(this.cache, 0, -1, range1.start + range2.length(), range1.length());\r\n                    }\r\n                    return;\r\n                }\r\n            } else {\r\n                if (range2.length() <= this.cache_size) {\r\n                    if (this.cache != null) {\r\n                        this.Writes.reverseArrayCopy(-1, range2.start, this.cache, 0, range2.length());\r\n                        this.Writes.reverseArrayCopy(-1, range1.start, -1, range2.end - range1.length(), range1.length());\r\n                        this.Writes.reverseArrayCopy(this.cache, 0, -1, range1.start, range2.length());\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        /*\r\n        int lenA = range1.length();\r\n        int lenB = range2.length();\r\n        int pos = range.start;\r\n\r\n        while(lenA != 0 && lenB != 0) {\r\n            if(lenA <= lenB) {\r\n                this.BlockSwap(array, pos, pos + lenA, lenA);\r\n                pos += lenA;\r\n                lenB -= lenA;\r\n            }\r\n            else {\r\n                this.BlockSwap(array, pos + (lenA - lenB), pos + lenA, lenB);\r\n                lenA -= lenB;\r\n            }\r\n        }\r\n        */\r\n\r\n        this.Reverse(range1);\r\n        this.Reverse(range2);\r\n        this.Reverse(range);\r\n    }\r\n\r\n// merge two ranges from one array and save the results into a different array\r\n    MergeInto(from, A, B, into, at_index, tempwrite) {\r\n        let A_index = A.start;\r\n        let B_index = B.start;\r\n        let insert_index = at_index;\r\n        let A_last = A.end;\r\n        let B_last = B.end;\r\n\r\n        if (from === -1) {\r\n            while (true) {\r\n                if (this.Reads.compareInArr(B_index, A_index) >= 0) {\r\n                    this.Writes.write(insert_index, this.Reads.get(A_index), into);\r\n\r\n\r\n                    A_index++;\r\n                    insert_index++;\r\n                    if (A_index === A_last) {\r\n                        // copy the remainder of B into the final array\r\n                        this.Writes.arrayCopy(from, B_index, into, insert_index, B_last - B_index);\r\n                        break;\r\n                    }\r\n                } else {\r\n                    this.Writes.write(insert_index, this.Reads.get(B_index), into);\r\n\r\n                    B_index++;\r\n                    insert_index++;\r\n                    if (B_index === B_last) {\r\n                        // copy the remainder of A into the final array\r\n                        this.Writes.arrayCopy(from, A_index, into, insert_index, A_last - A_index);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            while (true) {\r\n                // if (this.Reads.compareInArr(B_index, A_index) >= 0) {\r\n                console.log(\"FROM: \"+from)\r\n                if (this.Reads.compareValues(this.Reads.readValue(B_index, from), this.Reads.readValue(A_index, from)) >= 0) {\r\n\r\n                    this.Writes.write(insert_index, this.Reads.get(A_index, from));\r\n\r\n\r\n                    A_index++;\r\n                    insert_index++;\r\n                    if (A_index === A_last) {\r\n                        // copy the remainder of B into the final array\r\n                        this.Writes.arrayCopy(from, B_index, into, insert_index, B_last - B_index);\r\n                        break;\r\n                    }\r\n                } else {\r\n                    this.Writes.write(insert_index, this.Reads.get(B_index, from));\r\n\r\n                    B_index++;\r\n                    insert_index++;\r\n                    if (B_index === B_last) {\r\n                        // copy the remainder of A into the final array\r\n                        this.Writes.arrayCopy(from, A_index, into, insert_index, A_last - A_index);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n// merge operation using an external buffer,\r\n    MergeExternal(A, B) {\r\n        // A fits into the cache, so use that instead of the internal buffer\r\n        let A_index = 0;\r\n        let B_index = B.start;\r\n        let insert_index = A.start;\r\n        let A_last = A.length();\r\n        let B_last = B.end;\r\n\r\n        if (B.length() > 0 && A.length() > 0) {\r\n            while (true) {\r\n                if (this.Reads.compareValues(this.Reads.get(B_index), this.Reads.get(A_index, this.cache)) >= 0) {\r\n                    this.Writes.write(insert_index, this.Reads.get(A_index, this.cache));\r\n                    A_index++;\r\n                    insert_index++;\r\n                    if (A_index === A_last) break;\r\n                } else {\r\n                    this.Writes.write(insert_index, this.Reads.get(B_index));\r\n                    B_index++;\r\n                    insert_index++;\r\n                    if (B_index === B_last) break;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // copy the remainder of A into the final array\r\n        if (this.cache != null) {\r\n            this.Writes.arrayCopy(this.cache, A_index, -1, insert_index, A_last - A_index, 1, true, false);\r\n        }\r\n    }\r\n\r\n// merge operation using an internal buffer\r\n    MergeInternal(A, B, buffer) {\r\n        // whenever we find a value to add to the final array, swap it with the value that's already in that spot\r\n        // when this algorithm is finished, 'buffer' will contain its original contents, but in a different order\r\n        let A_count = 0, B_count = 0, insert = 0;\r\n\r\n        if (B.length() > 0 && A.length() > 0) {\r\n            while (true) {\r\n                if (this.Reads.compareInArr(B.start + B_count, buffer.start + A_count) >= 0) {\r\n                    this.Writes.swap(A.start + insert, buffer.start + A_count);\r\n                    A_count++;\r\n                    insert++;\r\n                    if (A_count >= A.length()) break;\r\n                } else {\r\n                    this.Writes.swap(A.start + insert, B.start + B_count);\r\n                    B_count++;\r\n                    insert++;\r\n                    if (B_count >= B.length()) break;\r\n                }\r\n            }\r\n        }\r\n        // swap the remainder of A into the final array\r\n        this.BlockSwap(buffer.start + A_count, A.start + insert, A.length() - A_count);\r\n    }\r\n\r\n// merge operation without a buffer\r\n    MergeInPlace(A, B) {\r\n        if (A.length() === 0 || B.length() === 0) return;\r\n\r\n        /*\r\n            this just repeatedly binary searches into B and rotates A into position.\r\n            the paper suggests using the 'rotation-based Hwang and Lin algorithm' here,\r\n            but I decided to stick with this because it had better situational performance\r\n\r\n            (Hwang and Lin is designed for merging subarrays of very different sizes,\r\n            but WikiSort almost always uses subarrays that are roughly the same size)\r\n\r\n            normally this is incredibly suboptimal, but this function is only called\r\n            when none of the A or B blocks in any subarray contained 2A unique values,\r\n            which places a hard limit on the number of times this will ACTUALLY need\r\n            to binary search and rotate.\r\n\r\n            according to my analysis the worst case is A rotations performed on A items\r\n            once the constant factors are removed, which ends up being O(n)\r\n\r\n            again, this is NOT a general-purpose solution  it only works well in this case!\r\n            kind of like how the O(n^2) insertion sort is used in some places\r\n         */\r\n\r\n        A = new Range(A.start, A.end);\r\n        B = new Range(B.start, B.end);\r\n\r\n        while (true) {\r\n            // find the first place in B where the first item in A needs to be inserted\r\n            let mid = this.BinaryFirst(this.Reads.readValue(A.start), B)\r\n\r\n            // rotate A into place\r\n            let amount = mid - A.end;\r\n            this.Rotate(-amount, new Range(A.start, mid), true);\r\n            if (B.end === mid) break;\r\n\r\n            // calculate the new A and B ranges\r\n            B.start = mid;\r\n            A.set(A.start + amount, B.start);\r\n            A.start = this.BinaryLast(this.Reads.readValue(A.start), A);\r\n            if (A.length() === 0) break;\r\n        }\r\n    }\r\n\r\n    NetSwap(order, range, x, y) {\r\n        let compare = this.Reads.compareInArr(range.start + x, range.start + y);\r\n        if (compare > 0 || (this.Reads.compareValues(order[x], order[y]) > 0 && compare === 0)) {\r\n            // console.log(range.start + x)\r\n            // console.log(range.start + y)\r\n            this.Writes.swap(range.start + x, range.start + y);\r\n            let tmp = order[x]\r\n            order[x] = order[y]\r\n            order[y] = tmp\r\n            // this.Writes.swap(order, x, y, 0, false, false);\r\n        }\r\n    }\r\n\r\n// bottom-up merge sort combined with an in-place merge algorithm for O(1) memory use\r\n    Sort(len) {\r\n        let size = len;\r\n\r\n        // if the array is of size 0, 1, 2, or 3, just sort them like so:\r\n        if (size < 4) {\r\n            let insertionSort = new InsertionSort(this.arrayVisualizer)\r\n            insertionSort.runSort(0, len)\r\n            // if (size === 3) {\r\n            //     // hard-coded insertion sort\r\n            //     if (Reads.compareInArr(array[1], array[0]) < 0) {\r\n            //         Writes.swap(array, 0, 1, 1, true, false);\r\n            //     }\r\n            //     if (Reads.compareValues(array[2], array[1]) < 0) {\r\n            //         Writes.swap(array, 1, 2, 1, true, false);\r\n            //         if (Reads.compareValues(array[1], array[0]) < 0) {\r\n            //             Writes.swap(array, 0, 1, 1, true, false);\r\n            //         }\r\n            //     }\r\n            // } else if (size == 2) {\r\n            //     // swap the items if they're out of order\r\n            //     if (Reads.compareValues(array[1], array[0]) < 0) {\r\n            //         Writes.swap(array, 0, 1, 1, true, false);\r\n            //     }\r\n            // }\r\n            return;\r\n        }\r\n\r\n        // sort groups of 4-8 items at a time using an unstable sorting network,\r\n        // but keep track of the original item orders to force it to be stable\r\n        // http://pages.ripco.net/~jgamble/nw.html\r\n        let iterator = new Iterator(size, 4);\r\n        while (!iterator.finished()) {\r\n            let order = [0, 1, 2, 3, 4, 5, 6, 7];\r\n            let range = iterator.nextRange();\r\n\r\n            if (range.length() === 8) {\r\n                this.NetSwap(order, range, 0, 1);\r\n                this.NetSwap(order, range, 2, 3);\r\n                this.NetSwap(order, range, 4, 5);\r\n                this.NetSwap(order, range, 6, 7);\r\n                this.NetSwap(order, range, 0, 2);\r\n                this.NetSwap(order, range, 1, 3);\r\n                this.NetSwap(order, range, 4, 6);\r\n                this.NetSwap(order, range, 5, 7);\r\n                this.NetSwap(order, range, 1, 2);\r\n                this.NetSwap(order, range, 5, 6);\r\n                this.NetSwap(order, range, 0, 4);\r\n                this.NetSwap(order, range, 3, 7);\r\n                this.NetSwap(order, range, 1, 5);\r\n                this.NetSwap(order, range, 2, 6);\r\n                this.NetSwap(order, range, 1, 4);\r\n                this.NetSwap(order, range, 3, 6);\r\n                this.NetSwap(order, range, 2, 4);\r\n                this.NetSwap(order, range, 3, 5);\r\n                this.NetSwap(order, range, 3, 4);\r\n\r\n            } else if (range.length() === 7) {\r\n                this.NetSwap(order, range, 1, 2);\r\n                this.NetSwap(order, range, 3, 4);\r\n                this.NetSwap(order, range, 5, 6);\r\n                this.NetSwap(order, range, 0, 2);\r\n                this.NetSwap(order, range, 3, 5);\r\n                this.NetSwap(order, range, 4, 6);\r\n                this.NetSwap(order, range, 0, 1);\r\n                this.NetSwap(order, range, 4, 5);\r\n                this.NetSwap(order, range, 2, 6);\r\n                this.NetSwap(order, range, 0, 4);\r\n                this.NetSwap(order, range, 1, 5);\r\n                this.NetSwap(order, range, 0, 3);\r\n                this.NetSwap(order, range, 2, 5);\r\n                this.NetSwap(order, range, 1, 3);\r\n                this.NetSwap(order, range, 2, 4);\r\n                this.NetSwap(order, range, 2, 3);\r\n\r\n            } else if (range.length() === 6) {\r\n                this.NetSwap(order, range, 1, 2);\r\n                this.NetSwap(order, range, 4, 5);\r\n                this.NetSwap(order, range, 0, 2);\r\n                this.NetSwap(order, range, 3, 5);\r\n                this.NetSwap(order, range, 0, 1);\r\n                this.NetSwap(order, range, 3, 4);\r\n                this.NetSwap(order, range, 2, 5);\r\n                this.NetSwap(order, range, 0, 3);\r\n                this.NetSwap(order, range, 1, 4);\r\n                this.NetSwap(order, range, 2, 4);\r\n                this.NetSwap(order, range, 1, 3);\r\n                this.NetSwap(order, range, 2, 3);\r\n\r\n            } else if (range.length() === 5) {\r\n                this.NetSwap(order, range, 0, 1);\r\n                this.NetSwap(order, range, 3, 4);\r\n                this.NetSwap(order, range, 2, 4);\r\n                this.NetSwap(order, range, 2, 3);\r\n                this.NetSwap(order, range, 1, 4);\r\n                this.NetSwap(order, range, 0, 3);\r\n                this.NetSwap(order, range, 0, 2);\r\n                this.NetSwap(order, range, 1, 3);\r\n                this.NetSwap(order, range, 1, 2);\r\n\r\n            } else if (range.length() === 4) {\r\n                this.NetSwap(order, range, 0, 1);\r\n                this.NetSwap(order, range, 2, 3);\r\n                this.NetSwap(order, range, 0, 2);\r\n                this.NetSwap(order, range, 1, 3);\r\n                this.NetSwap(order, range, 1, 2);\r\n            }\r\n        }\r\n        if (size < 8) return;\r\n\r\n\r\n        // we need to keep track of a lot of ranges during this sort!\r\n        let buffer1 = new Range(), buffer2 = new Range();\r\n        let blockA = new Range(), blockB = new Range();\r\n        let lastA = new Range(), lastB = new Range();\r\n        let firstA = new Range();\r\n        let A = new Range(), B = new Range();\r\n\r\n        let pull = new Array(2);\r\n        pull[0] = new Pull();\r\n        pull[1] = new Pull();\r\n\r\n        // then merge sort the higher levels, which can be 8-15, 16-31, 32-63, 64-127, etc.\r\n        while (true) {\r\n\r\n            // if every A and B block will fit into the cache, use a special branch specifically for merging with the cache\r\n            // (we use < rather than <= since the block size might be one more than iterator.length())\r\n            if (iterator.length() < this.cache_size) {\r\n\r\n                // if four subarrays fit into the cache, it's faster to merge both pairs of subarrays into the cache,\r\n                // then merge the two merged subarrays from the cache back into the original array\r\n                if ((iterator.length() + 1) * 4 <= this.cache_size && iterator.length() * 4 <= size) {\r\n                    iterator.begin();\r\n                    while (!iterator.finished()) {\r\n                        // merge A1 and B1 into the cache\r\n                        let A1 = iterator.nextRange();\r\n                        let B1 = iterator.nextRange();\r\n                        let A2 = iterator.nextRange();\r\n                        let B2 = iterator.nextRange();\r\n\r\n                        if (this.Reads.compareInArr(B1.end - 1, A1.start) < 0) {\r\n                            // the two ranges are in reverse order, so copy them in reverse order into the cache\r\n                            this.Writes.arrayCopy(-1, A1.start, this.cache, B1.length(), A1.length());\r\n                            this.Writes.arrayCopy(-1, B1.start, this.cache, 0, B1.length());\r\n                        } else if (this.Reads.compareInArr(B1.start, A1.end - 1) < 0) {\r\n                            // these two ranges weren't already in order, so merge them into the cache\r\n                            this.MergeInto(-1, A1, B1, this.cache, 0, true);\r\n                        } else {\r\n                            // if A1, B1, A2, and B2 are all in order, skip doing anything else\r\n                            if (this.Reads.compareInArr(B2.start, A2.end - 1) >= 0 && this.Reads.compareInArr(A2.start, B1.end - 1) >= 0) continue;\r\n\r\n                            // copy A1 and B1 into the cache in the same order\r\n                            this.Writes.arrayCopy(A1.start, this.cache, 0, A1.length(), 1);\r\n                            this.Writes.arrayCopy(B1.start, this.cache, A1.length(), B1.length(), 1);\r\n                        }\r\n                        A1.set(A1.start, B1.end);\r\n\r\n                        // merge A2 and B2 into the cache\r\n                        if (this.Reads.compareInArr(B2.end - 1, A2.start) < 0) {\r\n                            // the two ranges are in reverse order, so copy them in reverse order into the cache\r\n                            this.Writes.arrayCopy(A2.start, this.cache, A1.length() + B2.length(), A2.length(), 1);\r\n                            this.Writes.arrayCopy(B2.start, this.cache, A1.length(), B2.length(), 1);\r\n                        } else if (this.Reads.compareInArr(B2.start, A2.end - 1) < 0) {\r\n                            // these two ranges weren't already in order, so merge them into the cache\r\n                            this.MergeInto(-1, A2, B2, this.cache, A1.length(), true);\r\n                        } else {\r\n                            // copy A2 and B2 into the cache in the same order\r\n                            this.Writes.arrayCopy(A2.start, this.cache, A1.length(), A2.length(), 1);\r\n                            this.Writes.arrayCopy(B2.start, this.cache, A1.length() + A2.length(), B2.length(), 1);\r\n                        }\r\n                        A2.set(A2.start, B2.end);\r\n\r\n                        // merge A1 and A2 from the cache into the array\r\n                        let A3 = new Range(0, A1.length());\r\n                        let B3 = new Range(A1.length(), A1.length() + A2.length());\r\n\r\n                        if (this.Reads.compareValues(this.Reads.readValue(B3.end - 1, this.cache), this.Reads.readValue(A3.start, this.cache)) < 0) {\r\n                            // the two ranges are in reverse order, so copy them in reverse order into the cache\r\n                            this.Writes.arrayCopy(this.cache, A3.start, -1, A1.start + A2.length(), A3.length(), 1, true, false);\r\n                            this.Writes.arrayCopy(this.cache, B3.start, -1, A1.start, B3.length(), 1, true, false);\r\n                        } else if (this.Reads.compareValues(this.Reads.readValue(B3.start, this.cache), this.Reads.readValue(A3.end - 1, this.cache)) < 0) {\r\n                            // these two ranges weren't already in order, so merge them back into the array\r\n                            this.MergeInto(this.cache, A3, B3, -1, A1.start, false);\r\n                        } else {\r\n                            // copy A3 and B3 into the array in the same order\r\n                            this.Writes.arraycopy(this.cache, A3.start, -1, A1.start, A3.length(), 1);\r\n                            this.Writes.arraycopy(this.cache, B3.start, -1, A1.start + A1.length(), B3.length(), 1);\r\n                        }\r\n                    }\r\n\r\n                    // we merged two levels at the same time, so we're done with this level already\r\n                    // (iterator.nextLevel() is called again at the bottom of this outer merge loop)\r\n                    iterator.nextLevel();\r\n\r\n                } else {\r\n                    iterator.begin();\r\n                    while (!iterator.finished()) {\r\n                        A = iterator.nextRange();\r\n                        B = iterator.nextRange();\r\n\r\n                        if (this.Reads.compareInArr(B.end - 1, A.start) < 0) {\r\n                            // the two ranges are in reverse order, so a simple rotation should fix it\r\n                            this.Rotate(A.length(), new Range(A.start, B.end), true);\r\n                        } else if (this.Reads.compareInArr(B.start, A.end - 1) < 0) {\r\n                            // these two ranges weren't already in order, so we'll need to merge them!\r\n                            this.Writes.arrayCopy(-1, A.start, this.cache, 0, A.length(), 1);\r\n                            this.MergeExternal(A, B);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // this is where the in-place merge logic starts!\r\n                // 1. pull out two internal buffers each containing A unique values\r\n                //     1a. adjust block_size and buffer_size if we couldn't find enough unique values\r\n                // 2. loop over the A and B subarrays within this level of the merge sort\r\n                //     3. break A and B into blocks of size 'block_size'\r\n                //     4. \"tag\" each of the A blocks with values from the first internal buffer\r\n                //     5. roll the A blocks through the B blocks and drop/rotate them where they belong\r\n                //     6. merge each A block with any B values that follow, using the cache or the second internal buffer\r\n                // 7. sort the second internal buffer if it exists\r\n                // 8. redistribute the two internal buffers back into the array\r\n\r\n                let block_size = Math.trunc(Math.sqrt(iterator.length()));\r\n                let buffer_size = Math.trunc(iterator.length() / block_size) + 1;\r\n\r\n                // as an optimization, we really only need to pull out the internal buffers once for each level of merges\r\n                // after that we can reuse the same buffers over and over, then redistribute it when we're finished with this level\r\n                let index, last, count, pull_index = 0;\r\n                buffer1.set(0, 0);\r\n                buffer2.set(0, 0);\r\n\r\n                pull[0].reset();\r\n                pull[1].reset();\r\n\r\n                // find two internal buffers of size 'buffer_size' each\r\n                let find = buffer_size + buffer_size;\r\n                let find_separately = false;\r\n\r\n                if (block_size <= this.cache_size) {\r\n                    // if every A block fits into the cache then we won't need the second internal buffer,\r\n                    // so we really only need to find 'buffer_size' unique values\r\n                    find = buffer_size;\r\n                } else if (find > iterator.length()) {\r\n                    // we can't fit both buffers into the same A or B subarray, so find two buffers separately\r\n                    find = buffer_size;\r\n                    find_separately = true;\r\n                }\r\n\r\n                // we need to find either a single contiguous space containing 2A unique values (which will be split up into two buffers of size A each),\r\n                // or we need to find one buffer of < 2A unique values, and a second buffer of A unique values,\r\n                // OR if we couldn't find that many unique values, we need the largest possible buffer we can get\r\n\r\n                // in the case where it couldn't find a single buffer of at least A unique values,\r\n                // all of the Merge steps must be replaced by a different merge algorithm (MergeInPlace)\r\n\r\n                iterator.begin();\r\n                while (!iterator.finished()) {\r\n                    A = iterator.nextRange();\r\n                    B = iterator.nextRange();\r\n\r\n                    // check A for the number of unique values we need to fill an internal buffer\r\n                    // these values will be pulled out to the start of A\r\n                    for (last = A.start, count = 1; count < find; last = index, count++) {\r\n                        index = this.FindLastForward(this.Reads.readValue(last), new Range(last + 1, A.end), find - count);\r\n                        if (index === A.end) break;\r\n                    }\r\n                    index = last;\r\n\r\n                    if (count >= buffer_size) {\r\n                        // keep track of the range within the array where we'll need to \"pull out\" these values to create the internal buffer\r\n                        pull[pull_index].range.set(A.start, B.end);\r\n                        pull[pull_index].count = count;\r\n                        pull[pull_index].from = index;\r\n                        pull[pull_index].to = A.start;\r\n                        pull_index = 1;\r\n\r\n                        if (count === buffer_size + buffer_size) {\r\n                            // we were able to find a single contiguous section containing 2A unique values,\r\n                            // so this section can be used to contain both of the internal buffers we'll need\r\n                            buffer1.set(A.start, A.start + buffer_size);\r\n                            buffer2.set(A.start + buffer_size, A.start + count);\r\n                            break;\r\n                        } else if (find === buffer_size + buffer_size) {\r\n                            // we found a buffer that contains at least A unique values, but did not contain the full 2A unique values,\r\n                            // so we still need to find a second separate buffer of at least A unique values\r\n                            buffer1.set(A.start, A.start + count);\r\n                            find = buffer_size;\r\n                        } else if (block_size <= this.cache_size) {\r\n                            // we found the first and only internal buffer that we need, so we're done!\r\n                            buffer1.set(A.start, A.start + count);\r\n                            break;\r\n                        } else if (find_separately) {\r\n                            // found one buffer, but now find the other one\r\n                            buffer1 = new Range(A.start, A.start + count);\r\n                            find_separately = false;\r\n                        } else {\r\n                            // we found a second buffer in an 'A' subarray containing A unique values, so we're done!\r\n                            buffer2.set(A.start, A.start + count);\r\n                            break;\r\n                        }\r\n                    } else if (pull_index === 0 && count > buffer1.length()) {\r\n                        // keep track of the largest buffer we were able to find\r\n                        buffer1.set(A.start, A.start + count);\r\n\r\n                        pull[pull_index].range.set(A.start, B.end);\r\n                        pull[pull_index].count = count;\r\n                        pull[pull_index].from = index;\r\n                        pull[pull_index].to = A.start;\r\n                    }\r\n\r\n                    // check B for the number of unique values we need to fill an internal buffer\r\n                    // these values will be pulled out to the end of B\r\n                    for (last = B.end - 1, count = 1; count < find; last = index - 1, count++) {\r\n                        index = this.FindFirstBackward(this.Reads.readValue(last), new Range(B.start, last), find - count);\r\n                        if (index === B.start) break;\r\n                    }\r\n                    index = last;\r\n\r\n                    if (count >= buffer_size) {\r\n                        // keep track of the range within the array where we'll need to \"pull out\" these values to create the internal buffer\r\n                        pull[pull_index].range.set(A.start, B.end);\r\n                        pull[pull_index].count = count;\r\n                        pull[pull_index].from = index;\r\n                        pull[pull_index].to = B.end;\r\n                        pull_index = 1;\r\n\r\n                        if (count === buffer_size + buffer_size) {\r\n                            // we were able to find a single contiguous section containing 2A unique values,\r\n                            // so this section can be used to contain both of the internal buffers we'll need\r\n                            buffer1.set(B.end - count, B.end - buffer_size);\r\n                            buffer2.set(B.end - buffer_size, B.end);\r\n                            break;\r\n                        } else if (find === buffer_size + buffer_size) {\r\n                            // we found a buffer that contains at least A unique values, but did not contain the full 2A unique values,\r\n                            // so we still need to find a second separate buffer of at least A unique values\r\n                            buffer1.set(B.end - count, B.end);\r\n                            find = buffer_size;\r\n                        } else if (block_size <= this.cache_size) {\r\n                            // we found the first and only internal buffer that we need, so we're done!\r\n                            buffer1.set(B.end - count, B.end);\r\n                            break;\r\n                        } else if (find_separately) {\r\n                            // found one buffer, but now find the other one\r\n                            buffer1 = new Range(B.end - count, B.end);\r\n                            find_separately = false;\r\n                        } else {\r\n                            // buffer2 will be pulled out from a 'B' subarray, so if the first buffer was pulled out from the corresponding 'A' subarray,\r\n                            // we need to adjust the end point for that A subarray so it knows to stop redistributing its values before reaching buffer2\r\n                            if (pull[0].range.start === A.start) pull[0].range.end -= pull[1].count;\r\n\r\n                            // we found a second buffer in an 'B' subarray containing A unique values, so we're done!\r\n                            buffer2.set(B.end - count, B.end);\r\n                            break;\r\n                        }\r\n                    } else if (pull_index === 0 && count > buffer1.length()) {\r\n                        // keep track of the largest buffer we were able to find\r\n                        buffer1.set(B.end - count, B.end);\r\n\r\n                        pull[pull_index].range.set(A.start, B.end);\r\n                        pull[pull_index].count = count;\r\n                        pull[pull_index].from = index;\r\n                        pull[pull_index].to = B.end;\r\n                    }\r\n                }\r\n\r\n                // pull out the two ranges so we can use them as internal buffers\r\n                for (pull_index = 0; pull_index < 2; pull_index++) {\r\n                    let length = pull[pull_index].count;\r\n\r\n                    if (pull[pull_index].to < pull[pull_index].from) {\r\n                        // we're pulling the values out to the left, which means the start of an A subarray\r\n                        index = pull[pull_index].from;\r\n                        for (count = 1; count < length; count++) {\r\n                            index = this.FindFirstBackward(this.Reads.readValue(index - 1), new Range(pull[pull_index].to, pull[pull_index].from - (count - 1)), length - count);\r\n                            let range = new Range(index + 1, pull[pull_index].from + 1);\r\n                            this.Rotate(range.length() - count, range, true);\r\n                            pull[pull_index].from = index + count;\r\n                        }\r\n                    } else if (pull[pull_index].to > pull[pull_index].from) {\r\n                        // we're pulling values out to the right, which means the end of a B subarray\r\n                        index = pull[pull_index].from + 1;\r\n                        for (count = 1; count < length; count++) {\r\n                            index = this.FindLastForward(this.Reads.readValue(index), new Range(index, pull[pull_index].to), length - count);\r\n                            let range = new Range(pull[pull_index].from, index - 1);\r\n                            this.Rotate(count, range, true);\r\n                            pull[pull_index].from = index - 1 - count;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // adjust block_size and buffer_size based on the values we were able to pull out\r\n                buffer_size = buffer1.length();\r\n                block_size = Math.trunc(iterator.length() / buffer_size) + 1;\r\n\r\n                // the first buffer NEEDS to be large enough to tag each of the evenly sized A blocks,\r\n                // so this was originally here to test the math for adjusting block_size above\r\n                //if ((iterator.length() + 1)/block_size > buffer_size) throw new RuntimeException();\r\n\r\n                // now that the two internal buffers have been created, it's time to merge each A+B combination at this level of the merge sort!\r\n                iterator.begin();\r\n                while (!iterator.finished()) {\r\n                    A = iterator.nextRange();\r\n                    B = iterator.nextRange();\r\n\r\n                    // remove any parts of A or B that are being used by the internal buffers\r\n                    let start = A.start;\r\n                    if (start === pull[0].range.start) {\r\n                        if (pull[0].from > pull[0].to) {\r\n                            A.start += pull[0].count;\r\n\r\n                            // if the internal buffer takes up the entire A or B subarray, then there's nothing to merge\r\n                            // this only happens for very small subarrays, like 4 = 2, 2 * (2 internal buffers) = 4,\r\n                            // which also only happens when cache_size is small or 0 since it'd otherwise use MergeExternal\r\n                            if (A.length() === 0) continue;\r\n                        } else if (pull[0].from < pull[0].to) {\r\n                            B.end -= pull[0].count;\r\n                            if (B.length() === 0) continue;\r\n                        }\r\n                    }\r\n                    if (start === pull[1].range.start) {\r\n                        if (pull[1].from > pull[1].to) {\r\n                            A.start += pull[1].count;\r\n                            if (A.length() === 0) continue;\r\n                        } else if (pull[1].from < pull[1].to) {\r\n                            B.end -= pull[1].count;\r\n                            if (B.length() === 0) continue;\r\n                        }\r\n                    }\r\n\r\n                    if (this.Reads.compareInArr(B.end - 1, A.start) < 0) {\r\n                        // the two ranges are in reverse order, so a simple rotation should fix it\r\n                        this.Rotate(A.length(), new Range(A.start, B.end), true);\r\n                    } else if (this.Reads.compareInArr(A.end, A.end - 1) < 0) {\r\n                        // these two ranges weren't already in order, so we'll need to merge them!\r\n\r\n                        // break the remainder of A into blocks. firstA is the uneven-sized first A block\r\n                        blockA.set(A.start, A.end);\r\n                        firstA.set(A.start, A.start + blockA.length() % block_size);\r\n\r\n                        // swap the first value of each A block with the value in buffer1\r\n                        let indexA = buffer1.start;\r\n                        for (index = firstA.end; index < blockA.end; index += block_size) {\r\n                            this.Writes.swap(indexA, index);\r\n                            indexA++;\r\n                        }\r\n\r\n                        // start rolling the A blocks through the B blocks!\r\n                        // whenever we leave an A block behind, we'll need to merge the previous A block with any B blocks that follow it, so track that information as well\r\n                        lastA.set(firstA.start, firstA.end);\r\n                        lastB.set(0, 0);\r\n                        blockB.set(B.start, B.start + Math.min(block_size, B.length()));\r\n                        blockA.start += firstA.length();\r\n                        indexA = buffer1.start;\r\n\r\n                        // if the first unevenly sized A block fits into the cache, copy it there for when we go to Merge it\r\n                        // otherwise, if the second buffer is available, block swap the contents into that\r\n                        if (lastA.length() <= this.cache_size && this.cache != null) {\r\n                            this.Writes.arrayCopy(-1, lastA.start, this.cache, 0, lastA.length(), 1);\r\n                        } else if (buffer2.length() > 0)\r\n                            this.BlockSwap(lastA.start, buffer2.start, lastA.length());\r\n\r\n                        if (blockA.length() > 0) {\r\n                            while (true) {\r\n                                // if there's a previous B block and the first value of the minimum A block is <= the last value of the previous B block,\r\n                                // then drop that minimum A block behind. or if there are no B blocks left then keep dropping the remaining A blocks.\r\n                                if ((lastB.length() > 0 && this.Reads.compareInArr(lastB.end - 1, indexA) >= 0) || blockB.length() === 0) {\r\n                                    // figure out where to split the previous B block, and rotate it at the split\r\n                                    let B_split = this.BinaryFirst(this.Reads.readValue(indexA), lastB);\r\n                                    let B_remaining = lastB.end - B_split;\r\n\r\n                                    // swap the minimum A block to the beginning of the rolling A blocks\r\n                                    let minA = blockA.start;\r\n                                    for (let findA = minA + block_size; findA < blockA.end; findA += block_size)\r\n                                        if (this.Reads.compareInArr(findA, minA) < 0)\r\n                                            minA = findA;\r\n                                    this.BlockSwap(blockA.start, minA, block_size);\r\n\r\n                                    // swap the first item of the previous A block back with its original value, which is stored in buffer1\r\n                                    this.Writes.swap(blockA.start, indexA);\r\n                                    indexA++;\r\n\r\n                                    // locally merge the previous A block with the B values that follow it\r\n                                    // if lastA fits into the external cache we'll use that (with MergeExternal),\r\n                                    // or if the second internal buffer exists we'll use that (with MergeInternal),\r\n                                    // or failing that we'll use a strictly in-place merge algorithm (MergeInPlace)\r\n                                    if (lastA.length() <= this.cache_size)\r\n                                        this.MergeExternal(lastA, new Range(lastA.end, B_split));\r\n                                    else if (buffer2.length() > 0)\r\n                                        this.MergeInternal(lastA, new Range(lastA.end, B_split), buffer2);\r\n                                    else\r\n                                        this.MergeInPlace(lastA, new Range(lastA.end, B_split));\r\n\r\n                                    if (buffer2.length() > 0 || block_size <= this.cache_size) {\r\n                                        // copy the previous A block into the cache or buffer2, since that's where we need it to be when we go to merge it anyway\r\n                                        if (block_size <= this.cache_size) {\r\n                                            this.Writes.arrayCopy(-1, blockA.start, this.cache, 0, block_size, 1, true, true);\r\n                                        } else\r\n                                            this.BlockSwap(blockA.start, buffer2.start, block_size);\r\n\r\n                                        // this is equivalent to rotating, but faster\r\n                                        // the area normally taken up by the A block is either the contents of buffer2, or data we don't need anymore since we memcopied it\r\n                                        // either way, we don't need to retain the order of those items, so instead of rotating we can just block swap B to where it belongs\r\n                                        this.BlockSwap(B_split, blockA.start + block_size - B_remaining, B_remaining);\r\n                                    } else {\r\n                                        // we are unable to use the 'buffer2' trick to speed up the rotation operation since buffer2 doesn't exist, so perform a normal rotation\r\n                                        this.Rotate(blockA.start - B_split, new Range(B_split, blockA.start + block_size), true);\r\n                                    }\r\n\r\n                                    // update the range for the remaining A blocks, and the range remaining from the B block after it was split\r\n                                    lastA.set(blockA.start - B_remaining, blockA.start - B_remaining + block_size);\r\n                                    lastB.set(lastA.end, lastA.end + B_remaining);\r\n\r\n                                    // if there are no more A blocks remaining, this step is finished!\r\n                                    blockA.start += block_size;\r\n                                    if (blockA.length() === 0)\r\n                                        break;\r\n\r\n                                } else if (blockB.length() < block_size) {\r\n                                    // move the last B block, which is unevenly sized, to before the remaining A blocks, by using a rotation\r\n                                    // the cache is disabled here since it might contain the contents of the previous A block\r\n                                    this.Rotate(-blockB.length(), new Range(blockA.start, blockB.end), false);\r\n\r\n                                    lastB.set(blockA.start, blockA.start + blockB.length());\r\n                                    blockA.start += blockB.length();\r\n                                    blockA.end += blockB.length();\r\n                                    blockB.end = blockB.start;\r\n                                } else {\r\n                                    // roll the leftmost A block to the end by swapping it with the next B block\r\n                                    this.BlockSwap(blockA.start, blockB.start, block_size);\r\n                                    lastB.set(blockA.start, blockA.start + block_size);\r\n\r\n                                    blockA.start += block_size;\r\n                                    blockA.end += block_size;\r\n                                    blockB.start += block_size;\r\n                                    blockB.end += block_size;\r\n\r\n                                    if (blockB.end > B.end)\r\n                                        blockB.end = B.end;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // merge the last A block with the remaining B values\r\n                        if (lastA.length() <= this.cache_size)\r\n                            this.MergeExternal(lastA, new Range(lastA.end, B.end));\r\n                        else if (buffer2.length() > 0)\r\n                            this.MergeInternal(lastA, new Range(lastA.end, B.end), buffer2);\r\n                        else\r\n                            this.MergeInPlace(lastA, new Range(lastA.end, B.end));\r\n                    }\r\n                }\r\n\r\n\r\n                // when we're finished with this merge step we should have the one or two internal buffers left over, where the second buffer is all jumbled up\r\n                // insertion sort the second buffer, then redistribute the buffers back into the array using the opposite process used for creating the buffer\r\n\r\n                // while an unstable sort like quick sort could be applied here, in benchmarks it was consistently slightly slower than a simple insertion sort,\r\n                // even for tens of millions of items. this may be because insertion sort is quite fast when the data is already somewhat sorted, like it is here\r\n\r\n\r\n                this.InsertionSort(buffer2)\r\n\r\n                for (pull_index = 0; pull_index < 2; pull_index++) {\r\n                    let unique = pull[pull_index].count * 2;\r\n                    if (pull[pull_index].from > pull[pull_index].to) {\r\n                        // the values were pulled out to the left, so redistribute them back to the right\r\n                        let buffer = new Range(pull[pull_index].range.start, pull[pull_index].range.start + pull[pull_index].count);\r\n                        while (buffer.length() > 0) {\r\n                            index = this.FindFirstForward(this.Reads.readValue(buffer.start), new Range(buffer.end, pull[pull_index].range.end), unique);\r\n                            let amount = index - buffer.end;\r\n                            this.Rotate(buffer.length(), new Range(buffer.start, index), true);\r\n                            buffer.start += (amount + 1);\r\n                            buffer.end += amount;\r\n                            unique -= 2;\r\n                        }\r\n                    } else if (pull[pull_index].from < pull[pull_index].to) {\r\n                        // the values were pulled out to the right, so redistribute them back to the left\r\n                        let buffer = new Range(pull[pull_index].range.end - pull[pull_index].count, pull[pull_index].range.end);\r\n                        while (buffer.length() > 0) {\r\n                            index = this.FindLastBackward(this.Reads.readValue(buffer.end - 1), new Range(pull[pull_index].range.start, buffer.start), unique);\r\n                            let amount = buffer.start - index;\r\n                            this.Rotate(amount, new Range(index, buffer.end), true);\r\n                            buffer.start -= amount;\r\n                            buffer.end -= (amount + 1);\r\n                            unique -= 2;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // double the size of each A and B subarray that will be merged in the next level\r\n            if (!iterator.nextLevel()) break;\r\n        }\r\n    }\r\n    runSort(low, high, bucketsNum, bufferSize){\r\n        if(bufferSize!==0){\r\n            this.cache_size = bufferSize\r\n            this.cache = this.Writes.createAuxArray(bufferSize)\r\n        }\r\n        this.Sort(high+1)\r\n        this.Writes.removeAuxArray(this.cache)\r\n    }\r\n}\r\n","import React from \"react\";\r\nimport {objLength} from \"../utils/utils\";\r\nimport styles from \"./ArrayWindow.module.scss\";\r\n\r\nexport class ArrayWindow extends React.PureComponent {\r\n    array\r\n    mainArray\r\n    height\r\n    visualProps\r\n    borderEnabled\r\n    visualStyle\r\n    arrayLen\r\n    sizeStyle\r\n    updateInterval\r\n    updateAnimFrame\r\n    updateCounter\r\n    index\r\n    canvasRef\r\n    containerRef\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.array = props.array\r\n        this.mainArray = props.mainArray\r\n        this.height = props.height\r\n        this.visualProps = props.visualProps\r\n        this.borderEnabled = this.visualProps.barsStroke\r\n        this.visualStyle = this.visualProps.style\r\n        this.arrayLen = this.array.length\r\n        this.sizeStyle = {width: \"100%\", height: this.height + \"%\"};\r\n        this.updateCounter = 1\r\n        this.canvasRef = React.createRef()\r\n        this.containerRef = React.createRef()\r\n        this.state = {\r\n            renderedArray: this.renderArray()\r\n        }\r\n    }\r\n    componentDidMount() {\r\n        this.updateInterval = setInterval(()=>{\r\n            this.cancelAndUpdate()\r\n        }, 17)\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        cancelAnimationFrame(this.updateAnimFrame)\r\n\r\n        let canvas = this.canvasRef.current\r\n        let container = this.containerRef.current\r\n\r\n        let containerWidth = container.clientWidth\r\n        let containerHeight = container.clientHeight\r\n        canvas.width = containerWidth\r\n        canvas.height = containerHeight\r\n        let ctx = canvas.getContext('2d')\r\n        ctx.clearRect(0, 0, containerWidth, containerHeight);\r\n\r\n    }\r\n\r\n    cancelAndUpdate(){\r\n        cancelAnimationFrame(this.updateAnimFrame)\r\n        this.updateAnimFrame = requestAnimationFrame(this.renderArray.bind(this))\r\n    }\r\n\r\n    componentWillReceiveProps(nextProps, nextContext){\r\n        this.array = nextProps.array\r\n        this.mainArray = nextProps.mainArray\r\n        this.height = nextProps.height\r\n        this.visualProps = nextProps.visualProps\r\n        this.borderEnabled = this.visualProps.barsStroke\r\n        this.visualStyle = this.visualProps.style\r\n        this.sizeStyle = {width: \"100%\", height: this.height + \"%\"};\r\n        let len = this.array.length\r\n        if(len !== this.arrayLen){\r\n            this.arrayLen = len\r\n            this.cancelAndUpdate()\r\n        }\r\n        //workaround for firefox\r\n        if(++this.updateCounter%5===0){\r\n            this.cancelAndUpdate()\r\n            this.updateCounter=1\r\n        }\r\n\r\n    }\r\n\r\n    renderArray() {\r\n        const rem = parseInt(getComputedStyle(document.documentElement).fontSize)\r\n\r\n        let canvas = this.canvasRef.current\r\n        let container = this.containerRef.current\r\n\r\n        if(canvas==null){\r\n            return\r\n        }\r\n        let containerWidth = container.clientWidth\r\n        let containerHeight = container.clientHeight\r\n        canvas.width = containerWidth\r\n        canvas.height = containerHeight\r\n        let ctx = canvas.getContext('2d')\r\n        // ctx.clearRect(0, 0, containerWidth, containerHeight);\r\n        ctx.imageSmoothingEnabled= false\r\n        ctx.filter = \"none\"\r\n        let offset = containerWidth/this.mainArray.length\r\n\r\n        if(this.visualStyle === \"bars\") {\r\n            for (let i = 0; i < this.arrayLen; ++i) {\r\n                let height = this.array[i].getValue() / (this.mainArray.length - 1) * containerHeight\r\n\r\n                let x = offset * i\r\n                let y = containerHeight - height\r\n                let w = offset\r\n                let h = height\r\n                ctx.fillStyle = \"rgb(\" + this.array[i].getColorForRender() + \")\"\r\n                ctx.fillRect(x, y, w, h)\r\n                if (this.borderEnabled && containerWidth / this.mainArray.length > 5) {\r\n                    ctx.strokeStyle = \"rgb(0, 0, 0)\"\r\n                    ctx.lineWidth = 1\r\n                    ctx.strokeRect(x, y, w, h)\r\n                } else {\r\n                    ctx.strokeStyle = \"rgb(\" + this.array[i].getColorForRender() + \")\"\r\n                    ctx.lineWidth = 1\r\n                    ctx.strokeRect(x, y, w, h)\r\n                }\r\n\r\n            }\r\n        }\r\n        else if(this.visualStyle === \"dots\"){\r\n            for (let i = 0; i < this.arrayLen; ++i) {\r\n                let height = this.array[i].getValue() / (this.mainArray.length - 1) * containerHeight\r\n\r\n                let x = offset * i\r\n                let y = containerHeight - height\r\n                let w = 0.5*rem\r\n                let h = 0.5*rem\r\n\r\n                ctx.fillStyle = \"rgb(\" + this.array[i].getColorForRender() + \")\"\r\n                ctx.fillRect(x, y, w, h)\r\n            }\r\n        }\r\n    }\r\n\r\n    render() {\r\n            return <div style={this.sizeStyle}>\r\n                <div ref={this.containerRef} className={styles.arrayContainer}>\r\n                    <canvas ref={this.canvasRef} className={styles.canvas}/>\r\n                </div>\r\n            </div>\r\n    }\r\n}","import React from 'react';\r\nimport styles from \"./Stats.module.scss\";\r\n\r\nexport function Stats(props){\r\n    return(\r\n        <div className={styles.statsContainer}>\r\n            <div><b>Sort: {props.sortName}</b></div>\r\n            <div>Length: {props.arrLength}</div>\r\n            <div>Comparisons: {props.comparisons}</div>\r\n            <div>Writes to main array: {props.mainWrites}</div>\r\n            <div>Writes to auxiliary arrays: {props.auxWrites}</div>\r\n            <div>Sort time: {props.sortTime.toFixed(2)} ms</div>\r\n        </div>\r\n    )\r\n}","export const GAP_FACTOR = 10\r\nexport let initFunctions = {\r\n    linear: function (x, length) {\r\n        return x;\r\n    },\r\n    // reverse: function (x, length) {\r\n    //     return length - x;\r\n    // },\r\n    // pipeOrgan: function (x, length) {\r\n    //     if (x < length / 2) {\r\n    //         return 2 * x;\r\n    //     } else {\r\n    //         return 2 * (length - x) - 1;\r\n    //     }\r\n    // },\r\n    // inversedPipeOrgan: function (x, length){\r\n    //     if (x < length / 2) {\r\n    //         return (length - 2*x) - 1;\r\n    //     } else {\r\n    //         return x*2-length;\r\n    //     }\r\n    // },\r\n    manySimular: function (x, length){\r\n        let divider = Math.trunc(length/GAP_FACTOR)\r\n        return Math.trunc(x/divider)*divider\r\n    },\r\n    sineWave: function (x, length){\r\n        return (Math.sin(x/length*Math.PI*2)*length+length)/2\r\n    }\r\n}","import {randomInt} from \"./utils\";\r\nimport {HeapSort} from \"../Sorts/HeapSort\";\r\nimport {GAP_FACTOR} from \"./initFunctions\";\r\nimport {DualPivotQuickSort} from \"../Sorts/DualPivotQuickSort\";\r\n\r\nexport let shuffles = {\r\n    FullShuffle: function (arrayVisualizer) {\r\n        let len = arrayVisualizer.getArrLength()\r\n        for (let i = 0; i < len; ++i) {\r\n            let randomIndex = randomInt(i, len)\r\n            arrayVisualizer.getWrites().swap(i, randomIndex, -1)\r\n        }\r\n        // return instructions\r\n    },\r\n\r\n    AlmostSorted: function (arrayVisualizer) {\r\n        let len = arrayVisualizer.getArrLength()\r\n        const AMOUNT = 0.1\r\n        for (let i = 0; i < len * AMOUNT; ++i) {\r\n            let randomIndexA = randomInt(i, len)\r\n            let randomIndexB = randomInt(i, len)\r\n            arrayVisualizer.getWrites().swap(randomIndexA, randomIndexB, -1)\r\n        }\r\n    },\r\n    Reverse: function (arrayVisualizer) {\r\n        let len = arrayVisualizer.getArrLength()\r\n        for (let i = 0; i < Math.trunc(len / 2); ++i) {\r\n            arrayVisualizer.getWrites().swap(i, len - i - 1, -1)\r\n        }\r\n    },\r\n    BlockShuffle: function (arrayVisualizer) {\r\n        let len = arrayVisualizer.getArrLength()\r\n        let gap = len / GAP_FACTOR\r\n        for (let i = 0; i < GAP_FACTOR - 1; ++i) {\r\n            let factor = randomInt(i + 1, GAP_FACTOR)\r\n            for (let j = 0; j < gap; ++j) {\r\n                arrayVisualizer.getWrites().swap(j + i * gap, j + factor * gap, -1)\r\n            }\r\n        }\r\n    },\r\n    PipeOrgan: function (arrayVisualizer) {\r\n        let len = arrayVisualizer.getArrLength()\r\n        let Reads = arrayVisualizer.getReads()\r\n        let temp = new Array(len);\r\n        for (let i = 0, j = 0; i < len; i += 2) {\r\n            temp[j++] = Reads.get(i, -1)\r\n        }\r\n        for (let i = 1, j = len; i < len; i += 2) {\r\n            temp[--j] = Reads.get(i, -1)\r\n        }\r\n        for (let i = 0; i < len; i++) {\r\n            arrayVisualizer.getWrites().write(i, temp[i], -1)\r\n        }\r\n    },\r\n    InversedPipeOrgan: function (arrayVisualizer) {\r\n        let len = arrayVisualizer.getArrLength()\r\n        let Reads = arrayVisualizer.getReads()\r\n        let temp = new Array(len);\r\n        for (let i = 0, j = 0; i < len; i += 2) {\r\n            temp[j++] = Reads.get(len - i - 1, -1)\r\n        }\r\n        for (let i = 1, j = len; i < len; i += 2) {\r\n            temp[--j] = Reads.get(len - i - 1, -1)\r\n        }\r\n        for (let i = 0; i < len; i++) {\r\n            arrayVisualizer.getWrites().write(i, temp[i], -1)\r\n        }\r\n    },\r\n    Heap: function (arrayVisualizer) {\r\n        let n = arrayVisualizer.getArrLength()\r\n        arrayVisualizer.initPseudoArray()\r\n        let heapSort = new HeapSort(arrayVisualizer)\r\n        heapSort.heapify(0, n)\r\n    },\r\n    QuickSortKiller: function (arrayVisualizer) {\r\n        let len = arrayVisualizer.getArrLength()\r\n        for (let j = len - len % 2 - 2, i = j - 1; i >= 0; i -= 2, j--) {\r\n            arrayVisualizer.getWrites().swap(i, j, -1)\r\n        }\r\n    },\r\n    GrailSortKiller: function (arrayVisualizer) {\r\n        // let Reads = arrayVisualizer.getReads()\r\n        let Writes = arrayVisualizer.getWrites()\r\n        let currentLen = arrayVisualizer.getArrLength()\r\n        if (currentLen <= 16) {\r\n\r\n            Writes.reversal(0, currentLen - 1, -1);\r\n        } else {\r\n            let blockLen = 1;\r\n            while (blockLen * blockLen < currentLen) {\r\n                blockLen *= 2;\r\n            }\r\n            let numKeys = Math.trunc((currentLen - 1) / blockLen) + 1;\r\n\r\n            let keys = blockLen + numKeys;\r\n            // shuffle(array, 0, currentLen, delay ? 0.25 : 0, Writes);\r\n\r\n            shuffles.FullShuffle(arrayVisualizer)\r\n\r\n            let sorter = new DualPivotQuickSort(arrayVisualizer)\r\n            sorter.runSort(0, keys-1)\r\n            Writes.reversal(0, keys - 1, -1);\r\n            sorter.runSort(keys, currentLen-1)\r\n            push(keys, currentLen, blockLen);\r\n        }\r\n\r\n        function rotate(a, m, b) {\r\n            Writes.reversal(a, m - 1);\r\n            Writes.reversal(m, b - 1);\r\n            Writes.reversal(a, b - 1);\r\n        }\r\n\r\n        function push(a, b, bLen) {\r\n            let len = b - a\r\n            let b1 = b - len % bLen, len1 = b1 - a;\r\n            if (len1 <= 2 * bLen) {\r\n                return;\r\n            }\r\n\r\n            let m = bLen;\r\n            while (2 * m < len) {\r\n                m *= 2;\r\n            }\r\n            m += a;\r\n\r\n            if (b1 - m < bLen) {\r\n                push(a, m, bLen);\r\n            } else {\r\n                m = a + b1 - m;\r\n                rotate(m - (bLen - 2), b1 - (bLen - 1), b1);\r\n                Writes.multiSwap(a, m, -1);\r\n                rotate(a, m, b1);\r\n                m = a + b1 - m;\r\n\r\n                push(a, m, bLen);\r\n                push(m, b, bLen);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import React from 'react';\r\nimport styles from \"./Controls.module.scss\";\r\nimport {initFunctions} from \"../utils/initFunctions\";\r\nimport {shuffles} from \"../utils/shuffles\";\r\n\r\n\r\nexport class Controls extends React.PureComponent {\r\n    isControlShow\r\n    arrayVisualizer\r\n    Sorts\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.isControlShow = true;\r\n        this.arrayVisualizer = props.arrayVisualizer\r\n        this.Sorts = props.Sorts\r\n        this.arrayVisualizer.updateArrLength(this.arrayVisualizer.DEFAULT_ARR_LEN)\r\n        // this.arrayVisualizer.initArray(initFunctions.linear)\r\n    }\r\n\r\n    updateArrLength() {\r\n        this.stopSort()\r\n        let slider = document.getElementById(styles.slider)\r\n\r\n        if (slider !== null) {\r\n            let len = slider.value\r\n            this.arrayVisualizer.updateArrLength(len)\r\n        }\r\n\r\n    }\r\n\r\n    toggleControlShow() {\r\n        // console.log(styles.controls)\r\n        let controlsContainer = document.getElementById(styles.controlsContainer)\r\n        let controls = document.getElementById(styles.controls)\r\n        let btn = document.getElementById(styles.showToggleBtn)\r\n        if (this.isControlShow) {\r\n            controls.style.display = \"none\"\r\n            controlsContainer.style.width = \"0\"\r\n            btn.innerHTML = \"&gt;&gt;\";\r\n        } else {\r\n            controls.style.display = \"block\"\r\n            controlsContainer.style.width = \"20rem\"\r\n            btn.innerHTML = \"&lt;&lt\";\r\n        }\r\n        this.isControlShow = !this.isControlShow\r\n    }\r\n\r\n    initArray(func) {\r\n        this.arrayVisualizer.initArray(func, this.arrayVisualizer.getArrLength(), true)\r\n    }\r\n\r\n    shuffleArray(func) {\r\n        this.stopSort()\r\n        this.arrayVisualizer.getDelays().setDelayIncFactor(this.arrayVisualizer.getDelays().DELAY_INC_CONST/10)\r\n        this.arrayVisualizer.shuffleArray(func)\r\n        this.arrayVisualizer.getDelays().restoreDelayIncFactor()\r\n        // func(this.arrayVisualizer)\r\n    }\r\n\r\n    sortArray(sortName) {\r\n        this.stopSort()\r\n        this.Sorts.runSort(sortName, 0, this.arrayVisualizer.getArrLength() - 1)\r\n    }\r\n\r\n    stopSort() {\r\n        this.arrayVisualizer.stopSort()\r\n        // this.Delays.resetDelays()\r\n        // this.arrayVisualizer.nullify()\r\n    }\r\n\r\n    abortSort() {\r\n        this.stopSort()\r\n        this.initArray(initFunctions.linear)\r\n    }\r\n\r\n    genInitFunctions() {\r\n        // console.log(initFunctions)\r\n        let tmp = []\r\n        for (let i in initFunctions) {\r\n            tmp.push(\r\n                <button key={i} onClick={this.initArray.bind(this, initFunctions[i])}>{i}</button>\r\n            )\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    getSorts() {\r\n        let tmp = []\r\n        let sortsNames = this.Sorts.getSortsPaths()\r\n        for (let i of sortsNames) {\r\n            tmp.push(\r\n                <button key={i} onClick={this.sortArray.bind(this, i)}>{i}</button>)\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    getShuffles() {\r\n        let tmp = []\r\n        for (let i in shuffles) {\r\n            tmp.push(\r\n                <button key={i} onClick={this.shuffleArray.bind(this, shuffles[i])}>{i}</button>\r\n            )\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    toggleShowAuxArrays() {\r\n        let element = document.getElementById(\"auxArrShowCB\")\r\n        this.arrayVisualizer.setShowAuxArrays(element.checked)\r\n    }\r\n\r\n    toggleBarsStroke() {\r\n        let element = document.getElementById(\"enableStrokeCB\")\r\n        this.arrayVisualizer.setEnableBarsStroke(element.checked)\r\n    }\r\n\r\n    toggleEnableMarks() {\r\n        let element = document.getElementById(\"enableMarksCB\")\r\n        this.arrayVisualizer.setEnableMarks(element.checked)\r\n    }\r\n\r\n    toggleVisualStyle(val) {\r\n        this.arrayVisualizer.setVisualStyle(val)\r\n    }\r\n\r\n    toggleRainbow(val){\r\n        this.arrayVisualizer.getMarks().setRainbow(val)\r\n    }\r\n\r\n    toggleShowStats(){\r\n        let element = document.getElementById(\"showStatsCB\")\r\n        this.arrayVisualizer.setShowStats(element.checked)\r\n    }\r\n\r\n    restoreArray(){\r\n        this.stopSort()\r\n        this.arrayVisualizer.restoreArray()\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div id={styles.controlsContainer}>\r\n                {/*<div onClick={this.toggleControlShow.bind(this)} id={styles.showToggleBtn}>&lt;&lt;</div>*/}\r\n                <div id={styles.controls}>\r\n                    <div>\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Array Size</div>\r\n                            <input id={styles.slider} type=\"range\" min=\"10\" max=\"1000\"\r\n                                   defaultValue={this.arrayVisualizer.DEFAULT_ARR_LEN}\r\n                                   step=\"10\"\r\n                                   onChange={this.updateArrLength.bind(this)}/>\r\n                        </div>\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Visuals</div>\r\n                            <div style={{display: \"flex\", justifyContent:\"center\"}}>\r\n                                <div style={{textAlign: \"left\"}}>\r\n                                    <div className={styles.checkBoxContainer}>\r\n                                        <input onChange={this.toggleShowAuxArrays.bind(this)} type=\"checkbox\"\r\n                                               id=\"auxArrShowCB\"\r\n                                               name=\"auxArrShowCB\" defaultChecked={true}/>\r\n                                        <label htmlFor=\"auxArrShowCB\">Show Aux Arrays</label>\r\n                                    </div>\r\n                                    <div className={styles.checkBoxContainer}>\r\n                                        <input onChange={this.toggleBarsStroke.bind(this)} type=\"checkbox\"\r\n                                               id=\"enableStrokeCB\"\r\n                                               name=\"enableStrokeCB\" defaultChecked={true}/>\r\n                                        <label htmlFor=\"enableStrokeCB\">Enable Bars Stroke</label>\r\n                                    </div>\r\n                                    <div className={styles.checkBoxContainer}>\r\n                                        <input onChange={this.toggleEnableMarks.bind(this)} type=\"checkbox\"\r\n                                               id=\"enableMarksCB\"\r\n                                               name=\"enableMarksCB\" defaultChecked={true}/>\r\n                                        <label htmlFor=\"enableMarksCB\">Enable Marks(Disable to reduce lags)</label>\r\n                                    </div>\r\n                                    <div className={styles.checkBoxContainer}>\r\n                                        <input onChange={this.toggleShowStats.bind(this)} type=\"checkbox\"\r\n                                               id=\"showStatsCB\"\r\n                                               name=\"showStatsCB\" defaultChecked={true}/>\r\n                                        <label htmlFor=\"showStatsCB\">Show stats</label>\r\n                                    </div>\r\n                                    <div className={styles.checkBoxContainer}>\r\n                                        <button onClick={this.toggleRainbow.bind(this, true)}>Paint to Rainbow</button>\r\n                                        <button onClick={this.toggleRainbow.bind(this, false)}>Clear Color</button>\r\n                                    </div>\r\n                                </div>\r\n                            </div>\r\n                        </div>\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Visual Styles</div>\r\n                            <div>\r\n                                <input onChange={this.toggleVisualStyle.bind(this, \"bars\")} type=\"radio\"\r\n                                       id=\"barsRadioBtn\"\r\n                                       name=\"visualStyle\" value=\"bars\" defaultChecked={true}/>\r\n                                <label htmlFor=\"barsRadioBtn\">Bars</label>\r\n\r\n                                <input onChange={this.toggleVisualStyle.bind(this, \"dots\")} type=\"radio\"\r\n                                       id=\"dotsRadioBtn\"\r\n                                       name=\"visualStyle\" value=\"dots\"/>\r\n                                <label htmlFor=\"dotsRadioBtn\">Dots</label>\r\n                            </div>\r\n                        </div>\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Init Array</div>\r\n                            <div>{this.genInitFunctions()}</div>\r\n                            <div><button onClick={this.restoreArray.bind(this)}>RESTORE ARRAY</button></div>\r\n                        </div>\r\n\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Shuffle Array</div>\r\n                            <div>\r\n                                {/*<button onClick={this.shuffleArray.bind(this)}>Random</button>*/}\r\n                                <div>{this.getShuffles()}</div>\r\n                            </div>\r\n                        </div>\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Sort control</div>\r\n                            <div>\r\n                                <button onClick={this.abortSort.bind(this)}>Abort Sort(Recommended)</button>\r\n                                <button onClick={this.stopSort.bind(this)}>Stop Sort(Not Recommended)</button>\r\n                            </div>\r\n                        </div>\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Sort Array</div>\r\n                            <div>\r\n                                {this.getSorts()}\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}","export class Sounds{\r\n    arrayVisualizer\r\n    ctx\r\n    Delays\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.Delays = arrayVisualizer.getDelays()\r\n        this.ctx = new (window.AudioContext || window.webkitAudioContext)();\r\n    }\r\n    playSound(value) {\r\n        let osc = this.ctx.createOscillator();\r\n        osc.type = 'sine';\r\n\r\n        let k = value / this.arrayVisualizer.getArrLength()\r\n        osc.frequency.value = 2000 * k + 200;\r\n\r\n        let addTime = 50\r\n\r\n        let gainNode = this.ctx.createGain()\r\n        gainNode.gain.value = 0;\r\n        osc.connect(gainNode)\r\n        gainNode.connect(this.ctx.destination)\r\n        // console.log(this.Delays.getDelayInc())\r\n        gainNode.gain.linearRampToValueAtTime(0.05, this.ctx.currentTime + (this.Delays.getDelayInc() + addTime) / 1000 / 2)\r\n        gainNode.gain.linearRampToValueAtTime(0, this.ctx.currentTime + (this.Delays.getDelayInc() + addTime) / 1000)\r\n\r\n        osc.start();\r\n        osc.stop(this.ctx.currentTime + (this.Delays.getDelayInc() + addTime) / 1000);\r\n    }\r\n}","import {HSL2RGB, randomInt} from \"../utils/utils\";\r\n\r\nexport const colors = {\r\n    \"Unmarked\": [255, 255, 255],\r\n    \"Default\": [255, 0, 0],\r\n    \"Additional\": [randomInt(0, 256), randomInt(0, 256), randomInt(0, 256)],\r\n    \"Sorted\": [0, 255, 0],\r\n    \"Analysis\": [0, 0, 255]\r\n}\r\nexport class Marks{\r\n    arrayVisualizer\r\n    Delays\r\n\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.Delays = arrayVisualizer.getDelays()\r\n    }\r\n\r\n    mark(index, args, arrIndex = -1, saveArr = true) {\r\n        if(!this.arrayVisualizer.getEnableMarks()){\r\n            return;\r\n        }\r\n        let type = \"Default\"\r\n        let color = colors[\"Default\"]\r\n        let tmpArr = this.arrayVisualizer.getArray(arrIndex, false)\r\n        // Additional\r\n        if (args.type === \"Additional\") {\r\n            type = \"Additional\"\r\n            color = args.color\r\n            // console.log(color)\r\n        }\r\n        //Default\r\n        else if (args.type === \"Default\") {\r\n            type = \"Default\"\r\n            color = colors[\"Default\"]\r\n        } else {\r\n            type = args.type\r\n            color = args.color\r\n            // console.log(color)\r\n        }\r\n\r\n        tmpArr[index].setType(type)\r\n        tmpArr[index].setMarkColor(color)\r\n        if (saveArr) {\r\n            this.arrayVisualizer.setState({\r\n                array: tmpArr\r\n            })\r\n        } else {\r\n            return tmpArr\r\n        }\r\n        // console.log(color);\r\n    }\r\n\r\n    markMany(indexes, args, arrIndex = -1, saveArr = false) {\r\n        let tmpArr = this.arrayVisualizer.getArray(arrIndex, false)\r\n        for (let i of indexes) {\r\n            if (saveArr) {\r\n                this.mark(i, args, arrIndex, saveArr)\r\n            } else {\r\n                tmpArr = this.mark(i, args, arrIndex, saveArr)\r\n            }\r\n        }\r\n        if (!saveArr) {\r\n            return tmpArr\r\n        }\r\n    }\r\n\r\n    unmark(index, arrIndex = -1, saveArr = true) {\r\n        let tmpArr = this.arrayVisualizer.getArray(arrIndex, false)\r\n        // tmpArr[index].setMarkColor(colors[\"Unmarked\"])\r\n        tmpArr[index].setType(\"Unmarked\")\r\n        if (saveArr) {\r\n            this.arrayVisualizer.setState({\r\n                array: tmpArr\r\n            })\r\n        } else {\r\n            return tmpArr\r\n        }\r\n    }\r\n\r\n    unmarkMany(indexes, arrIndex = -1, saveArr, saveOnce) {\r\n        let tmpArr = this.arrayVisualizer.getArray(arrIndex, false)\r\n        for (let i of indexes) {\r\n            if (saveArr) {\r\n                this.unmark(i, arrIndex, saveArr)\r\n            } else {\r\n                tmpArr = this.unmark(i, arrIndex, saveArr)\r\n            }\r\n        }\r\n        if (saveOnce) {\r\n            this.arrayVisualizer.setState({\r\n                array: tmpArr\r\n            })\r\n        }\r\n        if (!saveArr) {\r\n            return tmpArr\r\n        }\r\n    }\r\n\r\n    setRainbow(val){\r\n        let tmpArr = this.arrayVisualizer.getArray(-1, false)\r\n        if(val){\r\n            for(let i = 0; i < tmpArr.length; ++i){\r\n                let hsl = [i / tmpArr.length, 0.8, 0.5]\r\n                let rgb = HSL2RGB(hsl[0], hsl[1], hsl[2])\r\n                tmpArr[i].setColor(rgb)\r\n            }\r\n        }else{\r\n            for(let i of tmpArr){\r\n                i.setColor([255, 255, 255])\r\n            }\r\n        }\r\n        this.arrayVisualizer.setState({\r\n            array: tmpArr\r\n        })\r\n    }\r\n\r\n    markUnmarkMany(markIndexes, markArgs, arrIndex = -1) {\r\n        this.markMany(markIndexes, markArgs, arrIndex, true)\r\n        this.Delays.push(setTimeout(this.unmarkMany.bind(this), this.Delays.incDelay(\"Unmark\", this.Delays.getDelayInc() / 500), markIndexes, arrIndex, false, true))\r\n    }\r\n\r\n    clearAllMarks(){\r\n        this.unmarkMany(Array.from(Array(this.arrayVisualizer.getArrLength()).keys()), -1, false, true)\r\n    }\r\n\r\n}","import {Delays} from \"./Delays\";\r\nimport {Marks} from \"./Marks\";\r\nimport {Sounds} from \"./Sounds\";\r\n\r\nexport class Reads{\r\n    arrayVisualizer;\r\n    Sounds\r\n    Delays\r\n    Marks\r\n    constructor(arrayVisualizer){\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.Sounds = arrayVisualizer.getSounds()\r\n        this.Delays = arrayVisualizer.getDelays()\r\n        this.Marks = arrayVisualizer.getMarks()\r\n    }\r\n\r\n    //TODO refactoring\r\n\r\n    readValue(index, arrIndex=-1) {\r\n        let arr = this.arrayVisualizer.getArray(arrIndex, true)\r\n        return arr[index].getValue()\r\n    }\r\n\r\n    compareInArr(a, b, arrIndex=-1) {\r\n        let arr = this.arrayVisualizer.getArray(arrIndex, true)\r\n        return this.compareValues(arr[a], arr[b])\r\n    }\r\n\r\n    get(index, arrIndex=-1){\r\n        let arr = this.arrayVisualizer.getArray(arrIndex, true)\r\n        return arr[index];\r\n    }\r\n\r\n    compareValues(a, b){\r\n        let Mark = function (index, value, arrIndex){\r\n            return {index: index, value: value, arrIndex: arrIndex}\r\n        }\r\n        //TODO working marks with aux arrays\r\n        let parseMark = (val) => {\r\n            let elementIndex = -1\r\n            let arrayIndex = -1\r\n            let mainArray = this.arrayVisualizer.getArray(-1, true)\r\n            // let auxArrays = this.arrayVisualizer.getAuxArrays(true)\r\n            // for(let i = 0; i < auxArrays.length;++i){\r\n            //     elementIndex = auxArrays[i].findIndex(element => {return element.getValue() === val})\r\n            //     if(elementIndex!==-1){\r\n            //         arrayIndex = i\r\n            //     }\r\n            // }\r\n            if(arrayIndex === -1){\r\n                elementIndex = mainArray.findIndex(element => {return element.getValue() === val})\r\n            }\r\n            return new Mark(elementIndex, val, arrayIndex)\r\n        }\r\n        let marks = []\r\n        let checkObj = (obj) => {\r\n            let tmpVal\r\n            if(typeof obj === \"object\"){\r\n                tmpVal = obj.getValue()\r\n                let mark = parseMark(tmpVal)\r\n                if(mark.index !== -1){\r\n                    marks.push(mark)\r\n                }\r\n            }else{\r\n                tmpVal = obj\r\n            }\r\n            return tmpVal\r\n        }\r\n\r\n        this.Delays.incOperationsCounter(1)\r\n        let tmpA = checkObj(a)\r\n        let tmpB = checkObj(b)\r\n\r\n\r\n        // let tmpA = typeof a === \"object\" ? a.getValue() : a\r\n        // let tmpB = typeof b === \"object\" ? b.getValue() : b\r\n\r\n        this.compareWithDelay(marks)\r\n        return tmpA - tmpB;\r\n    }\r\n\r\n    compareWithDelay(marks, delay = this.Delays.getDelayInc()/5){\r\n        this.Delays.push(setTimeout(this.compareStub.bind(this), this.Delays.incDelay(\"Write\", delay), marks))\r\n    }\r\n\r\n    compareStub(marks){\r\n        let curComparisons = this.arrayVisualizer.getState().comparisons + 1\r\n        this.arrayVisualizer.setState({\r\n            comparisons: curComparisons\r\n        })\r\n        for(let i of marks){\r\n            this.Sounds.playSound(i.value)\r\n            this.Marks.markUnmarkMany([i.index],{type: \"Default\"}, i.arrIndex)\r\n        }\r\n        this.Delays.updateSortTime()\r\n\r\n\r\n        // this.Marks.markUnmarkMany(toMark,{type: \"Additional\", color: [0,255,0]})\r\n    }\r\n\r\n    // auxGet(index, arrIndex, isPseudo = true){\r\n    //     if(isPseudo){\r\n    //         return this.arrayVisualizer.getPseudoAuxArrays()[arrIndex][index]\r\n    //     }else {\r\n    //         return this.arrayVisualizer.getAuxArrays()[arrIndex][index]\r\n    //     }\r\n    // }\r\n    //\r\n    //\r\n    // auxReadValue(index, arrIndex, isPseudo = true){\r\n    //     if(isPseudo){\r\n    //         return this.arrayVisualizer.getPseudoAuxArrays()[arrIndex][index].getValue()\r\n    //     }else {\r\n    //         return this.arrayVisualizer.getAuxArrays()[arrIndex][index].getValue()\r\n    //     }\r\n    // }\r\n}","import React from 'react';\r\nimport {arraysEquals, deepArrayCopy, getAllMethods, objLength, randomInt} from \"../utils/utils\";\r\nimport {Sorts} from \"../Sorts/Sorts\"\r\nimport {ArrayWindow} from \"../ArrayWindow/ArrayWindow\";\r\nimport {Element} from \"../classes/Element\";\r\nimport {Stats} from \"../Stats/Stats\";\r\nimport {Controls} from \"../Controls/Controls\";\r\nimport {initFunctions} from \"../utils/initFunctions\";\r\nimport {Delays} from \"../ArrayAccess/Delays\";\r\nimport {Sounds} from \"../ArrayAccess/Sounds\";\r\nimport {Marks} from \"../ArrayAccess/Marks\";\r\nimport {Reads} from \"../ArrayAccess/Reads\";\r\nimport {Writes} from \"../ArrayAccess/Writes\";\r\n\r\nconst colors = {\r\n    \"Unmarked\": [255, 255, 255],\r\n    \"Default\": [255, 0, 0],\r\n    \"Additional\": [randomInt(0, 256), randomInt(0, 256), randomInt(0, 256)],\r\n    \"Sorted\": [0, 255, 0],\r\n    \"Analysis\": [0, 0, 255]\r\n}\r\n\r\nexport class ArrayVisualizer extends React.Component {\r\n    delays;\r\n    delayInc;\r\n    pseudoArray;\r\n    pseudoAuxArrays;\r\n\r\n    static MAIN_ARRAY = -1\r\n\r\n    Sorts\r\n    delayIncConst\r\n    showAuxArrays\r\n    showStats\r\n    enableBarsStroke\r\n    visualStyle\r\n    enableMarks\r\n\r\n    Delays\r\n    Sounds\r\n    Marks\r\n    Reads\r\n    Writes\r\n\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.DEFAULT_ARR_LEN = 100\r\n        this.state = {\r\n            array: this.initArray(initFunctions.linear, this.DEFAULT_ARR_LEN),\r\n            sortName: \"\",\r\n            comparisons: 0,\r\n            mainWrites: 0,\r\n            auxWrites: 0,\r\n            sortTime: 0,\r\n            auxArrays: {}\r\n        }\r\n        this.pseudoArray = deepArrayCopy(this.state.array)\r\n        this.Delays = new Delays(this)\r\n        this.Sounds = new Sounds(this)\r\n        this.Marks = new Marks(this)\r\n        this.Reads = new Reads(this)\r\n\r\n        this.prevArray = []\r\n\r\n        this.Writes = new Writes(this)\r\n        this.pseudoAuxArrays = {}\r\n        this.Sorts = new Sorts(this);\r\n        this.showAuxArrays = true\r\n        this.showStats = true\r\n        this.enableBarsStroke = true\r\n        this.enableMarks = true\r\n        this.visualStyle = {\r\n            // style: \"bars\",\r\n            style: \"bars\",\r\n            barsStroke: true,\r\n        }\r\n    }\r\n\r\n    initArray(func, length, setToState=false) {\r\n        let arr = []\r\n        for (let i = 0; i < length; ++i) {\r\n            let element = new Element(func(i, length), \"Unmarked\", [255, 255, 255], [0,0,0,0])\r\n            arr.push(element)\r\n        }\r\n        if(setToState){\r\n            // eslint-disable-next-line react/no-direct-mutation-state\r\n            this.state.array = arr;\r\n            this.setState({\r\n                array: arr\r\n            })\r\n            this.initPseudoArray()\r\n        }else {\r\n            return arr;\r\n        }\r\n    }\r\n\r\n    nullify() {\r\n        this.Delays.resetDelays()\r\n        this.setState(\r\n            {\r\n                comparisons: 0,\r\n                mainWrites: 0,\r\n                auxWrites: 0,\r\n                sortTime: 0\r\n            }\r\n        )\r\n        // eslint-disable-next-line react/no-direct-mutation-state\r\n        this.state.writes = 0;\r\n        // eslint-disable-next-line react/no-direct-mutation-state\r\n        this.state.comparisons = 0;\r\n    }\r\n\r\n    setShowAuxArrays(val){\r\n        this.showAuxArrays = val\r\n    }\r\n\r\n    setShowStats(val){\r\n        this.showStats = val\r\n        this.forceMainArrayUpdate()\r\n    }\r\n\r\n    setEnableBarsStroke(val){\r\n        this.visualStyle.barsStroke = val;\r\n        this.forceMainArrayUpdate()\r\n    }\r\n\r\n    setVisualStyle(val){\r\n        this.visualStyle.style = val;\r\n        this.forceMainArrayUpdate()\r\n    }\r\n\r\n    setEnableMarks(val){\r\n        this.enableMarks = val;\r\n        if(!val){\r\n            this.Marks.clearAllMarks()\r\n        }\r\n    }\r\n\r\n    getEnableMarks(){\r\n        return this.enableMarks;\r\n    }\r\n\r\n    getArrayVisualizer() {\r\n        return this;\r\n    }\r\n\r\n    getState(){\r\n        return this.state\r\n    }\r\n\r\n    getArrLength(){\r\n        return this.state.array.length;\r\n    }\r\n\r\n    getArray(arrIndex, isPseudo = false){\r\n        if(arrIndex === -1){\r\n            return isPseudo ? this.pseudoArray : this.state.array\r\n        }else{\r\n            if(isPseudo){\r\n                return this.pseudoAuxArrays[arrIndex]\r\n            }else{\r\n                console.log(\"Non-Pseudo Aux Arrays:\")\r\n                console.log(this.state.auxArrays)\r\n                // throw new Error(\"LOL\")\r\n                return this.state.auxArrays[arrIndex]\r\n            }\r\n        }\r\n    }\r\n\r\n    getAuxArrays(isPseudo){\r\n        return isPseudo ? this.pseudoAuxArrays : this.state.auxArrays\r\n    }\r\n\r\n    getDelays(){\r\n        return this.Delays\r\n    }\r\n\r\n    getSounds(){\r\n        return this.Sounds;\r\n    }\r\n\r\n    getMarks(){\r\n        return this.Marks;\r\n    }\r\n\r\n    getReads(){\r\n        return this.Reads;\r\n    }\r\n\r\n    getWrites(){\r\n        return this.Writes\r\n    }\r\n\r\n\r\n    stopSort(){\r\n        // this.resetDelay()\r\n        this.Delays.resetDelays()\r\n        this.Marks.clearAllMarks()\r\n        this.setState({\r\n                auxArrays: []\r\n            }\r\n        )\r\n    }\r\n\r\n    shuffleArray(func) {\r\n        this.nullify()\r\n        this.setState({\r\n            sortName: \"Shuffle\"\r\n        })\r\n        this.backupArray()\r\n        func(this);\r\n        // let instructions = func(this);\r\n        // for(let i of instructions){\r\n        //     if(i.cmd === \"swap\"){\r\n        //         this.Writes.swapWithDelay(i.a, i.b, this.state.array, true, this.Delays.getDelayInc()/5, true)\r\n        //     }\r\n        // }\r\n\r\n    }\r\n\r\n    restoreArray(){\r\n        this.setState({\r\n            array: deepArrayCopy(this.prevArray)\r\n        })\r\n    }\r\n\r\n    backupArray(){\r\n        this.prevArray = deepArrayCopy(this.state.array)\r\n    }\r\n\r\n\r\n    setSortName(sortName){\r\n        this.setState({\r\n            sortName: sortName\r\n        })\r\n    }\r\n\r\n    initPseudoArray(){\r\n        this.pseudoArray = deepArrayCopy(this.state.array)\r\n    }\r\n\r\n    sortClickEvent() {\r\n    }\r\n\r\n    forceMainArrayUpdate(){\r\n        let tmp = this.state.array;\r\n        this.setState({\r\n            array: tmp\r\n        })\r\n    }\r\n\r\n    updateDelayInc(val){\r\n        this.delayInc = val/this.getArrLength();\r\n    }\r\n\r\n    updateArrLength(len){\r\n        let tmpArr = this.initArray(initFunctions.linear, len)\r\n        // eslint-disable-next-line react/no-direct-mutation-state\r\n        this.state.array = tmpArr\r\n        this.setState({\r\n            array: tmpArr\r\n        })\r\n\r\n        this.initPseudoArray()\r\n\r\n        this.Sorts.arrLength = this.getArrLength()\r\n        // this.updateDelayInc(this.delayIncConst)\r\n        this.Delays.updateDelayInc();\r\n    }\r\n\r\n    genArrayWindows(){\r\n        let tmp = []\r\n        if(this.showAuxArrays) {\r\n            let len = objLength(this.state.auxArrays)\r\n            for (let i = len - 1; i >= 0; i--) {\r\n                // console.log(this.state.auxArrays[i])\r\n                tmp.push(\r\n                    <ArrayWindow key={len - i} array={this.state.auxArrays[i]}\r\n                                 mainArray={this.state.array} height={100 / (1 + len)} visualProps = {this.visualStyle} />\r\n                )\r\n            }\r\n        }\r\n        return tmp\r\n    }\r\n\r\n    genStats(){\r\n        if(this.showStats){\r\n            return <Stats sortName={this.state.sortName} comparisons={this.state.comparisons} mainWrites={this.state.mainWrites} auxWrites={this.state.auxWrites} arrLength={this.getArrLength()} sortTime={this.state.sortTime}/>\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                {this.genStats()}\r\n                <div style={{height: \"100vh\"}}>\r\n                    {this.genArrayWindows()}\r\n                    <ArrayWindow array={this.state.array} mainArray={this.state.array} height={this.showAuxArrays ? 100/(1+objLength(this.state.auxArrays)) : 100} visualProps={this.visualStyle}/>\r\n                </div>\r\n                <div>\r\n                    <Controls arrayVisualizer={this} Sorts={this.Sorts}/>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport {ArrayVisualizer} from \"./components/ArrayVisualizer/ArrayVisualizer\";\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\n\r\n\r\n\r\n\r\n\r\nReactDOM.render(\r\n    <ArrayVisualizer></ArrayVisualizer>,\r\n  document.getElementById('root')\r\n);\r\n\r\n\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}