{"version":3,"sources":["components/Sorts/Sort.js","components/utils/utils.js","components/Controls/Controls.module.scss","components/ArrayWindow/ArrayWindow.module.scss","components/Sorts/InsertionSort.js","components/classes/Element.js","components/Sorts/HeapSort.js","components/ArrayAccess/Delays.js","components/ArrayAccess/Writes.js","components/Sorts/Sorts.js","components/Stats/Stats.module.scss","components/Sorts sync /^/.*/.js$","components/Sorts/BitonicSort.js","components/Sorts/BubbleSort.js","components/Sorts/DualPivotQuickSort.js","components/Sorts/GnomeSort.js","components/Sorts/GrailSort.js","components/Sorts/IntroSort.js","components/Sorts/LLQuickSort.js","components/Sorts/LRQuickSort.js","components/Sorts/LSDRadixSort.js","components/Sorts/MergeSort.js","components/Sorts/PseudoTimSort.js","components/Sorts/SelectionSort.js","components/Sorts/SlowSort.js","components/Sorts/StoogeSort.js","components/Sorts/TimSort.js","components/ArrayWindow/ArrayWindow.js","components/Stats/Stats.js","components/utils/initFunctions.js","components/utils/shuffles.js","components/Controls/Controls.js","components/ArrayAccess/Sounds.js","components/ArrayAccess/Marks.js","components/ArrayAccess/Reads.js","components/ArrayVisualizer/ArrayVisualizer.js","reportWebVitals.js","index.js"],"names":["Sort","arrayVisualizer","this","state","getState","Reads","getReads","Writes","getWrites","arrLength","getArrLength","sortName","warnLen","isDisabled","isNeedBucketsNum","low","high","bucketsNum","bufferSize","randomInt","a","b","Math","trunc","random","deepArrayCopy","arr","out","i","value","getValue","type","getType","color","getColor","markColor","getMarkColor","push","Element","objLength","obj","undefined","Object","keys","length","HSL2RGB","h","s","l","r","g","hue2rgb","p","q","t","round","module","exports","InsertionSort","key","get","j","compareValues","write","unMark","toString","HeapSort","root","dist","start","leaf","compareInArr","swap","siftDown","heapify","heapSort","Delays","timeoutArray","delays","Swap","Write","Comp","Unmark","CreateAuxArray","RemoveAuxArray","Other","DELAY_INC_CONST","updateDelayInc","delayIncFactor","delayInc","timeout","func","delayName","delay","args","setTimeout","bind","clearTimeout","name","inc","Sounds","getSounds","getDelays","Marks","getMarks","getPseudoArray","mark","getDelayInc","playSound","swapInArr","curWrites","mainWrites","setState","incDelay","tmpArr","tmp","copy","markUnmarkMany","swapWithDelay","getMainArray","index","toWrite","writeInArr","writeWithDelay","len","isPseudo","pseudoAuxArrays","getPseudoAuxArrays","auxArrIndex","initArray","createAuxArrayWithDelay","getAuxArrays","auxArrays","createAuxArray","removeAuxArrayWithDelay","removeAuxArray","arrIndex","auxWriteWithDelay","auxWrites","auxWrite","Sorts","sortsPaths","sortPath","require","resetDelays","nullify","sort","getSortObject","getWarnLen","parseInt","prompt","isNaN","alert","max","window","confirm","isNeedBuffer","initPseudoArray","setSortName","getSortName","backupArray","runSort","checkSort","isSorted","array","clearAllMarks","forceMainArrayUpdate","map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","e","Error","code","resolve","BitonicSort","sortLength","k","m","ij","bitonicSort","BubbleSort","DualPivotQuickSort","left","right","divisor","third","med1","med2","pivot1","readValue","pivot2","less","great","dualPivot","GnomeSort","Subarray","GrailSort","blockLen","grailSwap","srcArray","srcPos","destArray","destPos","copyLen","auxGet","leftLen","rightLen","grailBlockSwap","item","target","middle","idealKeys","keysFound","firstKey","currentKey","insertPos","grailBinarySearchLeft","grailRotate","bufferOffset","end","buffer","currentMerge","bufferLen","mergeLen","mergeIndex","mergeEnd","grailMergeForwards","leftOver","finalBlock","finalOffset","grailMergeBackwards","externLen","arraycopy","externalBuffer","grailPairwiseWrites","grailMergeOutOfPlace","offset","grailBuildInPlace","externalBufferLen","grailBuildOutOfPlace","grailPairwiseSwaps","medianKey","blockCount","block","compare","resetLen","leftOvers","leftBlocks","firstRightBlock","prevLeftBlock","leftOrigin","currentBlockLen","grailInPlaceBufferRewind","currentBlockOrigin","grailBinarySearchRight","grailOutOfPlaceBufferRewind","finalLeftBlocks","finalLen","currentBlock","blockIndex","grailGetSubarray","keyIndex","grailSmartMerge","grailSmartLazyMerge","grailLazyMerge","grailSmartMergeOutOfPlace","subarrayLen","mergeCount","lastSubarray","grailInsertSort","grailBlockSelectSort","grailMergeBlocks","grailLazyMergeBlocks","rightBlocks","lastFragment","grailCountFinalLeftBlocks","leftLength","grailInPlaceBufferReset","grailMergeBlocksOutOfPlace","grailOutOfPlaceBufferReset","grailCombineOutOfPlace","grailCombineInPlace","leftEnd","extBuf","extBufLen","idealBuffer","keyLen","grailCollectKeys","grailLazyStableSort","bufferEnd","grailBuildBlocks","scrollingBuffer","blockKeysSum","minKeys","calcMinKeys","grailCombineBlocks","grailCommonSort","grailSortInPlace","console","log","numKeys","IntroSort","sizeThreshold","floor","mid","lo","hi","x","depthLimit","partition","medianof3","introsortLoop","floorLogBaseTwo","LLQuickSort","pivot","LRQuickSort","quickSort","LSDRadixSort","highestPower","registers","Array","stabVal","min","tempArray","tempWrite","radix","total","pos","MergeSort","merge","nxt","PseudoTimSort","MIN_MERGE","n","len1","len2","minRun","minRunLength","size","pseudoTimSort","SelectionSort","minIndex","SlowSort","StoogeSort","TimSort","minGallop","tmpStorageLength","stackLength","runStart","runLength","stackSize","runHi","reverseRun","isAux","hint","lastOffset","maxOffset","auxReadValue","mergeAt","start1","length1","start2","length2","gallopRight","gallopLeft","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","customCursor","customDest","remaining","makeAscendingRun","binaryInsertionSort","force","pushRun","mergeRuns","forceMergeRuns","ArrayWindow","props","setProps","renderedArray","renderArray","isTimerEnded","isRunNeed","updateState","mainArray","height","visualProps","borderEnabled","barsStroke","visualStyle","style","arrayLen","sizeStyle","width","nextProps","nextContext","throttled","border","styleSheet","backgroundColor","getColorForRender","className","styles","bar","bottom","dotContainer","dot","arrayContainer","React","PureComponent","Stats","statsContainer","comparisons","initFunctions","linear","manySimular","divider","shuffles","FullShuffle","randomIndex","AlmostSorted","randomIndexA","randomIndexB","Reverse","BlockShuffle","gap","GAP_FACTOR","factor","PipeOrgan","temp","InversedPipeOrgan","Heap","QuickSortKiller","Controls","isControlShow","sorts","updateArrLength","DEFAULT_ARR_LEN","stopSort","slider","document","getElementById","controlsContainer","controls","btn","showToggleBtn","display","innerHTML","shuffleArray","onClick","sortsNames","getSortsPaths","sortArray","element","setShowAuxArrays","checked","setEnableBarsStroke","setEnableMarks","val","setVisualStyle","setRainbow","restoreArray","sectionHeader","defaultValue","step","onChange","justifyContent","textAlign","checkBoxContainer","toggleShowAuxArrays","defaultChecked","htmlFor","toggleBarsStroke","toggleEnableMarks","toggleRainbow","toggleVisualStyle","genInitFunctions","getShuffles","abortSort","getSorts","ctx","AudioContext","webkitAudioContext","osc","createOscillator","frequency","gainNode","createGain","gain","connect","destination","linearRampToValueAtTime","currentTime","stop","colors","saveArr","getEnableMarks","setType","setMarkColor","indexes","saveOnce","unmark","hsl","rgb","setColor","markIndexes","markArgs","markMany","unmarkMany","from","curComparisons","compareWithDelay","toSound","tmpA","tmpB","toMark","findIndex","compareStub","ArrayVisualizer","maiWrites","pseudoArray","prevArray","showAuxArrays","enableBarsStroke","enableMarks","setToState","writes","genArrayWindows","Component","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render"],"mappings":"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","file":"static/js/main.c7565ba9.chunk.js","sourcesContent":["export class Sort {\r\n    arrayVisualizer;\r\n\r\n    Reads\r\n    Writes\r\n\r\n    arrLength;\r\n\r\n    sortName;\r\n    warnLen;\r\n    isDisabled;\r\n    isNeedBucketsNum;\r\n    isNeedBuffer;\r\n\r\n\r\n\r\n\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.state = this.arrayVisualizer.getState()\r\n\r\n        this.Reads = this.arrayVisualizer.getReads()\r\n        this.Writes = this.arrayVisualizer.getWrites()\r\n\r\n        \r\n        this.arrLength = this.arrayVisualizer.getArrLength();\r\n        this.sortName = \"\"\r\n        this.warnLen = -1;\r\n        this.isDisabled = false;\r\n        this.isNeedBucketsNum = false;\r\n    }\r\n\r\n    getSortName(){\r\n        return this.sortName\r\n    }\r\n\r\n    getWarnLen(){\r\n        return this.warnLen\r\n    }\r\n\r\n    runSort(low, high, bucketsNum, bufferSize){\r\n    }\r\n}","import {Element} from \"../classes/Element\";\r\nexport function random(a, b) {\r\n    return Math.random() * (b - a) + a;\r\n}\r\n\r\nexport function randomInt(a, b) {\r\n    return Math.trunc(random(a, b))\r\n}\r\n\r\nexport function swapObj(json) {\r\n    let ret = {};\r\n    for (let key in json) {\r\n        ret[json[key]] = key;\r\n    }\r\n    return ret;\r\n}\r\n\r\nexport function sleep(ms) {\r\n    ms += new Date().getTime();\r\n    while (new Date() < ms) {\r\n    }\r\n}\r\n\r\nexport function getAllMethods(toCheck) {\r\n    const props = [];\r\n    let obj = toCheck;\r\n    do {\r\n        props.push(...Object.getOwnPropertyNames(obj));\r\n    } while (obj = Object.getPrototypeOf(obj));\r\n\r\n    return props.sort().filter((e, i, arr) => {\r\n        if (e!=arr[i+1] && typeof toCheck[e] == 'function') return true;\r\n    });\r\n}\r\n\r\nexport function deepArrayCopy(arr){\r\n    let out = [];\r\n    for(let i of arr){\r\n        let value = i.getValue();\r\n        let type = i.getType();\r\n        let color = i.getColor();\r\n        let markColor = i.getMarkColor();\r\n        out.push(new Element(value, type, color, markColor))\r\n    }\r\n    return out;\r\n}\r\n\r\nexport function arraysEquals(a, b){\r\n    return a.length === b.length &&\r\n    a.every((v, i) => v === b[i]);\r\n}\r\n\r\nexport function objLength(obj){\r\n    return (obj!==undefined) ? Object.keys(obj).length: 0\r\n}\r\n\r\nexport function HSL2RGB(h, s, l){\r\n    let r, g, b;\r\n\r\n    if(s === 0){\r\n        r = g = b = l;\r\n    }else{\r\n        let hue2rgb = function hue2rgb(p, q, t){\r\n            if(t < 0) t += 1;\r\n            if(t > 1) t -= 1;\r\n            if(t < 1/6) return p + (q - p) * 6 * t;\r\n            if(t < 1/2) return q;\r\n            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\r\n            return p;\r\n        }\r\n\r\n        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n        let p = 2 * l - q;\r\n        r = hue2rgb(p, q, h + 1/3);\r\n        g = hue2rgb(p, q, h);\r\n        b = hue2rgb(p, q, h - 1/3);\r\n    }\r\n\r\n    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\r\n}","// extracted by mini-css-extract-plugin\nmodule.exports = {\"textCenter\":\"Controls_textCenter__3_8jn\",\"controls\":\"Controls_controls__3X5vt\",\"showToggleBtn\":\"Controls_showToggleBtn__2CbSs\",\"slider\":\"Controls_slider__3IxWj\",\"sectionHeader\":\"Controls_sectionHeader__2EvBB\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"arrayContainer\":\"ArrayWindow_arrayContainer__jfaB8\",\"bar\":\"ArrayWindow_bar__30QYB\",\"dotContainer\":\"ArrayWindow_dotContainer__3porX\",\"dot\":\"ArrayWindow_dot__29TqH\"};","import {Sort} from \"./Sort\";\r\n\r\nexport class InsertionSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"InsertionSort\"\r\n    }\r\n\r\n    InsertionSort(low, high) {\r\n        let length = high+1;\r\n        for (let i = low+1; i < length; i++) {\r\n            let key = this.Reads.get(i);\r\n            let j = i - 1;\r\n            while (j >= 0 && this.Reads.compareValues(this.Reads.get(j), key) > 0) {\r\n                this.Writes.write(j + 1, this.Reads.get(j))\r\n                j = j - 1;\r\n            }\r\n            this.Writes.write(j + 1, key)\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.InsertionSort(low, high)\r\n    }\r\n}","const types = {\r\n\r\n}\r\n\r\nconst colors = {\r\n\r\n}\r\n\r\nexport class Element{\r\n\r\n    value;\r\n    type;\r\n    color;\r\n    markColor;\r\n\r\n    // constructor(args){\r\n    //     this.value = args.value;\r\n    //     this.type = args.type;\r\n    //     this.color = args.color || colors[args.type];\r\n    // }\r\n\r\n    constructor(value, type, color, markColor) {\r\n        this.value = value;\r\n        this.type = type;\r\n        this.color = color;\r\n        this.markColor = markColor;\r\n    }\r\n\r\n\r\n    getValue(){\r\n        return this.value;\r\n    }\r\n    setValue(value){\r\n        this.value = value;\r\n    }\r\n\r\n    getColor(){\r\n        return this.color;\r\n    }\r\n\r\n    setColor(color){\r\n        this.color = color;\r\n    }\r\n\r\n    getMarkColor(){\r\n        return this.markColor;\r\n    }\r\n    setMarkColor(markColor){\r\n        this.markColor = markColor;\r\n    }\r\n\r\n    getColorForRender(){\r\n        // if(this.type === \"Default\"){\r\n        //     return this.markColor\r\n        // }else{\r\n        //     return this.color\r\n        // }\r\n        if(this.type === \"Unmarked\"){\r\n            return this.color\r\n        }else {\r\n            return this.markColor\r\n        }\r\n    }\r\n\r\n    getType(){\r\n        return this.type;\r\n    }\r\n    setType(type){\r\n        this.type = type;\r\n    }\r\n\r\n    copy(unMark = true){\r\n        if(unMark){\r\n            return new Element(this.value, \"Unmarked\", this.color, [0,0,0])\r\n        }else{\r\n            return new Element(this.value, this.type, this.color, this.markColor)\r\n        }\r\n    }\r\n\r\n    toString(){\r\n        return this.value.toString()\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class HeapSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"HeapSort\"\r\n    }\r\n\r\n    siftDown(root, dist, start) {\r\n\r\n\r\n    while (root <= dist / 2) {\r\n        let leaf = 2 * root;\r\n        if (leaf < dist && this.Reads.compareInArr(start + leaf - 1, start + leaf) < 0) {\r\n        leaf++;\r\n    }\r\n\r\n    if (this.Reads.compareInArr(start + root - 1, start + leaf - 1) < 0) {\r\n        this.Writes.swap(start + root - 1, start + leaf - 1, );\r\n        root = leaf;\r\n    }\r\nelse break;\r\n}\r\n}\r\n\r\nheapify(low, high) {\r\n    let length = high - low;\r\n    for (let i = length / 2; i >= 1; i--) {\r\n        this.siftDown(i, length, low);\r\n    }\r\n}\r\n\r\n// This version of heap sort works for max and min variants, alongside sorting\r\n// partial ranges of an array.\r\nheapSort(start, length) {\r\n    this.heapify(start, length);\r\n\r\n    for (let i = length - start; i > 1; i--) {\r\n        this.Writes.swap(start, start + i - 1);\r\n        this.siftDown(1, i - 1, start);\r\n    }\r\n\r\n    // if(!isMax) {\r\n    //     this.Writes.reversal(arr, start, start + length - 1, 1, true, false);\r\n    // }\r\n}\r\n\r\n    runSort(low, high) {\r\n        this.heapSort(low, high+1)\r\n    }\r\n}","export class Delays {\r\n    arrayVisualizer\r\n    timeoutArray\r\n    delays\r\n    delayIncFactor\r\n    delayInc\r\n    DELAY_INC_CONST\r\n\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.timeoutArray = []\r\n        this.delays = {\r\n            Swap: 0,\r\n            Write: 0,\r\n            Comp: 0,\r\n            Unmark: 0,\r\n            CreateAuxArray: 0,\r\n            RemoveAuxArray: 0,\r\n            Other: 0\r\n        }\r\n        this.DELAY_INC_CONST = 3000\r\n        this.updateDelayInc()\r\n        // this.delayIncFactor = this.DELAY_INC_CONST-arrayVisualizer.getArrLength()*3\r\n        // this.delayInc = this.delayIncFactor/arrayVisualizer.getArrLength()\r\n    }\r\n\r\n    updateDelayInc(){\r\n        this.delayIncFactor = this.DELAY_INC_CONST\r\n        this.delayInc = this.delayIncFactor/this.arrayVisualizer.getArrLength()\r\n    }\r\n\r\n    push(timeout){\r\n        this.timeoutArray.push(timeout)\r\n    }\r\n\r\n    pushFunc(func, obj, delayName, delay, args) {\r\n        this.timeoutArray.push(setTimeout(func.bind(obj), this.delays[delayName] += delay, args))\r\n    }\r\n\r\n    resetDelays() {\r\n        this.delays = {\r\n            Swap: 0,\r\n            Write: 0,\r\n            Comp: 0,\r\n            Unmark: 0,\r\n            CreateAuxArray: 0,\r\n            RemoveAuxArray: 0,\r\n            Other: 0\r\n        }\r\n        for (let i of this.timeoutArray) {\r\n            clearTimeout(i);\r\n        }\r\n        this.timeoutArray = []\r\n    }\r\n\r\n    setDelay(name, value){\r\n        this.delays[name] = value\r\n    }\r\n\r\n    incDelay(name, inc=this.delayInc){\r\n        return this.delays[name]+=inc\r\n    }\r\n\r\n    getDelayInc(){\r\n        return this.delayInc\r\n    }\r\n\r\n    getDelays(){\r\n        return this.delays\r\n    }\r\n}","\r\nimport {objLength} from \"../utils/utils\";\r\n\r\nexport class Writes{\r\n    arrayVisualizer;\r\n    Sounds\r\n    Delays\r\n    Marks\r\n\r\n    constructor(arrayVisualizer){\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.Sounds = arrayVisualizer.getSounds()\r\n        this.Delays = arrayVisualizer.getDelays()\r\n        this.Marks = arrayVisualizer.getMarks()\r\n    }\r\n\r\n\r\n\r\n    swapWithDelay(a, b, arr = this.arrayVisualizer.getPseudoArray(), mark, delay = this.Delays.getDelayInc(), playSound) {\r\n        // this.Delays.push(setTimeout(this.swapInArr.bind(this), this.Delays.incDelay(\"Write\", delay), a, b, arr, mark, playSound))\r\n        this.Delays.push(setTimeout(()=>{\r\n            this.swapInArr(a, b, arr, mark, playSound)\r\n            let curWrites = this.arrayVisualizer.getState().mainWrites + 2;\r\n            this.arrayVisualizer.setState({\r\n                mainWrites: curWrites\r\n            })\r\n        }, this.Delays.incDelay(\"Write\", delay)))\r\n    }\r\n\r\n\r\n    swapInArr(a, b, arr = this.arrayVisualizer.getPseudoArray(), mark = true, playSound = false) {\r\n        if(playSound) {\r\n            this.Sounds.playSound(arr[b].getValue());\r\n        }\r\n        let tmpArr = arr\r\n        // let tmp = tmpArr[a]\r\n        // tmpArr[a] = tmpArr[b]\r\n        // tmpArr[b] = tmp\r\n        let tmp = tmpArr[a]\r\n        tmpArr[a] = tmpArr[b].copy(true)\r\n        tmpArr[b] = tmp.copy(true)\r\n        if (mark) {\r\n            this.Marks.markUnmarkMany([a, b], {type: \"Default\"})\r\n        }\r\n        // let curWrites = this.arrayVisualizer.getState().writes + 2;\r\n        // this.arrayVisualizer.setState({\r\n        //     writes: curWrites\r\n        // })\r\n    }\r\n\r\n    swap(a, b, arr = this.arrayVisualizer.getPseudoArray()) {\r\n        this.swapInArr(a, b, arr, false, false)\r\n        this.swapWithDelay(a, b, this.arrayVisualizer.getMainArray(), true, this.Delays.getDelayInc(), true)\r\n    }\r\n\r\n    // writeInArr(index, value, arr = this.arrayVisualizer.getPseudoArray(), mark = true, playSound = false) {\r\n    //     if(playSound) {\r\n    //         this.Sounds.playSound(value)\r\n    //     }\r\n    //     arr[index].setValue(value)\r\n    //     if (mark) {\r\n    //         this.Marks.markUnmarkMany([index], {type: \"Default\"})\r\n    //     }\r\n    //     let curWrites = this.arrayVisualizer.getState().writes;\r\n    //     this.arrayVisualizer.setState({\r\n    //         writes: curWrites + 1\r\n    //     })\r\n    // }\r\n\r\n\r\n    writeInArr(index, toWrite, arr = this.arrayVisualizer.getPseudoArray(), mark = true, playSound = false) {\r\n        if(playSound) {\r\n            this.Sounds.playSound(toWrite.getValue())\r\n        }\r\n        arr[index] = toWrite.copy(true)\r\n        if (mark) {\r\n            this.Marks.markUnmarkMany([index], {type: \"Default\"})\r\n        }\r\n        // let curWrites = this.arrayVisualizer.getState().mainWrites + 1;\r\n        // this.arrayVisualizer.setState({\r\n        //     mainWrites: curWrites\r\n        // })\r\n    }\r\n\r\n    writeWithDelay(index, toWrite, arr = this.arrayVisualizer.getPseudoArray(), mark, delay = this.Delays.getDelayInc(), playSound = true) {\r\n        // this.Delays.push(setTimeout(this.writeInArr.bind(this), this.Delays.incDelay(\"Write\", delay), index, toWrite, arr, mark, playSound))\r\n        this.Delays.push(setTimeout(()=>{\r\n            this.writeInArr(index, toWrite, arr, mark, playSound)\r\n            let curWrites = this.arrayVisualizer.getState().mainWrites + 1;\r\n            this.arrayVisualizer.setState({\r\n                mainWrites: curWrites\r\n            })\r\n        }, this.Delays.incDelay(\"Write\", delay)))\r\n    }\r\n\r\n    write(index, toWrite, arr = this.arrayVisualizer.getPseudoArray()) {\r\n        this.writeInArr(index, toWrite, arr, false, false)\r\n        this.writeWithDelay(index, toWrite, this.arrayVisualizer.getMainArray(), true, this.Delays.getDelayInc(), true)\r\n    }\r\n\r\n    createAuxArray(len, isPseudo = true){\r\n        if(isPseudo) {\r\n            let pseudoAuxArrays = this.arrayVisualizer.getPseudoAuxArrays()\r\n            let auxArrIndex = objLength(pseudoAuxArrays)\r\n            pseudoAuxArrays[auxArrIndex]=(this.arrayVisualizer.initArray(() => -1, len, false))\r\n            this.createAuxArrayWithDelay(len, this.Delays.getDelayInc(), false)\r\n            return auxArrIndex\r\n        }else{\r\n            let tmpArr = this.arrayVisualizer.getAuxArrays()\r\n            let auxArrIndex = objLength(tmpArr)\r\n\r\n            tmpArr[auxArrIndex]=(this.arrayVisualizer.initArray(() => -1, len, false))\r\n            this.arrayVisualizer.setState({\r\n                    auxArrays: tmpArr\r\n                }\r\n            )\r\n        }\r\n    }\r\n\r\n    createAuxArrayWithDelay(len, delay, isPseudo = false){\r\n        this.Delays.push(setTimeout(this.createAuxArray.bind(this), this.Delays.incDelay(\"Write\", delay), len, isPseudo))\r\n    }\r\n\r\n    removeAuxArray(index, isPseudo = true){\r\n        if(isPseudo) {\r\n            // this.arrayVisualizer.getPseudoAuxArrays().splice(index, 1)\r\n            delete this.arrayVisualizer.getPseudoAuxArrays()[index]\r\n            this.removeAuxArrayWithDelay(index, this.Delays.getDelayInc(), false)\r\n        }else{\r\n            let tmp = this.arrayVisualizer.getAuxArrays()\r\n            // tmp.splice(index, 1)\r\n            delete tmp[index]\r\n            this.arrayVisualizer.setState({\r\n                auxArrays: tmp\r\n            })\r\n        }\r\n    }\r\n\r\n    removeAuxArrayWithDelay(index, delay, isPseudo = false){\r\n        this.Delays.push(setTimeout(this.removeAuxArray.bind(this), this.Delays.incDelay(\"Write\", delay), index, isPseudo))\r\n    }\r\n\r\n\r\n    auxWrite(index, toWrite, arrIndex, isPseudo = true, playSound = false){\r\n        if(playSound){\r\n            this.Sounds.playSound(toWrite.getValue())\r\n        }\r\n        if(isPseudo){\r\n            this.arrayVisualizer.getPseudoAuxArrays()[arrIndex][index] = toWrite.copy()\r\n            this.auxWriteWithDelay(index, toWrite, arrIndex, this.Delays.getDelayInc(), false, true)\r\n        }else{\r\n            this.arrayVisualizer.getAuxArrays()[arrIndex][index] = toWrite.copy()\r\n            let tmp = this.arrayVisualizer.getAuxArrays()\r\n            let curWrites = this.arrayVisualizer.getState().auxWrites + 1;\r\n            this.arrayVisualizer.setState({\r\n                auxWrites: curWrites\r\n            })\r\n            this.arrayVisualizer.setState({\r\n                auxArrays: tmp\r\n            })\r\n        }\r\n    }\r\n\r\n    auxWriteWithDelay(index, value, arrIndex, delay, isPseudo = false, playSound = true, ){\r\n        this.Delays.push(setTimeout(this.auxWrite.bind(this), this.Delays.incDelay(\"Write\", delay), index, value, arrIndex, isPseudo, playSound))\r\n    }\r\n\r\n}","import {Delays} from \"../ArrayAccess/Delays\";\r\n\r\nexport class Sorts {\r\n    arrayVisualizer;\r\n    sortsPaths\r\n    Delays\r\n    Sounds\r\n    Marks\r\n\r\n\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n\r\n        this.Delays = arrayVisualizer.getDelays()\r\n        this.Sounds = arrayVisualizer.getSounds()\r\n        this.Marks = arrayVisualizer.getMarks()\r\n\r\n        this.sortsPaths = [\"BubbleSort\", \"MergeSort\", \"LLQuickSort\", \"LRQuickSort\", \"HeapSort\",\r\n            \"DualPivotQuickSort\", \"InsertionSort\", \"SelectionSort\", \"GnomeSort\", \"TimSort\", \"PseudoTimSort\",\r\n            \"IntroSort\", \"LSDRadixSort\", \"BitonicSort\", \"SlowSort\", \"StoogeSort\", \"GrailSort\"]\r\n\r\n    }\r\n\r\n    getSortsPaths() {\r\n        return this.sortsPaths;\r\n    }\r\n\r\n    getSortObject(sortPath) {\r\n        let Sort = require(\"./\" + sortPath + \".js\")[sortPath]\r\n        return new Sort(this.arrayVisualizer)\r\n    }\r\n\r\n    runSort(sortName, low, high) {\r\n        this.arrayVisualizer.getDelays().resetDelays()\r\n        this.arrayVisualizer.nullify()\r\n        let sort = this.getSortObject(sortName)\r\n        let warnLen = sort.getWarnLen()\r\n        let bucketsNum = 4\r\n        if (sort.isNeedBucketsNum) {\r\n            bucketsNum = parseInt(prompt(\"Enter the buckets num:\", \"4\"))\r\n            if (isNaN(bucketsNum)) {\r\n                return;\r\n            }\r\n            if (bucketsNum < 2){\r\n                alert(\"WARNING!!!\\nUncorrected buckets num was entered!\\nThe buckets num will be set to 2\")\r\n            }\r\n        }\r\n        bucketsNum = Math.max(2, bucketsNum)\r\n\r\n        if (warnLen !== -1 && this.arrayVisualizer.getArrLength() > warnLen &&\r\n            !window.confirm(\"WARNING!!!\\nThe array size(\" + this.arrayVisualizer.getArrLength() + \") \" +\r\n                \"more than recommended(\" + warnLen + \")\\nApplication may freeze\\nDo you want continue?\")) {\r\n            return\r\n\r\n        }\r\n\r\n        let bufferSize = 0\r\n        if (sort.isNeedBuffer) {\r\n            bufferSize = parseInt(prompt(\"Enter the buffer size:\", \"0\"))\r\n            if (isNaN(bufferSize)) {\r\n                return;\r\n            }\r\n        }\r\n        bufferSize = Math.max(0, bufferSize)\r\n\r\n        this.arrayVisualizer.initPseudoArray()\r\n        this.arrayVisualizer.setSortName(sort.getSortName())\r\n        this.arrayVisualizer.backupArray()\r\n        sort.runSort(low, high, bucketsNum, bufferSize)\r\n        // this.arrayVisualizer.sortClickEvent()\r\n        // console.log(this.Delays.getDelays().Write)\r\n        this.Delays.push(setTimeout(() => (this.checkSort()), this.Delays.getDelays().Write + this.Delays.getDelayInc() * 5))\r\n    }\r\n\r\n    checkSort() {\r\n        let isSorted = true\r\n        let array = this.arrayVisualizer.getMainArray()\r\n        for (let i = 1; i < array.length; ++i) {\r\n            if (array[i - 1].getValue() > array[i].getValue()) {\r\n                isSorted = false\r\n                break;\r\n            }\r\n        }\r\n        for (let i = 0; i < array.length; ++i) {\r\n            this.Delays.push(setTimeout(() => {\r\n                if (isSorted) {\r\n                    this.Sounds.playSound(array[i].getValue())\r\n                    this.Marks.mark(i, {type: \"Sorted\", color: [0, 255, 0]}, true)\r\n                } else {\r\n                    this.Marks.mark(i, {type: \"Default\", color: [255, 0, 0]}, true)\r\n                }\r\n            }, this.Delays.incDelay(\"Other\", this.Delays.getDelayInc() / 3)))\r\n        }\r\n        this.Delays.push(setTimeout(() => {\r\n            this.Marks.clearAllMarks()\r\n            this.Delays.resetDelays()\r\n            this.arrayVisualizer.forceMainArrayUpdate()\r\n        }, (this.Delays.getDelayInc()) * (array.length) / 3))\r\n\r\n    }\r\n}","// extracted by mini-css-extract-plugin\nmodule.exports = {\"statsContainer\":\"Stats_statsContainer__1qOnq\"};","var map = {\n\t\"./BitonicSort.js\": 31,\n\t\"./BubbleSort.js\": 32,\n\t\"./DualPivotQuickSort.js\": 33,\n\t\"./GnomeSort.js\": 34,\n\t\"./GrailSort.js\": 35,\n\t\"./HeapSort.js\": 14,\n\t\"./InsertionSort.js\": 12,\n\t\"./IntroSort.js\": 36,\n\t\"./LLQuickSort.js\": 37,\n\t\"./LRQuickSort.js\": 38,\n\t\"./LSDRadixSort.js\": 39,\n\t\"./MergeSort.js\": 40,\n\t\"./PseudoTimSort.js\": 41,\n\t\"./SelectionSort.js\": 42,\n\t\"./SlowSort.js\": 43,\n\t\"./Sort.js\": 5,\n\t\"./Sorts.js\": 20,\n\t\"./StoogeSort.js\": 44,\n\t\"./TimSort.js\": 45\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 30;","import {Sort} from \"./Sort\";\r\n\r\nexport class BitonicSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"BitonicSort\"\r\n    }\r\n    // kernel(p, q) {\r\n    //     const d = 1 << (p - q);\r\n    //\r\n    //     for (let i = 0; i < this.arrLength; i++) {\r\n    //         const up = ((i >> p) & 2) === 0;\r\n    //         // if ((i & d) === 0 && (x[i] > x[i | d]) === up) {\r\n    //         if ((i & d) === 0 && ((this.Reads.compare(i, i | d, \">\")) === up)) {\r\n    //             // const tmp = x[i];\r\n    //             // x[i] = x[i | d];\r\n    //             // x[i | d] = tmp;\r\n    //             this.Writes.swap(i, i | d)\r\n    //         }\r\n    //     }\r\n    // }\r\n    //\r\n    // bitonicSort(n) {\r\n    //     for (let i = 0; i < n; i++) {\r\n    //         for(let j = 0; j <= i; j++) {\r\n    //             this.kernel(i, j);\r\n    //         }\r\n    //     }\r\n    // }\r\n    bitonicSort(sortLength){\r\n        let i, j, k;\r\n\r\n        for(k = 2; k < sortLength*2; k = 2 * k) {\r\n            let m = (Math.trunc((sortLength + (k - 1)) / k) % 2) !== 0;\r\n\r\n            for(j = k >> 1; j > 0; j = j >> 1) {\r\n                for(i = 0; i < sortLength; i++) {\r\n                    let ij = i ^ j;\r\n\r\n                    if((ij) > i && ij < sortLength) {\r\n                        if((((i & k) === 0) === m) && this.Reads.compareInArr(i, ij) > 0)\r\n                            this.Writes.swap(i, ij);\r\n                        if((((i & k) !== 0) === m) && this.Reads.compareInArr(i, ij) < 0)\r\n                            this.Writes.swap(i, ij);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    runSort(low, high, bucketsNum) {\r\n        // this.bitonicSort(Math.trunc(Math.log2(high-1)))\r\n        this.bitonicSort(high+1)\r\n    }\r\n\r\n}\r\n","import {Sort} from \"./Sort\";\r\n\r\nexport class BubbleSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"BubbleSort\"\r\n    }\r\n    BubbleSort() {\r\n        let len = this.arrLength;\r\n        for (let i = 0; i < len; i++) {\r\n            for (let j = 0; j < len - i - 1; j++) {\r\n                if (this.Reads.compareInArr(j, j + 1) > 0) {\r\n                    this.Writes.swap(j, j + 1)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.BubbleSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\nimport {InsertionSort} from \"./InsertionSort\";\r\n\r\nexport class DualPivotQuickSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"Dual Pivot QuickSort\"\r\n    }\r\n\r\n    dualPivot(left, right, divisor) {\r\n        let length = right - left;\r\n\r\n        // insertion sort for tiny array\r\n        if (length < 4) {\r\n            let insertSorter = new InsertionSort(this.arrayVisualizer)\r\n            insertSorter.runSort(left, right)\r\n            return;\r\n        }\r\n        // if(length === 1){\r\n        //     return\r\n        // }\r\n\r\n        let third = Math.trunc(length / divisor);\r\n\r\n// \"medians\"\r\n        let med1 = left + third;\r\n        let med2 = right - third;\r\n\r\n        if (med1 <= left) {\r\n            med1 = left + 1;\r\n        }\r\n        if (med2 >= right) {\r\n            med2 = right - 1;\r\n        }\r\n\r\n\r\n        // if(Reads.compareValues(array[med1], array[med2]) == -1) {\r\n        if (this.Reads.compareInArr(med1, med2) < 0) {\r\n            this.Writes.swap(med1, left);\r\n            this.Writes.swap(med2, right);\r\n        } else {\r\n            this.Writes.swap(med1, right);\r\n            this.Writes.swap(med2, left);\r\n        }\r\n\r\n// pivots\r\n        let pivot1 = this.Reads.readValue(left);\r\n        let pivot2 = this.Reads.readValue(right);\r\n\r\n// pointers\r\n        let less = left + 1;\r\n        let great = right - 1;\r\n\r\n// sorting\r\n        for (let k = less; k <= great; k++) {\r\n\r\n            // if (this.Reads.read(k) < pivot1) {\r\n            if (this.Reads.compareValues(this.Reads.get(k), pivot1) < 0) {\r\n\r\n                this.Writes.swap(k, less++);\r\n            // } else if (this.Reads.read(k) > pivot2) {\r\n            } else if (this.Reads.compareValues(this.Reads.get(k), pivot2) > 0) {\r\n                // while (k < great && this.Reads.read(great) > pivot2) {\r\n                while (k < great && this.Reads.compareValues(this.Reads.get(great), pivot2) > 0) {\r\n                    great--;\r\n                }\r\n                this.Writes.swap(k, great--);\r\n\r\n                // if (this.Reads.read(k) < pivot1) {\r\n                if (this.Reads.compareValues(this.Reads.get(k), pivot1) < 0) {\r\n                    this.Writes.swap(k, less++);\r\n                }\r\n            }\r\n        }\r\n\r\n// swaps\r\n        let dist = great - less;\r\n\r\n        if (dist < 13) {\r\n            divisor++;\r\n        }\r\n        this.Writes.swap(less - 1, left);\r\n        this.Writes.swap(great + 1, right);\r\n\r\n// subarrays\r\n        this.dualPivot(left, less - 2, divisor);\r\n        if (pivot1 < pivot2) {\r\n            this.dualPivot(less, great, divisor);\r\n        }\r\n        this.dualPivot(great + 2, right, divisor);\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.dualPivot(low, high, 3)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\nimport {Writes} from \"../ArrayAccess/Writes\";\r\n\r\nexport class GnomeSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"GnomeSort\"\r\n    }\r\n\r\n    GnomeSort() {\r\n        let len = this.arrLength;\r\n        for (let i = 1; i < len;) {\r\n            if (this.Reads.compareInArr(i, i - 1) >= 0) {\r\n                i++\r\n            } else {\r\n                this.Writes.swap(i, i - 1)\r\n                if (i > 1) {\r\n                    i--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.GnomeSort(low, high)\r\n    }\r\n}","/*\r\n * MIT License\r\n * \r\n * Copyright (c) 2013 Andrey Astrelin\r\n * Copyright (c) 2020 The Holy Grail Sort Project\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n/*\r\n * The Holy Grail Sort Project\r\n * Project Manager:      Summer Dragonfly\r\n * Project Contributors: 666666t\r\n *                       Anonymous0726\r\n *                       aphitorite\r\n *                       dani_dlg\r\n *                       EilrahcF\r\n *                       Enver\r\n *                       lovebuny\r\n *                       MP\r\n *                       phoenixbound\r\n *                       thatsOven\r\n *                       \r\n * Special thanks to \"The Studio\" Discord community!\r\n */\r\n\r\n// Credit to phoenixbound for this clever idea\r\n\r\nimport {Sort} from \"./Sort\";\r\n\r\nconst Subarray = {\r\n    LEFT: 1,\r\n    RIGHT: 2,\r\n};\r\n\r\n// REWRITTEN GRAILSORT FOR JAVASCRIPT - A heavily refactored C/C++-to-JavaScript version of\r\n//                                      Andrey Astrelin's GrailSort.h, aiming to be as\r\n//                                      readable and intuitive as possible.\r\n//\r\n// ** Written and maintained by The Holy Grail Sort Project\r\n//\r\n// Primary author: Enver\r\n//\r\n// Current status: Finished. Potentially 100% working... Passing most tests, some tests capped by V8 Engine memory allocation limits\r\n\r\nexport class GrailSort extends Sort {\r\n    // static GRAIL_STATIC_EXT_BUF_LEN = 512;\r\n\r\n    externalBuffer\r\n    externalBufferLen\r\n\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"GrailSort\"\r\n        this.isNeedBuffer = true;\r\n    }\r\n\r\n    grailSwap(a, b) {\r\n        // let temp = array[a];\r\n        // array[a] = array[b];\r\n        // array[b] = temp;\r\n        this.Writes.swap(a, b)\r\n    }\r\n\r\n    grailBlockSwap(a, b, blockLen) {\r\n        for (let i = 0; i < blockLen; i++) {\r\n            this.grailSwap(a + i, b + i);\r\n        }\r\n    }\r\n\r\n    // Object src, int srcPos, Object dest, int destPos, int length\r\n    // Custom method for copying parts of the array either:\r\n    //      within itself to a different destination, or\r\n    //      to another array\r\n    arraycopy(srcArray, srcPos, destArray, destPos, copyLen) {\r\n\r\n        if (srcArray === -1 && destArray === -1) {\r\n            for (let i = 0; i < copyLen; i++) {\r\n                this.Writes.write(destPos + i, this.Reads.get(srcPos + i))\r\n            }\r\n        } else if (srcArray !== -1 && destArray !== -1) {\r\n            for (let i = 0; i < copyLen; i++) {\r\n                this.Writes.auxWrite(destPos + i, this.Reads.auxGet(srcPos + i, srcArray), destArray)\r\n            }\r\n        } else if (srcArray === -1 && destArray !== -1) {\r\n            for (let i = 0; i < copyLen; i++) {\r\n                this.Writes.auxWrite(destPos + i, this.Reads.get(srcPos + i), destArray)\r\n            }\r\n        } else if (srcArray !== -1 && destArray === -1) {\r\n            for (let i = 0; i < copyLen; i++) {\r\n                this.Writes.write(destPos + i, this.Reads.auxGet(srcPos + i, srcArray))\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    grailRotate(start, leftLen, rightLen) {\r\n        while (leftLen > 0 && rightLen > 0) {\r\n            if (leftLen <= rightLen) {\r\n                this.grailBlockSwap(start, start + leftLen, leftLen);\r\n                start += leftLen;\r\n                rightLen -= leftLen;\r\n            } else {\r\n                this.grailBlockSwap(start + leftLen - rightLen, start + leftLen, rightLen);\r\n                leftLen -= rightLen;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Variant of Insertion Sort that utilizes swaps instead of overwrites.\r\n    // Also known as \"Optimized Gnomesort\".\r\n    grailInsertSort(start, length) {\r\n        for (let item = 1; item < length; item++) {\r\n            let left = start + item - 1;\r\n            let right = start + item;\r\n\r\n            while (left >= start && this.Reads.compareInArr(left,\r\n                right) > 0) {\r\n                this.grailSwap(left, right);\r\n                left--;\r\n                right--;\r\n            }\r\n        }\r\n    }\r\n\r\n    grailBinarySearchLeft(start, length, target) {\r\n        let left = 0;\r\n        let right = length;\r\n        while (left < right) {\r\n            let middle = left + parseInt((right - left) / 2);\r\n            if (this.Reads.compareValues(this.Reads.readValue(start + middle), target) < 0) {\r\n                left = middle + 1;\r\n            } else {\r\n                right = middle;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n\r\n    // Credit to Anonymous0726 for debugging\r\n    grailBinarySearchRight(start, length, target) {\r\n        let left = 0;\r\n        let right = length;\r\n        while (left < right) {\r\n            let middle = left + parseInt((right - left) / 2);\r\n            if (this.Reads.compareValues(this.Reads.readValue(start + middle), target) > 0) {\r\n                right = middle;\r\n            } else {\r\n                left = middle + 1;\r\n            }\r\n        }\r\n        // OFF-BY-ONE BUG FIXED: used to be `return right - 1;`\r\n        return right;\r\n    }\r\n\r\n    // cost: 2 * length + idealKeys^2 / 2\r\n    grailCollectKeys(start, length, idealKeys) {\r\n        let keysFound = 1; // by itself, the first item in the array is our first unique key\r\n        let firstKey = 0; // the first item in the array is at the first position in the array\r\n        let currentKey = 1; // the index used for finding potentially unique items (\"keys\") in the array\r\n\r\n        while (currentKey < length && keysFound < idealKeys) {\r\n\r\n            // Find the location in the key-buffer where our current key can be inserted in sorted order.\r\n            // If the key at insertPos is equal to currentKey, then currentKey isn't unique and we move on.\r\n            let insertPos = this.grailBinarySearchLeft(start + firstKey, keysFound, this.Reads.readValue(start + currentKey));\r\n\r\n            // The second part of this conditional does the equal check we were just talking about; however,\r\n            // if currentKey is larger than everything in the key-buffer (meaning insertPos == keysFound),\r\n            // then that also tells us it wasn't *equal* to anything in the key-buffer. Magic! :) \r\n            if (insertPos == keysFound || this.Reads.compareInArr(start + currentKey,\r\n                start + firstKey + insertPos) != 0) {\r\n\r\n                // First, rotate the key-buffer over to currentKey's immediate left...\r\n                // (this helps save a TON of swaps/writes!!!)\r\n                this.grailRotate(start + firstKey, keysFound, currentKey - (firstKey + keysFound));\r\n\r\n                // Update the new position of firstKey...\r\n                firstKey = currentKey - keysFound;\r\n\r\n                // Then, \"insertion sort\" currentKey to its spot in the key-buffer!\r\n                this.grailRotate(start + firstKey + insertPos, keysFound - insertPos, 1);\r\n\r\n                // One step closer to idealKeys.\r\n                keysFound++;\r\n            }\r\n            // Move on and test the next key...\r\n            currentKey++;\r\n        }\r\n\r\n        // Bring however many keys we found back to the beginning of our array,\r\n        // and return the number of keys collected.\r\n        this.grailRotate(start, firstKey, keysFound);\r\n        return keysFound;\r\n    }\r\n\r\n    grailPairwiseSwaps(start, length) {\r\n        let index;\r\n        for (index = 1; index < length; index += 2) {\r\n            let left = start + index - 1;\r\n            let right = start + index;\r\n\r\n            if (this.Reads.compareInArr(left, right) > 0) {\r\n                this.grailSwap(left - 2, right);\r\n                this.grailSwap(right - 2, left);\r\n            } else {\r\n                this.grailSwap(left - 2, left);\r\n                this.grailSwap(right - 2, right);\r\n            }\r\n        }\r\n\r\n        let left = start + index - 1;\r\n        if (left < start + length) {\r\n            this.grailSwap(left - 2, left);\r\n        }\r\n    }\r\n\r\n    grailPairwiseWrites(start, length) {\r\n        let index;\r\n        for (index = 1; index < length; index += 2) {\r\n            let left = start + index - 1;\r\n            let right = start + index;\r\n\r\n            if (this.Reads.compareInArr(left, right) > 0) {\r\n                this.Writes.write(left - 2, this.Reads.get(right))\r\n                this.Writes.write(right - 2, this.Reads.get(left))\r\n            } else {\r\n                this.Writes.write(left - 2, this.Reads.get(left))\r\n                this.Writes.write(right - 2, this.Reads.get(right))\r\n            }\r\n        }\r\n\r\n        let left = start + index - 1;\r\n        if (left < start + length) {\r\n            this.Writes.write(left - 2, this.Reads.get(left))\r\n        }\r\n    }\r\n\r\n    // array[buffer .. start - 1] <=> \"scrolling buffer\"\r\n    // \r\n    // \"scrolling buffer\" + array[start, middle - 1] + array[middle, end - 1]\r\n    // --> array[buffer, buffer + end - 1] + \"scrolling buffer\"\r\n    grailMergeForwards(start, leftLen, rightLen, bufferOffset) {\r\n        let left = start;\r\n        let middle = start + leftLen;\r\n        let right = middle;\r\n        let end = middle + rightLen;\r\n        let buffer = start - bufferOffset;\r\n\r\n        while (right < end) {\r\n            if (left == middle || this.Reads.compareInArr(left,\r\n                right) > 0) {\r\n\r\n                this.grailSwap(buffer, right);\r\n                right++;\r\n            } else {\r\n                this.grailSwap(buffer, left);\r\n                left++;\r\n            }\r\n            buffer++;\r\n        }\r\n\r\n        if (buffer != left) {\r\n            this.grailBlockSwap(buffer, left, middle - left);\r\n        }\r\n    }\r\n\r\n    // credit to 666666t for thorough bug-checking/fixing\r\n    grailMergeBackwards(start, leftLen, rightLen, bufferOffset) {\r\n        let left = start + leftLen - 1;\r\n        let middle = left;\r\n        // OFF-BY-ONE BUG FIXED: used to be `let  right = middle + rightLen - 1;`\r\n        let right = middle + rightLen;\r\n        let end = start;\r\n        // OFF-BY-ONE BUG FIXED: used to be `let buffer = right  + bufferOffset - 1;`\r\n        let buffer = right + bufferOffset;\r\n\r\n        while (left >= end) {\r\n            if (right == middle || this.Reads.compareInArr(left,\r\n                right) > 0) {\r\n\r\n                this.grailSwap(buffer, left);\r\n                left--;\r\n            } else {\r\n                this.grailSwap(buffer, right);\r\n                right--;\r\n            }\r\n            buffer--;\r\n        }\r\n\r\n        if (right != buffer) {\r\n            while (right > middle) {\r\n                this.grailSwap(buffer, right);\r\n                buffer--;\r\n                right--;\r\n            }\r\n        }\r\n    }\r\n\r\n    // array[buffer .. start - 1] <=> \"free space\"    \r\n    //\r\n    // \"free space\" + array[start, middle - 1] + array[middle, end - 1]\r\n    // --> array[buffer, buffer + end - 1] + \"free space\"\r\n    //\r\n    // FUNCTION RENAMED: More consistent with \"out-of-place\" being at the end\r\n    grailMergeOutOfPlace(start, leftLen, rightLen, bufferOffset) {\r\n        let left = start;\r\n        let middle = start + leftLen;\r\n        let right = middle;\r\n        let end = middle + rightLen;\r\n        let buffer = start - bufferOffset;\r\n\r\n        while (right < end) {\r\n            if (left == middle || this.Reads.compareInArr(left,\r\n                right) > 0) {\r\n\r\n                this.Writes.write(buffer, this.Reads.get(right))\r\n                right++;\r\n            } else {\r\n                this.Writes.write(buffer, this.Reads.get(left))\r\n                left++;\r\n            }\r\n            buffer++;\r\n        }\r\n\r\n        if (buffer != left) {\r\n            while (left < middle) {\r\n                this.Writes.write(buffer, this.Reads.get(left))\r\n                buffer++;\r\n                left++;\r\n            }\r\n        }\r\n    }\r\n\r\n    grailBuildInPlace(start, length, currentMerge, bufferLen) {\r\n        for (let mergeLen = currentMerge; mergeLen < bufferLen; mergeLen *= 2) {\r\n            let mergeIndex;\r\n            let mergeEnd = start + length - (2 * mergeLen);\r\n            let bufferOffset = mergeLen;\r\n\r\n            for (mergeIndex = start; mergeIndex <= mergeEnd; mergeIndex += (2 * mergeLen)) {\r\n                this.grailMergeForwards(mergeIndex, mergeLen, mergeLen, bufferOffset);\r\n            }\r\n\r\n            let leftOver = length - (mergeIndex - start);\r\n\r\n            if (leftOver > mergeLen) {\r\n                this.grailMergeForwards(mergeIndex, mergeLen, leftOver - mergeLen, bufferOffset);\r\n            } else {\r\n                this.grailRotate(mergeIndex - mergeLen, mergeLen, leftOver);\r\n            }\r\n\r\n            start -= mergeLen;\r\n        }\r\n\r\n        let finalBlock = length % (2 * bufferLen);\r\n        let finalOffset = start + length - finalBlock;\r\n\r\n        if (finalBlock <= bufferLen) {\r\n            this.grailRotate(finalOffset, finalBlock, bufferLen);\r\n        } else {\r\n            this.grailMergeBackwards(finalOffset, bufferLen, finalBlock - bufferLen, bufferLen);\r\n        }\r\n\r\n        for (let mergeIndex = finalOffset - (2 * bufferLen); mergeIndex >= start; mergeIndex -= (2 * bufferLen)) {\r\n            this.grailMergeBackwards(mergeIndex, bufferLen, bufferLen, bufferLen);\r\n        }\r\n    }\r\n\r\n    grailBuildOutOfPlace(start, length, bufferLen, externLen) {\r\n        this.arraycopy(-1, start - externLen, this.externalBuffer, 0, externLen);\r\n\r\n        this.grailPairwiseWrites(start, length);\r\n        start -= 2;\r\n\r\n        let mergeLen;\r\n        for (mergeLen = 2; mergeLen < externLen; mergeLen *= 2) {\r\n            let mergeIndex;\r\n            let mergeEnd = start + length - (2 * mergeLen);\r\n            let bufferOffset = mergeLen;\r\n\r\n            for (mergeIndex = start; mergeIndex <= mergeEnd; mergeIndex += (2 * mergeLen)) {\r\n                this.grailMergeOutOfPlace(mergeIndex, mergeLen, mergeLen, bufferOffset);\r\n            }\r\n\r\n            let leftOver = length - (mergeIndex - start);\r\n\r\n            if (leftOver > mergeLen) {\r\n                this.grailMergeOutOfPlace(mergeIndex, mergeLen, leftOver - mergeLen, bufferOffset);\r\n            } else {\r\n                // TODO: Is this correct??\r\n                for (let offset = 0; offset < leftOver; offset++) {\r\n                    // array[mergeIndex + offset - mergeLen] = array[mergeIndex + offset];\r\n                    this.Writes.write(mergeIndex + offset - mergeLen, this.Reads.get(mergeIndex + offset))\r\n                }\r\n            }\r\n\r\n            start -= mergeLen;\r\n        }\r\n\r\n        this.arraycopy(this.externalBuffer, 0, -1, start + length, externLen);\r\n        this.grailBuildInPlace(start, length, mergeLen, bufferLen);\r\n    }\r\n\r\n    // build blocks of length 'bufferLen'\r\n    // input: [start - mergeLen, start - 1] elements are buffer\r\n    // output: first 'bufferLen' elements are buffer, blocks (2 * bufferLen) and last subblock sorted\r\n    grailBuildBlocks(start, length, bufferLen) {\r\n        if (this.externalBuffer != null) {\r\n            let externLen;\r\n\r\n            if (bufferLen < this.externalBufferLen) {\r\n                externLen = bufferLen;\r\n            } else {\r\n                // max power of 2 -- just in case\r\n                externLen = 1;\r\n                while ((externLen * 2) <= this.externalBufferLen) {\r\n                    externLen *= 2;\r\n                }\r\n            }\r\n\r\n            this.grailBuildOutOfPlace(start, length, bufferLen, externLen);\r\n        } else {\r\n            this.grailPairwiseSwaps(start, length);\r\n            this.grailBuildInPlace(start - 2, length, 2, bufferLen);\r\n        }\r\n    }\r\n\r\n    // Returns the final position of 'medianKey'.\r\n    grailBlockSelectSort(keys, start, medianKey, blockCount, blockLen) {\r\n        for (let block = 1; block < blockCount; block++) {\r\n            let left = block - 1;\r\n            let right = left;\r\n\r\n            for (let index = block; index < blockCount; index++) {\r\n                let compare = this.Reads.compareInArr(start + (right * blockLen),\r\n                    start + (index * blockLen));\r\n\r\n                if (compare > 0 || (compare == 0 && this.Reads.compareInArr(keys + right,\r\n                    keys + index) > 0)) {\r\n                    right = index;\r\n                }\r\n            }\r\n\r\n            if (right != left) {\r\n                // Swap the left and right selected blocks...\r\n                this.grailBlockSwap(start + (left * blockLen), start + (right * blockLen), blockLen);\r\n\r\n                // Swap the keys...\r\n                this.grailSwap(keys + left, keys + right);\r\n\r\n                // ...and follow the 'medianKey' if it was swapped\r\n\r\n                // ORIGINAL LOC: if(midkey==u-1 || midkey==p) midkey^=(u-1)^p;\r\n                // MASSIVE, MASSIVE credit to lovebuny for figuring this one out!\r\n                if (medianKey == left) {\r\n                    medianKey = right;\r\n                } else if (medianKey == right) {\r\n                    medianKey = left;\r\n                }\r\n            }\r\n        }\r\n\r\n        return medianKey;\r\n    }\r\n\r\n    // Swaps Grailsort's \"scrolling buffer\" from the right side of the array all the way back to 'start'.\r\n    // Costs O(n) operations.\r\n    //\r\n    // OFF-BY-ONE BUG FIXED: used to be `int index = start + resetLen`; credit to 666666t for debugging\r\n    grailInPlaceBufferReset(start, resetLen, bufferLen) {\r\n        for (let index = start + resetLen - 1; index >= start; index--) {\r\n            this.grailSwap(index, index - bufferLen);\r\n        }\r\n    }\r\n\r\n    // Shifts entire array over 'bufferSize' spaces to make room for the out-of-place merging buffer.\r\n    // Costs O(n) operations.\r\n    //\r\n    // OFF-BY-ONE BUG FIXED: used to be `int index = start + resetLen`; credit to 666666t for debugging\r\n    grailOutOfPlaceBufferReset(start, resetLen, bufferLen) {\r\n        for (let index = start + resetLen - 1; index >= start; index--) {\r\n            this.Writes.write(index, this.Reads.get(index - bufferLen))\r\n        }\r\n    }\r\n\r\n    // Rewinds Grailsort's \"scrolling buffer\" such that any items from a left subarray block left over by a \"smart merge\" are moved to\r\n    // the right of the buffer. This is used to maintain stability and to continue an ongoing merge that has run out of buffer space.\r\n    // Costs O(sqrt n) swaps in the *absolute* worst-case. \r\n    //\r\n    // NAMING IMPROVED: the left over items are in the middle of the merge while the buffer is at the end\r\n    grailInPlaceBufferRewind(start, leftOvers, buffer) {\r\n        while (leftOvers > start) {\r\n            leftOvers--;\r\n            buffer--;\r\n            this.grailSwap(buffer, leftOvers);\r\n        }\r\n    }\r\n\r\n    // Rewinds Grailsort's out-of-place buffer such that any items from a left subarray block left over by a \"smart merge\" are moved to\r\n    // the right of the buffer. This is used to maintain stability and to continue an ongoing merge that has run out of buffer space.\r\n    // Costs O(sqrt n) writes in the *absolute* worst-case.\r\n    //\r\n    // INCORRECT ORDER OF PARAMETERS BUG FIXED: `leftOvers` should be the middle, and `buffer` should be the end\r\n    grailOutOfPlaceBufferRewind(start, leftOvers, buffer) {\r\n        while (leftOvers > start) {\r\n            leftOvers--;\r\n            buffer--;\r\n            // array[buffer] = array[leftOvers];\r\n            this.Writes.write(buffer, this.Reads.get(leftOvers))\r\n        }\r\n    }\r\n\r\n    grailGetSubarray(currentKey, medianKey) {\r\n        if (this.Reads.compareInArr(currentKey, medianKey) < 0) {\r\n            return Subarray.LEFT;\r\n        } else {\r\n            return Subarray.RIGHT;\r\n        }\r\n    }\r\n\r\n    // FUNCTION RENAMED: more clear *which* left blocks are being counted\r\n    grailCountFinalLeftBlocks(offset, blockCount, blockLen) {\r\n        let leftBlocks = 0;\r\n\r\n        let firstRightBlock = offset + (blockCount * blockLen);\r\n        let prevLeftBlock = firstRightBlock - blockLen;\r\n\r\n        while (leftBlocks < blockCount && this.Reads.compareInArr(firstRightBlock,\r\n            prevLeftBlock) < 0) {\r\n            leftBlocks++;\r\n            prevLeftBlock -= blockLen;\r\n        }\r\n\r\n        return leftBlocks;\r\n    }\r\n\r\n    grailSmartMerge(start, leftLen, leftOrigin, rightLen, bufferOffset) {\r\n        let left = start;\r\n        let middle = start + leftLen;\r\n        let right = middle;\r\n        let end = middle + rightLen;\r\n        let buffer = start - bufferOffset;\r\n\r\n        if (leftOrigin == Subarray.LEFT) {\r\n            while (left < middle && right < end) {\r\n                if (this.Reads.compareInArr(left, right) <= 0) {\r\n                    this.grailSwap(buffer, left);\r\n                    left++;\r\n                } else {\r\n                    this.grailSwap(buffer, right);\r\n                    right++;\r\n                }\r\n                buffer++;\r\n            }\r\n        } else {\r\n            while (left < middle && right < end) {\r\n                if (this.Reads.compareInArr(left, right) < 0) {\r\n                    this.grailSwap(buffer, left);\r\n                    left++;\r\n                } else {\r\n                    this.grailSwap(buffer, right);\r\n                    right++;\r\n                }\r\n                buffer++;\r\n            }\r\n        }\r\n\r\n        if (left < middle) {\r\n            this.currentBlockLen = middle - left;\r\n            this.grailInPlaceBufferRewind(left, middle, end);\r\n        } else {\r\n            this.currentBlockLen = end - right;\r\n            if (leftOrigin == Subarray.LEFT) {\r\n                this.currentBlockOrigin = Subarray.RIGHT;\r\n            } else {\r\n                this.currentBlockOrigin = Subarray.LEFT;\r\n            }\r\n        }\r\n    }\r\n\r\n    grailSmartLazyMerge(start, leftLen, leftOrigin, rightLen) {\r\n        if (leftOrigin == Subarray.LEFT) {\r\n            if (this.Reads.compareInArr(start + leftLen - 1, start + leftLen) > 0) {\r\n                while (leftLen != 0) {\r\n                    let insertPos = this.grailBinarySearchLeft(start + leftLen, rightLen, this.Reads.readValue(start));\r\n\r\n                    if (insertPos != 0) {\r\n                        this.grailRotate(start, leftLen, insertPos);\r\n                        start += insertPos;\r\n                        rightLen -= insertPos;\r\n                    }\r\n\r\n                    if (rightLen == 0) {\r\n                        this.currentBlockLen = leftLen;\r\n                        return;\r\n                    } else {\r\n                        do {\r\n                            start++;\r\n                            leftLen--;\r\n                        } while (leftLen != 0 && this.Reads.compareInArr(start,\r\n                            start + leftLen) <= 0);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (this.Reads.compareInArr(start + leftLen - 1, start + leftLen) >= 0) {\r\n                while (leftLen != 0) {\r\n                    let insertPos = this.grailBinarySearchRight(start + leftLen, rightLen, this.Reads.readValue(start));\r\n\r\n                    if (insertPos != 0) {\r\n                        this.grailRotate(start, leftLen, insertPos);\r\n                        start += insertPos;\r\n                        rightLen -= insertPos;\r\n                    }\r\n\r\n                    if (rightLen == 0) {\r\n                        this.currentBlockLen = leftLen;\r\n                        return;\r\n                    } else {\r\n                        do {\r\n                            start++;\r\n                            leftLen--;\r\n                        } while (leftLen != 0 && this.Reads.compareInArr(start,\r\n                            start + leftLen) < 0);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.currentBlockLen = rightLen;\r\n        if (leftOrigin == Subarray.LEFT) {\r\n            this.currentBlockOrigin = Subarray.RIGHT;\r\n        } else {\r\n            this.currentBlockOrigin = Subarray.LEFT;\r\n        }\r\n    }\r\n\r\n    // FUNCTION RENAMED: more consistent with other \"out-of-place\" merges\r\n    grailSmartMergeOutOfPlace(start, leftLen, leftOrigin, rightLen, bufferOffset) {\r\n        let left = start;\r\n        let middle = start + leftLen;\r\n        let right = middle;\r\n        let end = middle + rightLen;\r\n        let buffer = start - bufferOffset;\r\n\r\n        if (leftOrigin == Subarray.LEFT) {\r\n            while (left < middle && right < end) {\r\n                if (this.Reads.compareInArr(left, right) <= 0) {\r\n                    this.Writes.write(buffer, this.Reads.get(left))\r\n                    left++;\r\n                } else {\r\n                    this.Writes.write(buffer, this.Reads.get(right))\r\n                    right++;\r\n                }\r\n                buffer++;\r\n            }\r\n        } else {\r\n            while (left < middle && right < end) {\r\n                if (this.Reads.compareInArr(left, right) < 0) {\r\n                    this.Writes.write(buffer, this.Reads.get(left))\r\n                    left++;\r\n                } else {\r\n                    this.Writes.write(buffer, this.Reads.get(right))\r\n                    right++;\r\n                }\r\n                buffer++;\r\n            }\r\n        }\r\n\r\n        if (left < middle) {\r\n            this.currentBlockLen = middle - left;\r\n            this.grailOutOfPlaceBufferRewind(left, middle, end);\r\n        } else {\r\n            this.currentBlockLen = end - right;\r\n            if (leftOrigin == Subarray.LEFT) {\r\n                this.currentBlockOrigin = Subarray.RIGHT;\r\n            } else {\r\n                this.currentBlockOrigin = Subarray.LEFT;\r\n            }\r\n        }\r\n    }\r\n\r\n    grailMergeBlocks(keys, medianKey, start, blockCount, blockLen, finalLeftBlocks, finalLen) {\r\n        let currentBlock;\r\n        let blockIndex = blockLen;\r\n\r\n        this.currentBlockLen = blockLen;\r\n        this.currentBlockOrigin = this.grailGetSubarray(keys, medianKey);\r\n\r\n        for (let keyIndex = 1; keyIndex < blockCount; keyIndex++, blockIndex += blockLen) {\r\n            currentBlock = blockIndex - this.currentBlockLen;\r\n\r\n            let nextBlockOrigin = this.grailGetSubarray(keys + keyIndex, medianKey);\r\n\r\n            if (nextBlockOrigin == this.currentBlockOrigin) {\r\n                this.grailBlockSwap(start + currentBlock - blockLen, start + currentBlock, this.currentBlockLen);\r\n                currentBlock = blockIndex;\r\n\r\n                this.currentBlockLen = blockLen;\r\n            } else {\r\n                this.grailSmartMerge(start + currentBlock, this.currentBlockLen, this.currentBlockOrigin, blockLen, blockLen);\r\n            }\r\n        }\r\n\r\n        currentBlock = blockIndex - this.currentBlockLen;\r\n\r\n        if (finalLen != 0) {\r\n            if (this.currentBlockOrigin == Subarray.RIGHT) {\r\n                this.grailBlockSwap(start + currentBlock - blockLen, start + currentBlock, this.currentBlockLen);\r\n                currentBlock = blockIndex;\r\n\r\n                this.currentBlockLen = blockLen * finalLeftBlocks;\r\n                this.currentBlockOrigin = Subarray.LEFT;\r\n            } else {\r\n                this.currentBlockLen += blockLen * finalLeftBlocks;\r\n            }\r\n\r\n            this.grailMergeForwards(start + currentBlock, this.currentBlockLen, finalLen, blockLen);\r\n        } else {\r\n            this.grailBlockSwap(start + currentBlock, start + currentBlock - blockLen, this.currentBlockLen);\r\n        }\r\n    }\r\n\r\n    grailLazyMergeBlocks(keys, medianKey, start, blockCount, blockLen, finalLeftBlocks, finalLen) {\r\n        let currentBlock;\r\n        let blockIndex = blockLen;\r\n\r\n        this.currentBlockLen = blockLen;\r\n        this.currentBlockOrigin = this.grailGetSubarray(keys, medianKey);\r\n\r\n        for (let keyIndex = 1; keyIndex < blockCount; keyIndex++, blockIndex += blockLen) {\r\n            currentBlock = blockIndex - this.currentBlockLen;\r\n\r\n            let nextBlockOrigin = this.grailGetSubarray(keys + keyIndex, medianKey);\r\n\r\n            if (nextBlockOrigin == this.currentBlockOrigin) {\r\n                currentBlock = blockIndex;\r\n\r\n                this.currentBlockLen = blockLen;\r\n            } else {\r\n                // These checks were included in the original code... but why???\r\n                if (blockLen != 0 && this.currentBlockLen != 0) {\r\n                    this.grailSmartLazyMerge(start + currentBlock, this.currentBlockLen, this.currentBlockOrigin, blockLen);\r\n                }\r\n            }\r\n        }\r\n\r\n        currentBlock = blockIndex - this.currentBlockLen;\r\n\r\n        if (finalLen != 0) {\r\n            if (this.currentBlockOrigin == Subarray.RIGHT) {\r\n                currentBlock = blockIndex;\r\n\r\n                this.currentBlockLen = blockLen * finalLeftBlocks;\r\n                this.currentBlockOrigin = Subarray.LEFT;\r\n            } else {\r\n                this.currentBlockLen += blockLen * finalLeftBlocks;\r\n            }\r\n\r\n            this.grailLazyMerge(start + currentBlock, this.currentBlockLen, finalLen);\r\n        }\r\n    }\r\n\r\n    grailMergeBlocksOutOfPlace(keys, medianKey, start, blockCount, blockLen, finalLeftBlocks, finalLen) {\r\n        let currentBlock;\r\n        let blockIndex = blockLen;\r\n\r\n        this.currentBlockLen = blockLen;\r\n        this.currentBlockOrigin = this.grailGetSubarray(keys, medianKey);\r\n\r\n        for (let keyIndex = 1; keyIndex < blockCount; keyIndex++, blockIndex += blockLen) {\r\n            currentBlock = blockIndex - this.currentBlockLen;\r\n\r\n            let nextBlockOrigin = this.grailGetSubarray(keys + keyIndex, medianKey);\r\n\r\n            if (nextBlockOrigin == this.currentBlockOrigin) {\r\n                this.arraycopy(-1, start + currentBlock, -1, start + currentBlock - blockLen, this.currentBlockLen);\r\n                currentBlock = blockIndex;\r\n\r\n                this.currentBlockLen = blockLen;\r\n            } else {\r\n                this.grailSmartMergeOutOfPlace(start + currentBlock, this.currentBlockLen, this.currentBlockOrigin, blockLen, blockLen);\r\n            }\r\n        }\r\n\r\n        currentBlock = blockIndex - this.currentBlockLen;\r\n\r\n        if (finalLen != 0) {\r\n            if (this.currentBlockOrigin == Subarray.RIGHT) {\r\n                this.arraycopy(-1, start + currentBlock, -1, start + currentBlock - blockLen, this.currentBlockLen);\r\n                currentBlock = blockIndex;\r\n\r\n                this.currentBlockLen = blockLen * finalLeftBlocks;\r\n                this.currentBlockOrigin = Subarray.LEFT;\r\n            } else {\r\n                this.currentBlockLen += blockLen * finalLeftBlocks;\r\n            }\r\n\r\n            this.grailMergeOutOfPlace(start + currentBlock, this.currentBlockLen, finalLen, blockLen);\r\n        } else {\r\n            this.arraycopy(-1, start + currentBlock, -1, start + currentBlock - blockLen, this.currentBlockLen);\r\n        }\r\n    }\r\n\r\n    //TODO: Double-check \"Merge Blocks\" arguments\r\n    grailCombineInPlace(keys, start, length, subarrayLen, blockLen, mergeCount, lastSubarray, buffer) {\r\n        for (let mergeIndex = 0; mergeIndex < mergeCount; mergeIndex++) {\r\n            let offset = start + (mergeIndex * (2 * subarrayLen));\r\n            let blockCount = parseInt((2 * subarrayLen) / blockLen);\r\n\r\n            this.grailInsertSort(keys, blockCount);\r\n\r\n            // INCORRECT PARAMETER BUG FIXED: `block select sort` should be using `offset`, not `start`\r\n            let medianKey = parseInt(subarrayLen / blockLen);\r\n            medianKey = this.grailBlockSelectSort(keys, offset, medianKey, blockCount, blockLen);\r\n\r\n            if (buffer) {\r\n                this.grailMergeBlocks(keys, keys + medianKey, offset, blockCount, blockLen, 0, 0);\r\n            } else {\r\n                this.grailLazyMergeBlocks(keys, keys + medianKey, offset, blockCount, blockLen, 0, 0);\r\n            }\r\n        }\r\n\r\n        // INCORRECT CONDITIONAL/PARAMETER BUG FIXED: Credit to 666666t for debugging.\r\n        if (lastSubarray != 0) {\r\n            let offset = start + (mergeCount * (2 * subarrayLen));\r\n            let rightBlocks = parseInt(lastSubarray / blockLen);\r\n\r\n            this.grailInsertSort(keys, rightBlocks + 1);\r\n\r\n            // INCORRECT PARAMETER BUG FIXED: `block select sort` should be using `offset`, not `start`\r\n            let medianKey = parseInt(subarrayLen / blockLen);\r\n            medianKey = this.grailBlockSelectSort(keys, offset, medianKey, rightBlocks, blockLen);\r\n\r\n            // MISSING BOUNDS CHECK BUG FIXED: `lastFragment` *can* be 0 if the `lastSubarray` is evenly\r\n            //                                 divided into blocks. This prevents Grailsort from going\r\n            //                                 out of bounds.\r\n            let lastFragment = lastSubarray % blockLen;\r\n            let leftBlocks;\r\n            if (lastFragment != 0) {\r\n                leftBlocks = this.grailCountFinalLeftBlocks(offset, rightBlocks, blockLen);\r\n            } else {\r\n                leftBlocks = 0;\r\n            }\r\n\r\n            let blockCount = rightBlocks - leftBlocks;\r\n\r\n            //TODO: Double-check if this micro-optimization works correctly like the original\r\n            if (blockCount == 0) {\r\n                let leftLength = leftBlocks * blockLen;\r\n\r\n                // INCORRECT PARAMETER BUG FIXED: these merges should be using `offset`, not `start`\r\n                if (buffer) {\r\n                    this.grailMergeForwards(offset, leftLength, lastFragment, blockLen);\r\n                } else {\r\n                    this.grailLazyMerge(offset, leftLength, lastFragment);\r\n                }\r\n            } else {\r\n                if (buffer) {\r\n                    this.grailMergeBlocks(keys, keys + medianKey, offset, blockCount, blockLen, leftBlocks, lastFragment);\r\n                } else {\r\n                    this.grailLazyMergeBlocks(keys, keys + medianKey, offset, blockCount, blockLen, leftBlocks, lastFragment);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (buffer) {\r\n            this.grailInPlaceBufferReset(start, length, blockLen);\r\n        }\r\n    }\r\n\r\n    grailCombineOutOfPlace(keys, start, length, subarrayLen, blockLen, mergeCount, lastSubarray) {\r\n        this.arraycopy(-1, start - blockLen, this.externalBuffer, 0, blockLen);\r\n\r\n        for (let mergeIndex = 0; mergeIndex < mergeCount; mergeIndex++) {\r\n            let offset = start + (mergeIndex * (2 * subarrayLen));\r\n            let blockCount = parseInt((2 * subarrayLen) / blockLen);\r\n\r\n            this.grailInsertSort(keys, blockCount);\r\n\r\n            // INCORRECT PARAMETER BUG FIXED: `block select sort` should be using `offset`, not `start`\r\n            let medianKey = parseInt(subarrayLen / blockLen);\r\n            medianKey = this.grailBlockSelectSort(keys, offset, medianKey, blockCount, blockLen);\r\n\r\n            this.grailMergeBlocksOutOfPlace(keys, keys + medianKey, offset, blockCount, blockLen, 0, 0);\r\n        }\r\n\r\n        // INCORRECT CONDITIONAL/PARAMETER BUG FIXED: Credit to 666666t for debugging.\r\n        if (lastSubarray != 0) {\r\n            let offset = start + (mergeCount * (2 * subarrayLen));\r\n            let rightBlocks = parseInt(lastSubarray / blockLen);\r\n\r\n            this.grailInsertSort(keys, rightBlocks + 1);\r\n\r\n            // INCORRECT PARAMETER BUG FIXED: `block select sort` should be using `offset`, not `start`\r\n            let medianKey = subarrayLen / blockLen;\r\n            medianKey = this.grailBlockSelectSort(keys, offset, medianKey, rightBlocks, blockLen);\r\n\r\n            // MISSING BOUNDS CHECK BUG FIXED: `lastFragment` *can* be 0 if the `lastSubarray` is evenly\r\n            //                                 divided into blocks. This prevents Grailsort from going\r\n            //                                 out of bounds.\r\n            let lastFragment = lastSubarray % blockLen;\r\n            let leftBlocks;\r\n            if (lastFragment != 0) {\r\n                leftBlocks = this.grailCountFinalLeftBlocks(offset, rightBlocks, blockLen);\r\n            } else {\r\n                leftBlocks = 0;\r\n            }\r\n\r\n            let blockCount = rightBlocks - leftBlocks;\r\n\r\n            if (blockCount == 0) {\r\n                // INCORRECT PARAMETER BUG FIXED: this merge should be using `offset`, not `start`\r\n                let leftLength = leftBlocks * blockLen;\r\n                this.grailMergeOutOfPlace(offset, leftLength, lastFragment, blockLen);\r\n            } else {\r\n                this.grailMergeBlocksOutOfPlace(keys, keys + medianKey, offset, blockCount, blockLen, leftBlocks, lastFragment);\r\n            }\r\n        }\r\n\r\n        this.grailOutOfPlaceBufferReset(start, length, blockLen);\r\n        this.arraycopy(this.externalBuffer, 0, -1, start - blockLen, blockLen);\r\n    }\r\n\r\n    // 'keys' are on the left side of array. Blocks of length 'subarrayLen' combined. We'll combine them in pairs\r\n    // 'subarrayLen' is a power of 2. (2 * subarrayLen / blockLen) keys are guaranteed\r\n    grailCombineBlocks(keys, start, length, subarrayLen, blockLen, buffer) {\r\n        let mergeCount = parseInt(length / (2 * subarrayLen));\r\n        let lastSubarray = parseInt(length % (2 * subarrayLen));\r\n\r\n        if (lastSubarray <= subarrayLen) {\r\n            length -= lastSubarray;\r\n            lastSubarray = 0;\r\n        }\r\n\r\n        // INCOMPLETE CONDITIONAL BUG FIXED: In order to combine blocks out-of-place, we must check if a full-sized\r\n        //                                   block fits into our external buffer.\r\n        if (buffer && blockLen <= this.externalBufferLen) {\r\n            this.grailCombineOutOfPlace(keys, start, length, subarrayLen, blockLen, mergeCount, lastSubarray);\r\n        } else {\r\n            this.grailCombineInPlace(keys, start, length, subarrayLen, blockLen, mergeCount, lastSubarray, buffer);\r\n        }\r\n    }\r\n\r\n    // \"Classic\" in-place merge sort using binary searches and rotations\r\n    //\r\n    // cost: min(leftLen, rightLen)^2 + max(leftLen, rightLen)\r\n    grailLazyMerge(start, leftLen, rightLen) {\r\n        if (leftLen < rightLen) {\r\n            while (leftLen != 0) {\r\n                let insertPos = this.grailBinarySearchLeft(start + leftLen, rightLen, this.Reads.readValue(start));\r\n\r\n                if (insertPos != 0) {\r\n                    this.grailRotate(start, leftLen, insertPos);\r\n                    start += insertPos;\r\n                    rightLen -= insertPos;\r\n                }\r\n\r\n                if (rightLen == 0) {\r\n                    break;\r\n                } else {\r\n                    do {\r\n                        start++;\r\n                        leftLen--;\r\n                    } while (leftLen != 0 && this.Reads.compareInArr(start,\r\n                        start + leftLen) <= 0);\r\n                }\r\n            }\r\n        } else {\r\n            let end = start + leftLen + rightLen - 1;\r\n            while (rightLen != 0) {\r\n                let insertPos = this.grailBinarySearchRight(start, leftLen, this.Reads.readValue(end));\r\n\r\n                if (insertPos != leftLen) {\r\n                    this.grailRotate(start + insertPos, leftLen - insertPos, rightLen);\r\n                    end -= leftLen - insertPos;\r\n                    leftLen = insertPos;\r\n                }\r\n\r\n                if (leftLen == 0) {\r\n                    break;\r\n                } else {\r\n                    let leftEnd = start + leftLen - 1;\r\n                    do {\r\n                        rightLen--;\r\n                        end--;\r\n                    } while (rightLen != 0 && this.Reads.compareInArr(leftEnd,\r\n                        end) <= 0);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    grailLazyStableSort(start, length) {\r\n        for (let index = 1; index < length; index += 2) {\r\n            let left = start + index - 1;\r\n            let right = start + index;\r\n\r\n            if (this.Reads.compareInArr(left, right) > 0) {\r\n                this.grailSwap(left, right);\r\n            }\r\n        }\r\n        for (let mergeLen = 2; mergeLen < length; mergeLen *= 2) {\r\n            let mergeIndex;\r\n            let mergeEnd = length - (2 * mergeLen);\r\n\r\n            for (mergeIndex = 0; mergeIndex <= mergeEnd; mergeIndex += (2 * mergeLen)) {\r\n                this.grailLazyMerge(start + mergeIndex, mergeLen, mergeLen);\r\n            }\r\n\r\n            let leftOver = length - mergeIndex;\r\n            if (leftOver > mergeLen) {\r\n                this.grailLazyMerge(start + mergeIndex, mergeLen, leftOver - mergeLen);\r\n            }\r\n        }\r\n    }\r\n\r\n    static calcMinKeys(numKeys, blockKeysSum) {\r\n        let minKeys = 1;\r\n        while (minKeys < numKeys && blockKeysSum != 0) {\r\n            minKeys *= 2;\r\n            blockKeysSum = parseInt(blockKeysSum / 8);\r\n        }\r\n        return minKeys;\r\n    }\r\n\r\n    grailCommonSort(start, length, extBuf, extBufLen) {\r\n        if (length < 16) {\r\n            this.grailInsertSort(start, length);\r\n            return;\r\n        } else {\r\n            let blockLen = 1;\r\n\r\n            // find the smallest power of two greater than or equal to\r\n            // the square root of the input's length\r\n            while ((blockLen * blockLen) < length) {\r\n                blockLen *= 2;\r\n            }\r\n\r\n            // '((a - 1) / b) + 1' is actually a clever and very efficient\r\n            // formula for the ceiling of (a / b)\r\n            //\r\n            // credit to Anonymous0726 for figuring this out!\r\n            let keyLen = parseInt((length - 1) / blockLen) + 1;\r\n\r\n            // Grailsort is hoping to find `2 * sqrt(n)` unique items\r\n            // throughout the array\r\n            let idealKeys = keyLen + blockLen;\r\n\r\n            //TODO: Clean up `start +` offsets\r\n            let keysFound = this.grailCollectKeys(start, length, idealKeys);\r\n\r\n            let idealBuffer;\r\n            if (keysFound < idealKeys) {\r\n                if (keysFound < 4) {\r\n                    // GRAILSORT STRATEGY 3 -- No block swaps or scrolling buffer; resort to Lazy Stable Sort\r\n                    this.grailLazyStableSort(start, length);\r\n                    return;\r\n                } else {\r\n                    // GRAILSORT STRATEGY 2 -- Block swaps with small scrolling buffer and/or lazy merges\r\n                    keyLen = blockLen;\r\n                    blockLen = 0;\r\n                    idealBuffer = false;\r\n\r\n                    while (keyLen > keysFound) {\r\n                        keyLen = parseInt(keyLen / 2);\r\n                    }\r\n                }\r\n            } else {\r\n                // GRAILSORT STRATEGY 1 -- Block swaps with scrolling buffer\r\n                idealBuffer = true;\r\n            }\r\n\r\n            let bufferEnd = blockLen + keyLen;\r\n            let bufferLen;\r\n            if (idealBuffer) {\r\n                bufferLen = blockLen;\r\n            } else {\r\n                bufferLen = keyLen;\r\n            }\r\n\r\n            if (idealBuffer && extBuf != null) {\r\n                // GRAILSORT + EXTRA SPACE\r\n                this.externalBuffer = extBuf;\r\n                this.externalBufferLen = extBufLen;\r\n            }\r\n\r\n            this.grailBuildBlocks(start + bufferEnd, length - bufferEnd, bufferLen);\r\n\r\n            while ((length - bufferEnd) > (2 * bufferLen)) {\r\n                bufferLen *= 2;\r\n\r\n                let currentBlockLen = blockLen;\r\n                let scrollingBuffer = idealBuffer;\r\n\r\n                if (!scrollingBuffer) {\r\n                    if (keyLen > 4 && (parseInt(keyLen / 8) * keyLen) >= bufferLen) {\r\n                        currentBlockLen = parseInt(keyLen / 2);\r\n                        scrollingBuffer = true;\r\n                    } else {\r\n                        let blockKeysSum = parseInt(bufferLen * keysFound) / 2;\r\n                        let minKeys = GrailSort.calcMinKeys(keyLen, blockKeysSum);\r\n\r\n                        currentBlockLen = parseInt(2 * bufferLen) / minKeys;\r\n                    }\r\n                }\r\n\r\n                this.grailCombineBlocks(start, start + bufferEnd, length - bufferEnd, bufferLen, currentBlockLen, scrollingBuffer);\r\n            }\r\n\r\n            this.grailInsertSort(start, bufferEnd);\r\n            this.grailLazyMerge(start, bufferEnd, length - bufferEnd);\r\n        }\r\n    }\r\n\r\n    grailSortInPlace(start, length) {\r\n        this.grailCommonSort(start, length, null, 0);\r\n    }\r\n\r\n    /*\r\n    grailSortStaticOOP(array, start, length) {\r\n        let buffer = Array.newInstance(array[0].getClass(), GRAIL_STATIC_EXT_BUF_LEN);\r\n        this.grailCommonSort(array, start, length, buffer, GRAIL_STATIC_EXT_BUF_LEN);\r\n    }\r\n    \r\n    grailSortDynamicOOP(array, start, length) {\r\n        let bufferLen = 1;\r\n        while((bufferLen * bufferLen) < length) {\r\n            bufferLen *= 2;\r\n        }\r\n\r\n        let buffer = Array.newInstance(array[0].getClass(), bufferLen);\r\n\r\n        this.grailCommonSort(array, start, length, buffer, bufferLen);\r\n    }*/\r\n    runSort(low, high, bucketsNum, bufferSize) {\r\n        // this.grailSortInPlace(low, high + 1)\r\n        if(bufferSize === 0){\r\n            this.grailSortInPlace(low, high + 1)\r\n        }else{\r\n            let buffer = this.Writes.createAuxArray(bufferSize)\r\n            console.log(\"WITH BUFFER!!!\")\r\n            this.grailCommonSort(low, high + 1, buffer, bufferSize)\r\n            this.Writes.removeAuxArray(buffer)\r\n        }\r\n    }\r\n}\r\n\r\n","import {Sort} from \"./Sort\";\r\nimport {HeapSort} from \"./HeapSort\";\r\nimport {InsertionSort} from \"./InsertionSort\";\r\n\r\nexport class IntroSort extends Sort {\r\n    middle\r\n    sizeThreshold = 16;\r\n\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"IntroSort\"\r\n    }\r\n\r\n    floorLogBaseTwo(a) {\r\n        return (Math.floor(Math.log(a) / Math.log(2)));\r\n    }\r\n\r\n// Swaps the median of arr[left], arr[mid], and arr[right] to index left.\r\n// taken from gcc source code found here: https://gcc.gnu.org/onlinedocs/gcc-4.7.2/libstdc++/api/a01462_source.html\r\n// gccmedianof3(left, mid, right) {\r\n//     if (this.Reads.compareInArr(left, mid) < 0) {\r\n//         if (this.Reads.compareInArr(mid, right)  < 0) {\r\n//             this.Writes.swap(left, mid);\r\n//         }\r\n//         else if (this.Reads.compareInArr(left, right) < 0) {\r\n//             this.Writes.swap(left, right);\r\n//         }\r\n//     }\r\n//     else if (this.Reads.compareInArr(left, right) < 0) {\r\n//         this.middle = left;\r\n//         // return arr[left];\r\n//         return this.Reads.getValue(left);\r\n//     }\r\n//     else if (this.Reads.compareInArr(mid, right)  < 0) {\r\n//         this.Writes.swap(left, right);\r\n//     }\r\n//     else {\r\n//         this.Writes.swap(left, mid);\r\n//     }\r\n//     this.middle = left;\r\n//     // Highlights.markArray(3, left);\r\n//     return this.Reads.readValue(left);\r\n// }\r\n\r\n    medianof3(left, mid, right) {\r\n        if (this.Reads.compareInArr(right, left) < 0) {\r\n            this.Writes.swap(left, right);\r\n        }\r\n        if (this.Reads.compareInArr(mid, left) < 0) {\r\n            this.Writes.swap(mid, left);\r\n        }\r\n        if (this.Reads.compareInArr(right, mid) < 0) {\r\n            this.Writes.swap(right, mid);\r\n        }\r\n        this.middle = mid;\r\n        return this.Reads.readValue(mid);\r\n    }\r\n\r\n    partition(lo, hi, x) {\r\n        let i = lo, j = hi;\r\n        while (true) {\r\n            // console.log(\"PARTITION LOOP!\")\r\n            // while (Reads.compareValues(a[i], x) == -1) {\r\n            while (this.Reads.compareValues(this.Reads.get(i), x) < 0) {\r\n                i++;\r\n            }\r\n\r\n            j--;\r\n\r\n            // while (Reads.compareValues(x, a[j]) == -1) {\r\n            while (this.Reads.compareValues(x, this.Reads.get(j)) < 0) {\r\n                // Highlights.markArray(2, j);\r\n                // Delays.sleep(0.5);\r\n                j--;\r\n            }\r\n\r\n            if (!(i < j)) {\r\n                // Highlights.markArray(1, i);\r\n                // Delays.sleep(0.5);\r\n                return i;\r\n            }\r\n\r\n            // Follow the pivot and highlight it.\r\n            // if(i == middle) {\r\n            //     Highlights.markArray(3, j);\r\n            // }\r\n            // if(j == middle) {\r\n            //     Highlights.markArray(3, i);\r\n            // }\r\n\r\n            this.Writes.swap(i, j);\r\n            i++;\r\n        }\r\n    }\r\n\r\n    introsortLoop(lo, hi, depthLimit) {\r\n        while (hi - lo > this.sizeThreshold) {\r\n            // console.log(\"INTROSORT LOOP!!!\")\r\n            // while (hi - lo > 1) {\r\n            if (depthLimit === 0) {\r\n                // this.Marks.clearAllMarks();\r\n                let heapSort = new HeapSort(this.arrayVisualizer)\r\n\r\n                heapSort.heapSort(lo, hi);\r\n                return;\r\n            }\r\n            depthLimit--;\r\n            let p = this.partition(lo, hi, this.medianof3(lo, lo + Math.trunc((hi - lo) / 2), hi - 1));\r\n            this.introsortLoop(p, hi, depthLimit);\r\n            hi = p;\r\n        }\r\n        return;\r\n    }\r\n\r\n\r\n    runSort(low, high) {\r\n        this.introsortLoop(low, high + 1, this.floorLogBaseTwo(high-low+1))\r\n        let insertionSort = new InsertionSort(this.arrayVisualizer)\r\n        insertionSort.runSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class LLQuickSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"LLQuickSort\"\r\n    }\r\n    partition(lo, hi) {\r\n        let pivot = hi;\r\n        let i = lo;\r\n        for (let j = lo; j < hi; j++) {\r\n            if (this.Reads.compareInArr(j, pivot) < 0) {\r\n                this.Writes.swap(i, j);\r\n                i++;\r\n            }\r\n        }\r\n        this.Writes.swap(i, hi);\r\n        return i;\r\n    }\r\n\r\n    LLQuickSort(lo, hi) {\r\n        if (lo < hi) {\r\n            let p = this.partition(lo, hi);\r\n            this.LLQuickSort(lo, p - 1);\r\n            this.LLQuickSort(p + 1, hi);\r\n        }\r\n    }\r\n    runSort(low, high) {\r\n        this.LLQuickSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class LRQuickSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName=\"LRQuickSort\"\r\n    }\r\n\r\n    quickSort(p, r){\r\n        let pivot = Math.trunc(p + (r - p + 1) / 2);\r\n        let x = this.Reads.readValue(pivot);\r\n\r\n        let i = p;\r\n        let j = r;\r\n\r\n        while (i <= j) {\r\n            // while (this.Reads.readValue(i) < x){\r\n            while (this.Reads.compareValues(this.Reads.get(i), x) < 0){\r\n                i++;\r\n            }\r\n            // while (this.Reads.get(j) > x){\r\n            while (this.Reads.compareValues(this.Reads.get(j), x) > 0){\r\n                j--;\r\n            }\r\n\r\n            if (i <= j) {\r\n                this.Writes.swap(i, j);\r\n                i++;\r\n                j--;\r\n            }\r\n        }\r\n\r\n        if(p < j) {\r\n            this.quickSort(p, j);\r\n        }\r\n        if(i < r) {\r\n            this.quickSort(i, r);\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.quickSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\nimport {Element} from \"../classes/Element\";\r\n\r\nexport class LSDRadixSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"LSD RadixSort\"\r\n        this.isNeedBucketsNum = true;\r\n    }\r\n\r\n    LSDRadixSort(bucketsNum) {\r\n        let len = this.arrayVisualizer.getArrLength()\r\n        let max = this.Reads.readValue(0);\r\n        for (let i = 1; i < len; ++i) {\r\n            let tmp = this.Reads.readValue(i)\r\n            if (max < tmp) {\r\n                max = tmp\r\n            }\r\n        }\r\n        let highestPower = Math.log(max) / Math.log(bucketsNum);\r\n\r\n        let registers = new Array(bucketsNum)\r\n        for (let i = 0; i < bucketsNum; i++) {\r\n            registers[i] = [];\r\n        }\r\n\r\n        for (let p = 0; p <= highestPower; p++) {\r\n            for (let i = 0; i < len; i++) {\r\n                let stabVal = Math.max(0, Math.min(this.Reads.readValue(i), len - 1))\r\n                let digit = Math.trunc(stabVal / (bucketsNum ** p) % bucketsNum)\r\n                // console.log(digit)\r\n                registers[digit].push(this.Reads.get(i))\r\n                //PseudoWrite\r\n            }\r\n\r\n\r\n            let tempArray = this.Writes.createAuxArray(len)\r\n            let tempWrite = new Array(len)\r\n            let radix = registers.length\r\n\r\n\r\n            let total = 0;\r\n            for (let index = 0; index < registers.length; index++) {\r\n                for (let i = 0; i < registers[index].length; i++) {\r\n                    this.Writes.auxWrite(total++, registers[index][i], tempArray)\r\n                }\r\n                registers[index] = []\r\n            }\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                let register = i % radix\r\n                let pos = (register * Math.trunc(len / radix) + Math.trunc(i / radix))\r\n\r\n                this.Writes.write(pos, this.Reads.auxGet(pos, tempArray))\r\n                tempWrite[pos] = true\r\n            }\r\n            for (let i = 0; i < len; i++) {\r\n                if (!tempWrite[i]) {\r\n                    this.Writes.write(i, this.Reads.auxGet(i, tempArray))\r\n                }\r\n            }\r\n\r\n            this.Writes.removeAuxArray(tempArray)\r\n\r\n        }\r\n\r\n    }\r\n\r\n    runSort(low, high, bucketsNum) {\r\n        this.LSDRadixSort(bucketsNum)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\nimport {Writes} from \"../ArrayAccess/Writes\";\r\n\r\nexport class MergeSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"MergeSort\"\r\n    }\r\n\r\n    merge(tmp, start, mid, end) {\r\n        if (start === mid) {\r\n            return\r\n        }\r\n\r\n        this.merge(tmp, start, Math.trunc((mid + start) / 2), mid);\r\n        this.merge(tmp, mid, Math.trunc((mid + end) / 2), end);\r\n\r\n        let low = start\r\n        let high = mid\r\n\r\n        for (let nxt = 0; nxt < end - start; nxt++) {\r\n            if (low >= mid && high >= end) break;\r\n\r\n            if (low < mid && high >= end) {\r\n                this.Writes.auxWrite(nxt, this.Reads.get(low++), tmp)\r\n            } else if (low >= mid && high < end) {\r\n                this.Writes.auxWrite(nxt, this.Reads.get(high++), tmp)\r\n            } else if (this.Reads.compareInArr(low, high) <= 0) {\r\n                this.Writes.auxWrite(nxt, this.Reads.get(low++), tmp)\r\n            } else {\r\n                this.Writes.auxWrite(nxt, this.Reads.get(high++), tmp)\r\n            }\r\n        }\r\n        for (let i = 0; i < end - start; i++) {\r\n            this.Writes.write(start + i, this.Reads.auxGet(i, tmp))\r\n        }\r\n\r\n    }\r\n\r\n    MergeSort(low, high) {\r\n        let tmp = this.Writes.createAuxArray(low - high)\r\n\r\n        let mid = low + (Math.trunc((high - low) / 2))\r\n\r\n        this.merge(tmp, low, mid, high+1)\r\n\r\n        this.Writes.removeAuxArray(tmp)\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.MergeSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\nimport {InsertionSort} from \"./InsertionSort\";\r\n\r\nexport class PseudoTimSort extends Sort {\r\n    MIN_MERGE\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"PseudoTimSort\"\r\n        this.MIN_MERGE = 32\r\n    }\r\n\r\n    minRunLength(n) {\r\n        let r = 0;\r\n        while (n >= this.MIN_MERGE)\r\n        {\r\n            r |= (n & 1);\r\n            n >>= 1;\r\n        }\r\n        return n + r;\r\n    }\r\n    merge(l, m, r) {\r\n        let len1 = m - l + 1, len2 = r - m;\r\n        let left = this.Writes.createAuxArray(len1);\r\n        let right = this.Writes.createAuxArray(len2);\r\n        for(let x = 0; x < len1; x++)\r\n        {\r\n            // left[x] = arr[l + x];\r\n            this.Writes.auxWrite(x, this.Reads.get(l + x), left)\r\n        }\r\n        for(let x = 0; x < len2; x++)\r\n        {\r\n            // right[x] = arr[m + 1 + x];\r\n            this.Writes.auxWrite(x, this.Reads.get(m + 1 + x), right)\r\n        }\r\n\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = l;\r\n\r\n        while (i < len1 && j < len2)\r\n        {\r\n            // if (left[i] <= right[j])\r\n            if(this.Reads.compareValues(this.Reads.auxGet(i, left), this.Reads.auxGet(j, right))<=0)\r\n            {\r\n                // arr[k] = left[i];\r\n                this.Writes.write(k, this.Reads.auxGet(i, left))\r\n                i++;\r\n            }\r\n            else\r\n            {\r\n                // arr[k] = right[j];\r\n                this.Writes.write(k, this.Reads.auxGet(j, right))\r\n                j++;\r\n            }\r\n            k++;\r\n        }\r\n\r\n        while (i < len1) {\r\n            // arr[k] = left[i];\r\n            this.Writes.write(k, this.Reads.auxGet(i, left))\r\n            k++;\r\n            i++;\r\n        }\r\n\r\n        while (j < len2) {\r\n            this.Writes.write(k, this.Reads.auxGet(j, right))\r\n            k++;\r\n            j++;\r\n        }\r\n        this.Writes.removeAuxArray(right)\r\n        this.Writes.removeAuxArray(left)\r\n    }\r\n\r\n    pseudoTimSort(n)\r\n    {\r\n        let minRun = this.minRunLength(this.MIN_MERGE);\r\n\r\n        for(let i = 0; i < n; i += minRun)\r\n        {\r\n            let insertionSort = new InsertionSort(this.arrayVisualizer)\r\n\r\n            insertionSort.runSort(i, Math.min(\r\n                (i + this.MIN_MERGE - 1), (n - 1)));\r\n        }\r\n\r\n        for(let size = minRun; size < n; size = 2 * size) {\r\n            for(let left = 0; left < n; left += 2 * size) {\r\n                let mid = left + size - 1;\r\n                let right = Math.min((left + 2 * size - 1), (n - 1));\r\n                if(mid < right) {\r\n                    this.merge(left, mid, right);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.pseudoTimSort(high+1)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class SelectionSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"SelectionSort\"\r\n    }\r\n\r\n    SelectionSort() {\r\n        for (let i=0; i < this.arrLength; i++) {\r\n            let minIndex = i\r\n            for (let j=i; j < this.arrLength; j++) {\r\n                if (this.Reads.compareInArr(j, minIndex) < 0) {\r\n                    minIndex = j\r\n                }\r\n            }\r\n\r\n            if (this.Reads.compareInArr(i, minIndex) > 0) {\r\n                this.Writes.swap(i, minIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.SelectionSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class SlowSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"SlowSort\"\r\n        this.warnLen = 50\r\n    }\r\n\r\n    SlowSort(i, j) {\r\n        if (i >= j) {\r\n            return;\r\n        }\r\n        let m = Math.floor((i + j) / 2);\r\n        this.SlowSort(i, m);\r\n        this.SlowSort(m + 1, j);\r\n        if (this.Reads.compareInArr(j, m) < 0) {\r\n            this.Writes.swap(j, m)\r\n        }\r\n        this.SlowSort(i, j - 1)\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.SlowSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class StoogeSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"StoogeSort\"\r\n        this.warnLen = 60\r\n    }\r\n\r\n    StoogeSort(i, j) {\r\n        if (this.Reads.compareInArr(i, j) > 0) {\r\n            this.Writes.swap(i, j)\r\n        }\r\n        if (j - i > 1) {\r\n            let t = Math.trunc((j - i + 1) / 3)\r\n            this.StoogeSort(i, j - t)\r\n            this.StoogeSort(i + t, j)\r\n            this.StoogeSort(i, j - t)\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.StoogeSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\n/**\r\n * Default minimum size of a run.\r\n */\r\nconst DEFAULT_MIN_MERGE = 32\r\n\r\n/**\r\n * Minimum ordered subsequece required to do galloping.\r\n */\r\nconst DEFAULT_MIN_GALLOPING = 7\r\n\r\n/**\r\n * Default tmp storage length. Can increase depending on the size of the\r\n * smallest run to merge.\r\n */\r\nconst DEFAULT_TMP_STORAGE_LENGTH = 256\r\n\r\n/**\r\n * Pre-computed powers of 10 for efficient lexicographic comparison of\r\n * small integers.\r\n */\r\nconst POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9]\r\n\r\nlet results\r\n\r\n/**\r\n * Estimate the logarithm base 10 of a small integer.\r\n *\r\n * @param {number} x - The integer to estimate the logarithm of.\r\n * @return {number} - The estimated logarithm of the integer.\r\n */\r\nconst log10 = x => x < 1e5\r\n    ? x < 1e2\r\n        ? x < 1e1\r\n            ? 0\r\n            : 1\r\n        : x < 1e4\r\n            ? x < 1e3\r\n                ? 2\r\n                : 3\r\n            : 4\r\n    : x < 1e7\r\n        ? x < 1e6\r\n            ? 5\r\n            : 6\r\n        : x < 1e9\r\n            ? x < 1e8\r\n                ? 7\r\n                : 8\r\n            : 9\r\n\r\n/**\r\n * Default alphabetical comparison of items.\r\n *\r\n * @param {string|object|number} a - First element to compare.\r\n * @param {string|object|number} b - Second element to compare.\r\n * @return {number} - A positive number if a.toString() > b.toString(), a\r\n * negative number if .toString() < b.toString(), 0 otherwise.\r\n */\r\nfunction alphabeticalCompare(a, b) {\r\n    if (a === b) {\r\n        return 0\r\n    }\r\n\r\n    if (~~a === a && ~~b === b) {\r\n        if (a === 0 || b === 0) {\r\n            return a < b ? -1 : 1\r\n        }\r\n\r\n        if (a < 0 || b < 0) {\r\n            if (b >= 0) {\r\n                return -1\r\n            }\r\n\r\n            if (a >= 0) {\r\n                return 1\r\n            }\r\n\r\n            a = -a\r\n            b = -b\r\n        }\r\n\r\n        const al = log10(a)\r\n        const bl = log10(b)\r\n\r\n        let t = 0\r\n\r\n        if (al < bl) {\r\n            a *= POWERS_OF_TEN[bl - al - 1]\r\n            b /= 10\r\n            t = -1\r\n        } else if (al > bl) {\r\n            b *= POWERS_OF_TEN[al - bl - 1]\r\n            a /= 10\r\n            t = 1\r\n        }\r\n\r\n        if (a === b) {\r\n            return t\r\n        }\r\n\r\n        return a < b ? -1 : 1\r\n    }\r\n\r\n    const aStr = String(a)\r\n    const bStr = String(b)\r\n\r\n    if (aStr === bStr) {\r\n        return 0\r\n    }\r\n\r\n    return aStr < bStr ? -1 : 1\r\n}\r\n\r\n/**\r\n * Compute minimum run length for TimSort\r\n *\r\n * @param {number} n - The size of the array to sort.\r\n */\r\nfunction minRunLength(n) {\r\n    let r = 0\r\n\r\n    while (n >= DEFAULT_MIN_MERGE) {\r\n        r |= (n & 1)\r\n        n >>= 1\r\n    }\r\n\r\n    return n + r\r\n}\r\n\r\n/**\r\n * Counts the length of a monotonically ascending or strictly monotonically\r\n * descending sequence (run) starting at array[lo] in the range [lo, hi). If\r\n * the run is descending it is made ascending.\r\n *\r\n * @param {array} array - The array to reverse.\r\n * @param {number} lo - First element in the range (inclusive).\r\n * @param {number} hi - Last element in the range.\r\n * @param {function} compare - Item comparison function.\r\n * @return {number} - The length of the run.\r\n */\r\n\r\nexport class TimSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n\r\n        this.minGallop = DEFAULT_MIN_GALLOPING\r\n\r\n        this.tmpStorageLength = this.arrLength < 2 * DEFAULT_TMP_STORAGE_LENGTH\r\n            ? this.arrLength >>> 1\r\n            : DEFAULT_TMP_STORAGE_LENGTH\r\n\r\n        // this.tmp = new Array(this.tmpStorageLength)\r\n        this.tmp = this.Writes.createAuxArray(this.tmpStorageLength)\r\n\r\n        this.stackLength = this.arrLength < 120\r\n            ? 5\r\n            : this.arrLength < 1542\r\n                ? 10\r\n                : this.arrLength < 119151\r\n                    ? 19\r\n                    : 40\r\n\r\n        this.runStart = new Array(this.stackLength)\r\n        this.runLength = new Array(this.stackLength)\r\n\r\n        this.stackSize = 0\r\n        this.sortName = \"TimSort\"\r\n    }\r\n\r\n    makeAscendingRun(lo, hi) {\r\n        let runHi = lo + 1\r\n\r\n        if (runHi === hi) {\r\n            return 1\r\n        }\r\n\r\n        // Descending\r\n        // if (compare(array[runHi++], array[lo]) < 0) {\r\n        if (this.Reads.compareInArr(runHi++, lo)<0) {\r\n            // while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\r\n            while (runHi < hi && this.Reads.compareInArr(runHi, runHi - 1)<0) {\r\n                runHi++\r\n            }\r\n\r\n            // this.reverseRun(array, lo, runHi)\r\n            this.reverseRun(lo, runHi)\r\n            // reverseRun(results, lo, runHi)\r\n            // Ascending\r\n        } else {\r\n            // while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\r\n            while (runHi < hi && this.Reads.compareInArr(runHi, runHi - 1)>=0) {\r\n                runHi++\r\n            }\r\n        }\r\n\r\n        return runHi - lo\r\n    }\r\n\r\n    /**\r\n     * Reverse an array in the range [lo, hi).\r\n     *\r\n     * @param {array} array - The array to reverse.\r\n     * @param {number} lo - First element in the range (inclusive).\r\n     * @param {number} hi - Last element in the range.\r\n     */\r\n\r\n\r\n    reverseRun(lo, hi) {\r\n        hi--\r\n\r\n        while (lo < hi) {\r\n            // const t = array[lo]\r\n            // array[lo++] = array[hi]\r\n            // array[hi--] = t\r\n            const t = this.Reads.get(lo)\r\n            this.Writes.write(lo++, this.Reads.get(hi))\r\n            this.Writes.write(hi--, t)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Perform the binary sort of the array in the range [lo, hi) where start is\r\n     * the first element possibly out of order.\r\n     *\r\n     * @param {array} array - The array to sort.\r\n     * @param {number} lo - First element in the range (inclusive).\r\n     * @param {number} hi - Last element in the range.\r\n     * @param {number} start - First element possibly out of order.\r\n     * @param {} compare - Item comparison function.\r\n     */\r\n\r\n\r\n    binaryInsertionSort(lo, hi, start) {\r\n        if (start === lo) {\r\n            start++\r\n        }\r\n\r\n        for (; start < hi; start++) {\r\n            // const pivot = array[start]\r\n            const pivot = this.Reads.get(start)\r\n\r\n            // const pivotIndex = results[start]\r\n\r\n            // Ranges of the array where pivot belongs\r\n            let left = lo\r\n            let right = start\r\n\r\n            /*\r\n             *   pivot >= array[i] for i in [lo, left)\r\n             *   pivot <  array[i] for i in  in [right, start)\r\n             */\r\n            while (left < right) {\r\n                const mid = (left + right) >>> 1\r\n\r\n                // if (compare(pivot, array[mid]) < 0) {\r\n                // if (pivot.getValue() < this.Reads.readValue(mid)) {\r\n                if (this.Reads.compareValues(pivot, this.Reads.get(mid)) < 0) {\r\n                    right = mid\r\n                } else {\r\n                    left = mid + 1\r\n                }\r\n            }\r\n\r\n            /*\r\n             * Move elements right to make room for the pivot. If there are elements\r\n             * equal to pivot, left points to the first slot after them: this is also\r\n             * a reason for which TimSort is stable\r\n             */\r\n            let n = start - left\r\n            // Switch is just an optimization for small arrays\r\n            switch (n) {\r\n                case 3:\r\n                    // array[left + 3] = array[left + 2]\r\n                    this.Writes.write(left + 3, this.Reads.get(left + 2))\r\n                /* falls through */\r\n                case 2:\r\n                    // array[left + 2] = array[left + 1]\r\n                    this.Writes.write(left + 2, this.Reads.get(left + 1))\r\n                /* falls through */\r\n                case 1:\r\n                    // array[left + 1] = array[left]\r\n                    this.Writes.write(left + 1, this.Reads.get(left))\r\n                    break\r\n                default:\r\n                    while (n > 0) {\r\n                        // array[left + n] = array[left + n - 1]\r\n                        this.Writes.write(left + n, this.Reads.get(left + n - 1))\r\n                        n--\r\n                    }\r\n            }\r\n\r\n            // array[left] = pivot\r\n            this.Writes.write(left, pivot)\r\n            // results[left] = pivotIndex\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find the position at which to insert a value in a sorted range. If the range\r\n     * contains elements equal to the value the leftmost element index is returned\r\n     * (for stability).\r\n     *\r\n     * @param {number} value - Value to insert.\r\n     * @param {array} array - The array in which to insert value.\r\n     * @param {number} start - First element in the range.\r\n     * @param {number} length - Length of the range.\r\n     * @param {number} hint - The index at which to begin the search.\r\n     * @param {function} compare - Item comparison function.\r\n     * @return {number} - The index where to insert value.\r\n     */\r\n\r\n\r\n    gallopLeft(value, isAux, start, length, hint) {\r\n        let lastOffset = 0\r\n        let maxOffset = 0\r\n        let offset = 1\r\n        if (!isAux) {\r\n            // if (compare(value, array[start + hint]) > 0) {\r\n            if (value > this.Reads.readValue(start + hint)) {\r\n                maxOffset = length - hint\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint + offset]) > 0\r\n                    // && value > this.Reads.readValue(start + hint + offset)\r\n                    && (this.Reads.compareValues(value, this.Reads.get(start+hint+offset)) > 0)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint\r\n                offset += hint\r\n\r\n                // value <= array[start + hint]\r\n            } else {\r\n                maxOffset = hint + 1\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint - offset]) <= 0\r\n                    // && value <= this.Reads.readValue(start + hint - offset)\r\n                    // && value <= this.Reads.readValue(start + hint - offset)\r\n                    && (this.Reads.compareValues(value, this.Reads.get(start + hint - offset)) <= 0)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                const tmp = lastOffset\r\n                lastOffset = hint - offset\r\n                offset = hint - tmp\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++\r\n            while (lastOffset < offset) {\r\n                const m = lastOffset + ((offset - lastOffset) >>> 1)\r\n\r\n                // if (compare(value, array[start + m]) > 0) {\r\n                // if (value > this.Reads.readValue(start + m)) {\r\n                if (this.Reads.compareValues(value, this.Reads.get(start+m))>0) {\r\n                    lastOffset = m + 1\r\n                } else {\r\n                    offset = m\r\n                }\r\n            }\r\n        } else {\r\n            // if (compare(value, array[start + hint]) > 0) {\r\n            // if (value > this.Reads.auxReadValue(start + hint, this.tmp)) {\r\n            if (this.Reads.compareValues(value, this.Reads.auxReadValue(start + hint, this.tmp)) > 0) {\r\n                maxOffset = length - hint\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint + offset]) > 0\r\n                    // && value > this.Reads.auxReadValue(start + hint + offset, this.tmp)\r\n                    && (this.Reads.compareValues(value, this.Reads.auxReadValue(start + hint + offset, this.tmp))>0)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint\r\n                offset += hint\r\n\r\n                // value <= array[start + hint]\r\n            } else {\r\n                maxOffset = hint + 1\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint - offset]) <= 0\r\n                    // && value <= this.Reads.auxRead(start + hint - offset, this.tmp)\r\n                    // && value <= this.Reads.auxReadValue(start + hint - offset, this.tmp)\r\n                    && (this.Reads.compareValues(value, this.Reads.auxReadValue(start + hint - offset, this.tmp)) <= 0)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                const tmp = lastOffset\r\n                lastOffset = hint - offset\r\n                offset = hint - tmp\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++\r\n            while (lastOffset < offset) {\r\n                const m = lastOffset + ((offset - lastOffset) >>> 1)\r\n\r\n                // if (compare(value, array[start + m]) > 0) {\r\n                // if (value > this.Reads.auxReadValue(start + m, this.tmp)) {\r\n                if (this.Reads.compareValues(value, this.Reads.auxReadValue(start + m, this.tmp))>0) {\r\n                    lastOffset = m + 1\r\n                } else {\r\n                    offset = m\r\n                }\r\n            }\r\n        }\r\n        return offset\r\n    }\r\n\r\n    /**\r\n     * Find the position at which to insert a value in a sorted range. If the range\r\n     * contains elements equal to the value the rightmost element index is returned\r\n     * (for stability).\r\n     *\r\n     * @param {number} value - Value to insert.\r\n     * @param {array} array - The array in which to insert value.\r\n     * @param {number} start - First element in the range.\r\n     * @param {number} length - Length of the range.\r\n     * @param {number} hint - The index at which to begin the search.\r\n     * @param {function} compare - Item comparison function.\r\n     * @return {number} - The index where to insert value.\r\n     */\r\n\r\n\r\n    gallopRight(value, isAux, start, length, hint) {\r\n        let lastOffset = 0\r\n        let maxOffset = 0\r\n        let offset = 1\r\n\r\n        if (!isAux) {\r\n            // if (compare(value, array[start + hint]) < 0) {\r\n            // if (value < this.Reads.readValue(start + hint)) {\r\n            if (this.Reads.compareValues(value, this.Reads.get(start+hint)) < 0) {\r\n                maxOffset = hint + 1\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint - offset]) < 0\r\n                    // && value < this.Reads.readValue(start + hint - offset)\r\n                    && (this.Reads.compareValues(value, this.Reads.get(start + hint - offset)) < 0)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                const tmp = lastOffset\r\n                lastOffset = hint - offset\r\n                offset = hint - tmp\r\n\r\n                // value >= array[start + hint]\r\n            } else {\r\n                maxOffset = length - hint\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint + offset]) >= 0\r\n                    // && value >= this.Reads.readValue(start + hint + offset)\r\n                    && (this.Reads.compareValues(value, this.Reads.get(start + hint + offset))>=0)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint\r\n                offset += hint\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++\r\n\r\n            while (lastOffset < offset) {\r\n                const m = lastOffset + ((offset - lastOffset) >>> 1)\r\n\r\n                // if (compare(value, array[start + m]) < 0) {\r\n                // if (value < this.Reads.readValue(start + m)) {\r\n                if (this.Reads.compareValues(value, this.Reads.get(start+m)) < 0){\r\n                    offset = m\r\n                } else {\r\n                    lastOffset = m + 1\r\n                }\r\n            }\r\n\r\n        } else {\r\n            //AUX\r\n            // if (compare(value, array[start + hint]) < 0) {\r\n            // if (value < this.Reads.auxReadValue(start + hint, this.tmp)) { WARN\r\n            if (this.Reads.compareValues(value, this.Reads.auxReadValue(start + hint, this.tmp))<0) {\r\n                maxOffset = hint + 1\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint - offset]) < 0\r\n                    // && value < this.Reads.auxReadValue(start + hint - offset, this.tmp) WARN\r\n                    && (this.Reads.compareValues(value, this.Reads.auxReadValue(start + hint - offset, this.tmp))<0)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                const tmp = lastOffset\r\n                lastOffset = hint - offset\r\n                offset = hint - tmp\r\n\r\n                // value >= array[start + hint]\r\n            } else {\r\n                maxOffset = length - hint\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint + offset]) >= 0\r\n                    // && value >= this.Reads.auxReadValue(start + hint + offset, this.tmp)\r\n                    && (this.Reads.compareInArr(value, this.Reads.auxReadValue(start + hint + offset, this.tmp))>=0)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint\r\n                offset += hint\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++\r\n\r\n            while (lastOffset < offset) {\r\n                const m = lastOffset + ((offset - lastOffset) >>> 1)\r\n\r\n                // if (compare(value, array[start + m]) < 0) {\r\n                // if (value < this.Reads.auxReadValue(start + m, this.tmp)) {\r\n                if (this.Reads.compareValues(value, this.Reads.auxReadValue(start + m, this.tmp))<0) {\r\n                    offset = m\r\n                } else {\r\n                    lastOffset = m + 1\r\n                }\r\n            }\r\n        }\r\n\r\n        return offset\r\n    }\r\n\r\n\r\n    /**\r\n     * Push a new run on TimSort's stack.\r\n     *\r\n     * @param {number} runStart - Start index of the run in the original array.\r\n     * @param {number} runLength - Length of the run;\r\n     */\r\n    pushRun(runStart, runLength) {\r\n        this.runStart[this.stackSize] = runStart\r\n        this.runLength[this.stackSize] = runLength\r\n        this.stackSize += 1\r\n    }\r\n\r\n    /**\r\n     * Merge runs on TimSort's stack so that the following holds for all i:\r\n     * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]\r\n     * 2) runLength[i - 2] > runLength[i - 1]\r\n     */\r\n    mergeRuns() {\r\n        while (this.stackSize > 1) {\r\n            let n = this.stackSize - 2\r\n\r\n            if (\r\n                (\r\n                    n >= 1\r\n                    && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1]\r\n                )\r\n                || (\r\n                    n >= 2\r\n                    && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]\r\n                )\r\n            ) {\r\n                if (this.runLength[n - 1] < this.runLength[n + 1]) {\r\n                    n--\r\n                }\r\n            } else if (this.runLength[n] > this.runLength[n + 1]) {\r\n                break\r\n            }\r\n            this.mergeAt(n)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge all runs on TimSort's stack until only one remains.\r\n     */\r\n    forceMergeRuns() {\r\n        while (this.stackSize > 1) {\r\n            let n = this.stackSize - 2\r\n\r\n            if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {\r\n                n--\r\n            }\r\n\r\n            this.mergeAt(n)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge the runs on the stack at positions i and i+1. Must be always be called\r\n     * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).\r\n     *\r\n     * @param {number} i - Index of the run to merge in TimSort's stack.\r\n     */\r\n    mergeAt(i) {\r\n        let start1 = this.runStart[i]\r\n        let length1 = this.runLength[i]\r\n        const start2 = this.runStart[i + 1]\r\n        let length2 = this.runLength[i + 1]\r\n\r\n        this.runLength[i] = length1 + length2\r\n\r\n        if (i === this.stackSize - 3) {\r\n            this.runStart[i + 1] = this.runStart[i + 2]\r\n            this.runLength[i + 1] = this.runLength[i + 2]\r\n        }\r\n\r\n        this.stackSize--\r\n\r\n        /*\r\n         * Find where the first element in the second run goes in run1. Previous\r\n         * elements in run1 are already in place\r\n         */\r\n        // const k = gallopRight(array[start2], array, start1, length1, 0, compare)\r\n        const k = this.gallopRight(this.Reads.readValue(start2), false, start1, length1, 0)\r\n        start1 += k\r\n        length1 -= k\r\n\r\n        if (length1 === 0) {\r\n            return\r\n        }\r\n\r\n        /*\r\n         * Find where the last element in the first run goes in run2. Next elements\r\n         * in run2 are already in place\r\n         */\r\n        // length2 = gallopLeft(\r\n        //     array[start1 + length1 - 1],\r\n        //     array,\r\n        //     start2,\r\n        //     length2,\r\n        //     length2 - 1,\r\n        //     compare\r\n        // )\r\n        length2 = this.gallopLeft(\r\n            // array[start1 + length1 - 1],\r\n            this.Reads.readValue(start1 + length1 - 1),\r\n            false,\r\n            start2,\r\n            length2,\r\n            length2 - 1,\r\n        )\r\n\r\n        if (length2 === 0) {\r\n            return\r\n        }\r\n\r\n        /*\r\n         * Merge remaining runs. A tmp array with length = min(length1, length2) is\r\n         * used\r\n         */\r\n        if (length1 <= length2) {\r\n            this.mergeLow(start1, length1, start2, length2)\r\n        } else {\r\n            this.mergeHigh(start1, length1, start2, length2)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge two adjacent runs in a stable way. The runs must be such that the\r\n     * first element of run1 is bigger than the first element in run2 and the\r\n     * last element of run1 is greater than all the elements in run2.\r\n     * The method should be called when run1.length <= run2.length as it uses\r\n     * TimSort temporary array to store run1. Use mergeHigh if run1.length >\r\n     * run2.length.\r\n     *\r\n     * @param {number} start1 - First element in run1.\r\n     * @param {number} length1 - Length of run1.\r\n     * @param {number} start2 - First element in run2.\r\n     * @param {number} length2 - Length of run2.\r\n     */\r\n    mergeLow(start1, length1, start2, length2) {\r\n        // const {compare} = this\r\n        // const {array} = this\r\n        // const {tmp} = this\r\n        // const {tmpIndex} = this\r\n        // const {compare} = this\r\n        // const {array} = this\r\n        // const {tmp} = this\r\n        // const {tmpIndex} = this\r\n        let i = 0\r\n\r\n        for (i = 0; i < length1; i++) {\r\n            // tmp[i] = array[start1 + i]\r\n            this.Writes.auxWrite(i, this.Reads.get(start1 + i), this.tmp)\r\n        }\r\n\r\n        let cursor1 = 0\r\n        let cursor2 = start2\r\n        let dest = start1\r\n\r\n\r\n        // array[dest] = array[cursor2]\r\n        this.Writes.write(dest, this.Reads.get(cursor2))\r\n\r\n\r\n        dest++\r\n        cursor2++\r\n\r\n        if (--length2 === 0) {\r\n            for (i = 0; i < length1; i++) {\r\n                // array[dest + i] = tmp[cursor1 + i]\r\n                this.Writes.write(dest + i, this.Reads.auxGet(cursor1 + i, this.tmp))\r\n            }\r\n            return\r\n        }\r\n\r\n        if (length1 === 1) {\r\n            for (i = 0; i < length2; i++) {\r\n                // array[dest + i] = array[cursor2 + i]\r\n\r\n                this.Writes.write(dest + i, this.Reads.get(cursor2 + i))\r\n            }\r\n            // array[dest + length2] = tmp[cursor1]\r\n            this.Writes.write(dest + length2, this.Reads.auxGet(cursor1, this.tmp))\r\n            return\r\n        }\r\n\r\n        let {minGallop} = this\r\n\r\n        while (true) {\r\n            let count1 = 0\r\n            let count2 = 0\r\n            let exit = false\r\n\r\n            do {\r\n                // if (compare(array[cursor2], tmp[cursor1]) < 0) {\r\n                // if (this.Reads.readValue(cursor2) < this.Reads.auxReadValue(cursor1, this.tmp)) {\r\n                if (this.Reads.compareValues(this.Reads.get(cursor2), this.Reads.auxReadValue(cursor1, this.tmp)) < 0) {\r\n                    // array[dest] = array[cursor2]\r\n                    this.Writes.write(dest, this.Reads.get(cursor2))\r\n                    dest++\r\n                    cursor2++\r\n                    count2++\r\n                    count1 = 0\r\n\r\n                    if (--length2 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                } else {\r\n                    // array[dest] = tmp[cursor1]\r\n                    this.Writes.write(dest, this.Reads.auxGet(cursor1, this.tmp))\r\n\r\n                    dest++\r\n                    cursor1++\r\n                    count1++\r\n                    count2 = 0\r\n                    if (--length1 === 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n            } while ((count1 | count2) < minGallop)\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            do {\r\n                // count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare)\r\n                count1 = this.gallopRight(this.Reads.readValue(cursor2), true, cursor1, length1, 0)\r\n\r\n                if (count1 !== 0) {\r\n                    for (i = 0; i < count1; i++) {\r\n                        // array[dest + i] = tmp[cursor1 + i]\r\n                        // results[dest + i] = tmpIndex[cursor1 + i]\r\n                        this.Writes.write(dest + i, this.Reads.auxGet(cursor1 + i, this.tmp))\r\n                    }\r\n\r\n                    dest += count1\r\n                    cursor1 += count1\r\n                    length1 -= count1\r\n                    if (length1 <= 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n\r\n                // array[dest] = array[cursor2]\r\n                // results[dest] = results[cursor2]\r\n                this.Writes.write(dest, this.Reads.get(cursor2))\r\n\r\n                dest++\r\n                cursor2++\r\n\r\n                if (--length2 === 0) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                // count2 = this.gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare)\r\n                count2 = this.gallopLeft(this.Reads.auxReadValue(cursor1, this.tmp), false, cursor2, length2, 0)\r\n\r\n                if (count2 !== 0) {\r\n                    for (i = 0; i < count2; i++) {\r\n                        // array[dest + i] = array[cursor2 + i]\r\n                        // results[dest + i] = results[cursor2 + i]\r\n                        this.Writes.write(dest + i, this.Reads.get(cursor2 + i))\r\n                    }\r\n\r\n                    dest += count2\r\n                    cursor2 += count2\r\n                    length2 -= count2\r\n\r\n                    if (length2 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n                // array[dest] = tmp[cursor1]\r\n                // results[dest] = tmpIndex[cursor1]\r\n\r\n                this.Writes.write(dest, this.Reads.auxGet(cursor1, this.tmp))\r\n\r\n                dest++\r\n                cursor1++\r\n\r\n                if (--length1 === 1) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                minGallop--\r\n            } while (\r\n                count1 >= DEFAULT_MIN_GALLOPING\r\n                || count2 >= DEFAULT_MIN_GALLOPING\r\n                )\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            if (minGallop < 0) {\r\n                minGallop = 0\r\n            }\r\n\r\n            minGallop += 2\r\n        }\r\n\r\n        this.minGallop = minGallop\r\n\r\n        if (minGallop < 1) {\r\n            this.minGallop = 1\r\n        }\r\n\r\n        if (length1 === 1) {\r\n            for (i = 0; i < length2; i++) {\r\n                // array[dest + i] = array[cursor2 + i]\r\n                // results[dest + i] = results[cursor2 + i]\r\n                this.Writes.write(dest + i, this.Reads.get(cursor2 + i))\r\n            }\r\n            // array[dest + length2] = tmp[cursor1]\r\n            // results[dest + length2] = tmpIndex[cursor1]\r\n            this.Writes.write(dest + length2, this.Reads.auxGet(cursor1, this.tmp))\r\n        } else if (length1 === 0) {\r\n            throw new Error('mergeLow preconditions were not respected')\r\n        } else {\r\n            for (i = 0; i < length1; i++) {\r\n                // array[dest + i] = tmp[cursor1 + i]\r\n                // results[dest + i] = tmpIndex[cursor1 + i]\r\n                this.Writes.write(dest + i, this.Reads.auxGet(cursor1 + i, this.tmp))\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge two adjacent runs in a stable way. The runs must be such that the\r\n     * first element of run1 is bigger than the first element in run2 and the\r\n     * last element of run1 is greater than all the elements in run2.\r\n     * The method should be called when run1.length > run2.length as it uses\r\n     * TimSort temporary array to store run2. Use mergeLow if run1.length <=\r\n     * run2.length.\r\n     *\r\n     * @param {number} start1 - First element in run1.\r\n     * @param {number} length1 - Length of run1.\r\n     * @param {number} start2 - First element in run2.\r\n     * @param {number} length2 - Length of run2.\r\n     */\r\n    mergeHigh(start1, length1, start2, length2) {\r\n        // const {compare} = this\r\n        // const {array} = this\r\n        // const {tmp} = this\r\n        // const {tmpIndex} = this\r\n        let i = 0\r\n\r\n        for (i = 0; i < length2; i++) {\r\n            // tmp[i] = array[start2 + i]\r\n            this.Writes.auxWrite(i, this.Reads.get(start2 + i), this.tmp)\r\n        }\r\n\r\n        let cursor1 = start1 + length1 - 1\r\n        let cursor2 = length2 - 1\r\n        let dest = start2 + length2 - 1\r\n        let customCursor = 0\r\n        let customDest = 0\r\n\r\n        // array[dest] = array[cursor1]\r\n        this.Writes.write(dest, this.Reads.get(cursor1))\r\n\r\n        dest--\r\n        cursor1--\r\n\r\n        if (--length1 === 0) {\r\n            customCursor = dest - (length2 - 1)\r\n\r\n            for (i = 0; i < length2; i++) {\r\n                // array[customCursor + i] = tmp[i]\r\n                this.Writes.write(customCursor + i, this.Reads.auxGet(i, this.tmp))\r\n            }\r\n\r\n            return\r\n        }\r\n\r\n        if (length2 === 1) {\r\n            dest -= length1\r\n            cursor1 -= length1\r\n            customDest = dest + 1\r\n            customCursor = cursor1 + 1\r\n\r\n            for (i = length1 - 1; i >= 0; i--) {\r\n                // array[customDest + i] = array[customCursor + i]\r\n                this.Writes.write(customDest + i, this.Reads.get(customCursor + i))\r\n            }\r\n\r\n            // array[dest] = tmp[cursor2]\r\n            this.Writes.write(dest, this.Reads.auxGet(cursor2, this.tmp))\r\n            return\r\n        }\r\n\r\n        let {minGallop} = this\r\n\r\n        while (true) {\r\n            let count1 = 0\r\n            let count2 = 0\r\n            let exit = false\r\n\r\n            do {\r\n                // if (compare(tmp[cursor2], array[cursor1]) < 0) {\r\n                // if (this.Reads.auxReadValue(cursor2, this.tmp) < this.Reads.readValue(cursor1)) {\r\n                if (this.Reads.compareValues(this.Reads.auxReadValue(cursor2, this.tmp), this.Reads.get(cursor1))<0) {\r\n                    // array[dest] = array[cursor1]\r\n                    this.Writes.write(dest, this.Reads.get(cursor1))\r\n                    dest--\r\n                    cursor1--\r\n                    count1++\r\n                    count2 = 0\r\n                    if (--length1 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                } else {\r\n                    // array[dest] = tmp[cursor2]\r\n                    this.Writes.write(dest, this.Reads.auxGet(cursor2, this.tmp))\r\n                    dest--\r\n                    cursor2--\r\n                    count2++\r\n                    count1 = 0\r\n                    if (--length2 === 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n            } while ((count1 | count2) < minGallop)\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            do {\r\n                // count1 = length1 - gallopRight(\r\n                //     tmp[cursor2],\r\n                //     array,\r\n                //     start1,\r\n                //     length1,\r\n                //     length1 - 1,\r\n                //     compare\r\n                // )\r\n                count1 = length1 - this.gallopRight(\r\n                    this.Reads.auxReadValue(cursor2, this.tmp),\r\n                    false,\r\n                    start1,\r\n                    length1,\r\n                    length1 - 1\r\n                )\r\n\r\n                if (count1 !== 0) {\r\n                    dest -= count1\r\n                    cursor1 -= count1\r\n                    length1 -= count1\r\n                    customDest = dest + 1\r\n                    customCursor = cursor1 + 1\r\n\r\n                    for (i = count1 - 1; i >= 0; i--) {\r\n                        // array[customDest + i] = array[customCursor + i]\r\n                        this.Writes.write(customDest + i, this.Reads.get(customCursor + i))\r\n                    }\r\n\r\n                    if (length1 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n\r\n                // array[dest] = tmp[cursor2]\r\n                this.Writes.write(dest, this.Reads.auxGet(cursor2, this.tmp))\r\n\r\n                dest--\r\n                cursor2--\r\n\r\n                if (--length2 === 1) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                // count2 = length2 - gallopLeft(\r\n                //     array[cursor1],\r\n                //     tmp,\r\n                //     0,\r\n                //     length2,\r\n                //     length2 - 1,\r\n                //     compare\r\n                // )\r\n\r\n                count2 = length2 - this.gallopLeft(\r\n                    this.Reads.readValue(cursor1),\r\n                    true,\r\n                    0,\r\n                    length2,\r\n                    length2 - 1\r\n                )\r\n\r\n                if (count2 !== 0) {\r\n                    dest -= count2\r\n                    cursor2 -= count2\r\n                    length2 -= count2\r\n                    customDest = dest + 1\r\n                    customCursor = cursor2 + 1\r\n\r\n                    for (i = 0; i < count2; i++) {\r\n                        // array[customDest + i] = tmp[customCursor + i]\r\n                        this.Writes.write(customDest + i, this.Reads.auxGet(customCursor + i, this.tmp))\r\n                    }\r\n\r\n                    if (length2 <= 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n\r\n                // array[dest] = array[cursor1]\r\n                this.Writes.write(dest, this.Reads.get(cursor1))\r\n\r\n                dest--\r\n                cursor1--\r\n\r\n                if (--length1 === 0) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                minGallop--\r\n            } while (\r\n                count1 >= DEFAULT_MIN_GALLOPING\r\n                || count2 >= DEFAULT_MIN_GALLOPING\r\n                )\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            if (minGallop < 0) {\r\n                minGallop = 0\r\n            }\r\n\r\n            minGallop += 2\r\n        }\r\n\r\n        this.minGallop = minGallop\r\n\r\n        if (minGallop < 1) {\r\n            this.minGallop = 1\r\n        }\r\n\r\n        if (length2 === 1) {\r\n            dest -= length1\r\n            cursor1 -= length1\r\n            customDest = dest + 1\r\n            customCursor = cursor1 + 1\r\n\r\n            for (i = length1 - 1; i >= 0; i--) {\r\n                // array[customDest + i] = array[customCursor + i]\r\n                this.Writes.write(customDest + i, this.Reads.get(customCursor + i))\r\n            }\r\n\r\n            // array[dest] = tmp[cursor2]\r\n            // results[dest] = tmpIndex[cursor2]\r\n\r\n            this.Writes.write(dest, this.Reads.auxGet(cursor2, this.tmp))\r\n\r\n\r\n        } else if (length2 === 0) {\r\n            throw new Error('mergeHigh preconditions were not respected')\r\n        } else {\r\n            customCursor = dest - (length2 - 1)\r\n            for (i = 0; i < length2; i++) {\r\n                // array[customCursor + i] = tmp[i]\r\n                this.Writes.write(customCursor + i, this.Reads.auxGet(i, this.tmp))\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Sort an array in the range [lo, hi) using TimSort.\r\n     *\r\n     * @param {array} array - The array to sort.\r\n     * @param {function=} compare - Item comparison function. Default is\r\n     *     alphabetical\r\n     * @param {number} lo - First element in the range (inclusive).\r\n     * @param {number} hi - Last element in the range.\r\n     *     comparator.\r\n     */\r\n    runSort(low, high) {\r\n        this.sort(low, high+1)\r\n    }\r\n\r\n    sort(lo, hi) {\r\n\r\n        let i = 0\r\n\r\n        let remaining = hi - lo\r\n\r\n        // The array is already sorted\r\n        if (remaining < 2) {\r\n            return results\r\n        }\r\n\r\n        let runLength = 0\r\n        // On small arrays binary sort can be used directly\r\n        if (remaining < DEFAULT_MIN_MERGE) {\r\n            runLength = this.makeAscendingRun(lo, hi)\r\n            this.binaryInsertionSort(lo, hi, lo + runLength)\r\n        }\r\n\r\n\r\n        const minRun = minRunLength(remaining)\r\n\r\n        do {\r\n            runLength = this.makeAscendingRun(lo, hi)\r\n            if (runLength < minRun) {\r\n                let force = remaining\r\n                if (force > minRun) {\r\n                    force = minRun\r\n                }\r\n\r\n                this.binaryInsertionSort(lo, lo + force, lo + runLength)\r\n                runLength = force\r\n            }\r\n            // Push new run and merge if necessary\r\n            this.pushRun(lo, runLength)\r\n            this.mergeRuns()\r\n\r\n            // Go find next run\r\n            remaining -= runLength\r\n            lo += runLength\r\n        } while (remaining !== 0)\r\n\r\n        // Force merging of remaining runs\r\n        this.forceMergeRuns()\r\n        this.Writes.removeAuxArray(this.tmp)\r\n    }\r\n}","import React from \"react\";\r\nimport {objLength} from \"../utils/utils\";\r\nimport styles from \"./ArrayWindow.module.scss\";\r\n\r\nexport class ArrayWindow extends React.PureComponent {\r\n    array\r\n    mainArray\r\n    height\r\n    visualProps\r\n    borderEnabled\r\n    visualStyle\r\n    arrayLen\r\n    sizeStyle\r\n    isTimerEnded\r\n    isRunNeed\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.setProps(props)\r\n        this.state = {\r\n            renderedArray: this.renderArray()\r\n        }\r\n        this.isTimerEnded = true\r\n        this.isRunNeed = false\r\n    }\r\n    componentDidMount() {\r\n        //50 FPS\r\n        // setInterval(this.throttled.bind(this), 15)\r\n    }\r\n    throttled(){\r\n        this.isRunNeed = true\r\n        if(this.isTimerEnded){\r\n            this.isTimerEnded=false\r\n            this.updateState()\r\n            setTimeout(()=>{\r\n                this.isTimerEnded=true;\r\n                if(this.isRunNeed){\r\n                    this.updateState()\r\n                }\r\n                }, 30)\r\n        }\r\n    }\r\n    updateState(){\r\n        this.setState({\r\n            renderedArray: this.renderArray()\r\n        })\r\n    }\r\n    setProps(props){\r\n        this.array = props.array\r\n        this.mainArray = props.mainArray\r\n        this.height = props.height\r\n        this.visualProps = props.visualProps\r\n        this.borderEnabled = this.visualProps.barsStroke\r\n        this.visualStyle = this.visualProps.style\r\n        this.arrayLen = this.array.length\r\n        this.sizeStyle = {width: \"100%\", height: this.height + \"%\"};\r\n    }\r\n    componentWillReceiveProps(nextProps, nextContext){\r\n        if(this.isTimerEnded){\r\n            this.setProps(nextProps)\r\n        }\r\n        this.throttled()\r\n    }\r\n\r\n    renderArray() {\r\n        let tmp = []\r\n        if (this.visualStyle === \"bars\") {\r\n            let border = this.borderEnabled ? {} : {border: \"none\"}\r\n            for (let i = 0; i < this.arrayLen; ++i) {\r\n                let styleSheet = {\r\n                    height: this.array[i].getValue() / this.mainArray.length * 100 + \"%\",\r\n                    backgroundColor: \"rgb(\" + this.array[i].getColorForRender() + \")\",\r\n                    ...border\r\n                }\r\n                tmp.push(<div key={i} style={styleSheet} className={styles.bar}/>);\r\n            }\r\n            let styleSheet = {\r\n                height: \"0%\",\r\n                backgroundColor: \"rgb(255,255,255)\",\r\n            }\r\n            for (let i = this.arrayLen; i < this.mainArray.length; ++i) {\r\n                tmp.push(<div key={i} style={styleSheet} className={styles.bar}/>);\r\n            }\r\n        } else if (this.visualStyle === \"dots\") {\r\n            for (let i = 0; i < this.arrayLen; ++i) {\r\n                let value = this.array[i].getValue()\r\n                let height = (value === -1) ? {height: 0} : {}\r\n                let styleSheet = {\r\n                    bottom: \"calc(\" + value / this.mainArray.length * 100 + \"% - 0.25rem)\",\r\n                    backgroundColor: \"rgb(\" + this.array[i].getColorForRender() + \")\",\r\n                    ...height\r\n                }\r\n                tmp.push(<div className={styles.dotContainer}>\r\n                    <div key={i} style={styleSheet} className={styles.dot}/>\r\n                </div>);\r\n            }\r\n            let styleSheet = {\r\n                bottom: 0,\r\n                backgroundColor: \"rgb(0, 0, 0)\",\r\n            }\r\n            for (let i = this.arrayLen; i < this.mainArray.length; ++i) {\r\n                tmp.push(<div className={styles.dotContainer}>\r\n                    <div key={i} style={styleSheet} className={styles.dot}/>\r\n                </div>);\r\n            }\r\n        }\r\n        return tmp\r\n    }\r\n\r\n    render() {\r\n        if (this.arrayLen === 0) {\r\n            return <div style={this.sizeStyle}/>\r\n        }else{\r\n            return <div style={this.sizeStyle}>\r\n                <div className={styles.arrayContainer}>\r\n                    {this.state.renderedArray}\r\n                </div>\r\n            </div>\r\n        }\r\n    }\r\n}","import React from 'react';\r\nimport styles from \"./Stats.module.scss\";\r\n\r\nexport function Stats(props){\r\n    return(\r\n        <div className={styles.statsContainer}>\r\n            <div><b>Sort: {props.sortName}</b></div>\r\n            <div>Length: {props.arrLength}</div>\r\n            <div>Comparisons: {props.comparisons}</div>\r\n            <div>Writes to main array: {props.mainWrites}</div>\r\n            <div>Writes to auxiliary arrays: {props.auxWrites}</div>\r\n        </div>\r\n    )\r\n}","export const GAP_FACTOR = 10\r\nexport let initFunctions = {\r\n    linear: function (x, length) {\r\n        return x;\r\n    },\r\n    // reverse: function (x, length) {\r\n    //     return length - x;\r\n    // },\r\n    // pipeOrgan: function (x, length) {\r\n    //     if (x < length / 2) {\r\n    //         return 2 * x;\r\n    //     } else {\r\n    //         return 2 * (length - x) - 1;\r\n    //     }\r\n    // },\r\n    // inversedPipeOrgan: function (x, length){\r\n    //     if (x < length / 2) {\r\n    //         return (length - 2*x) - 1;\r\n    //     } else {\r\n    //         return x*2-length;\r\n    //     }\r\n    // },\r\n    manySimular: function (x, length){\r\n        let divider = Math.trunc(length/GAP_FACTOR)\r\n        return Math.trunc(x/divider)*divider\r\n    }\r\n}","import {randomInt} from \"./utils\";\r\nimport {HeapSort} from \"../Sorts/HeapSort\";\r\nimport {GAP_FACTOR} from \"./initFunctions\";\r\n\r\nexport let shuffles = {\r\n    FullShuffle: function (arrayVisualizer) {\r\n        let len = arrayVisualizer.getArrLength()\r\n        for (let i = 0; i < len; ++i) {\r\n            let randomIndex = randomInt(i, len)\r\n            arrayVisualizer.getWrites().swapWithDelay(i, randomIndex, arrayVisualizer.getMainArray(), true, arrayVisualizer.getDelays().getDelayInc()/5, true)\r\n        }\r\n        // return instructions\r\n    },\r\n\r\n    AlmostSorted: function (arrayVisualizer) {\r\n        let len = arrayVisualizer.getArrLength()\r\n        const AMOUNT = 0.1\r\n        for (let i = 0; i < len * AMOUNT; ++i) {\r\n            let randomIndexA = randomInt(i, len)\r\n            let randomIndexB = randomInt(i, len)\r\n            arrayVisualizer.getWrites().swapWithDelay(randomIndexA, randomIndexB, arrayVisualizer.getMainArray(), true, arrayVisualizer.getDelays().getDelayInc()/5, true)\r\n        }\r\n    },\r\n    Reverse: function (arrayVisualizer){\r\n        let len = arrayVisualizer.getArrLength()\r\n        for (let i = 0; i < Math.trunc(len/2); ++i){\r\n            arrayVisualizer.getWrites().swapWithDelay(i, len-i-1, arrayVisualizer.getMainArray(), true, arrayVisualizer.getDelays().getDelayInc()/5, true)\r\n        }\r\n    },\r\n    BlockShuffle: function (arrayVisualizer) {\r\n        let len = arrayVisualizer.getArrLength()\r\n        let gap = len/GAP_FACTOR\r\n        for (let i = 0; i < GAP_FACTOR-1; ++i) {\r\n            let factor = randomInt(i+1, GAP_FACTOR)\r\n            for(let j = 0; j < gap; ++j){\r\n                arrayVisualizer.getWrites().swapWithDelay(j+i*gap, j+factor*gap, arrayVisualizer.getMainArray(), true, arrayVisualizer.getDelays().getDelayInc()/5, true)\r\n            }\r\n        }\r\n    },\r\n    PipeOrgan: function (arrayVisualizer){\r\n        let len = arrayVisualizer.getArrLength()\r\n        let Reads = arrayVisualizer.getReads()\r\n        let temp = new Array(len);\r\n        for(let i = 0, j = 0; i < len; i+=2){\r\n            temp[j++] = Reads.get(i, arrayVisualizer.getMainArray())\r\n        }\r\n        for(let i = 1, j = len; i < len ;i+=2) {\r\n            temp[--j] = Reads.get(i, arrayVisualizer.getMainArray())\r\n        }\r\n        for(let i = 0; i < len; i++){\r\n            arrayVisualizer.getWrites().writeWithDelay(i, temp[i], arrayVisualizer.getMainArray(), true, arrayVisualizer.getDelays().getDelayInc()/5, true)\r\n        }\r\n    },\r\n    InversedPipeOrgan: function (arrayVisualizer){\r\n        let len = arrayVisualizer.getArrLength()\r\n        let Reads = arrayVisualizer.getReads()\r\n        let temp = new Array(len);\r\n        for(let i = 0, j = 0; i < len; i+=2){\r\n            temp[j++] = Reads.get(len-i-1, arrayVisualizer.getMainArray())\r\n        }\r\n        for(let i = 1, j = len; i < len ;i+=2) {\r\n            temp[--j] = Reads.get(len-i-1, arrayVisualizer.getMainArray())\r\n        }\r\n        for(let i = 0; i < len; i++){\r\n            arrayVisualizer.getWrites().writeWithDelay(i, temp[i], arrayVisualizer.getMainArray(), true, arrayVisualizer.getDelays().getDelayInc()/5, true)\r\n        }\r\n    },\r\n    Heap: function (arrayVisualizer){\r\n        let n = arrayVisualizer.getArrLength()\r\n        arrayVisualizer.initPseudoArray()\r\n        let heapSort = new HeapSort(arrayVisualizer)\r\n        for (let i = Math.trunc(n / 2) - 1; i >= 0; i--) {\r\n            heapSort.heapify(n, i);\r\n        }\r\n    },\r\n    QuickSortKiller: function (arrayVisualizer){\r\n        let len = arrayVisualizer.getArrLength()\r\n        for(let j = len-len%2-2, i = j-1; i >= 0; i-=2, j--) {\r\n            arrayVisualizer.getWrites().swapWithDelay(i, j, arrayVisualizer.getMainArray(), true, arrayVisualizer.getDelays().getDelayInc() / 5, true)\r\n        }\r\n    }\r\n}","import React from 'react';\r\nimport styles from \"./Controls.module.scss\";\r\nimport {initFunctions} from \"../utils/initFunctions\";\r\nimport {shuffles} from \"../utils/shuffles\";\r\n\r\n\r\nexport class Controls extends React.PureComponent {\r\n    isControlShow\r\n    arrayVisualizer\r\n    sorts\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.isControlShow = true;\r\n        this.arrayVisualizer = props.arrayVisualizer\r\n        this.sorts = props.sorts\r\n        this.arrayVisualizer.updateArrLength(this.arrayVisualizer.DEFAULT_ARR_LEN)\r\n        // this.arrayVisualizer.initArray(initFunctions.linear)\r\n    }\r\n\r\n    updateArrLength() {\r\n        this.stopSort()\r\n        let slider = document.getElementById(styles.slider)\r\n\r\n        if (slider !== null) {\r\n            let len = slider.value\r\n            this.arrayVisualizer.updateArrLength(len)\r\n        }\r\n\r\n    }\r\n\r\n    toggleControlShow() {\r\n        // console.log(styles.controls)\r\n        let controlsContainer = document.getElementById(styles.controlsContainer)\r\n        let controls = document.getElementById(styles.controls)\r\n        let btn = document.getElementById(styles.showToggleBtn)\r\n        if (this.isControlShow) {\r\n            controls.style.display = \"none\"\r\n            controlsContainer.style.width = \"0\"\r\n            btn.innerHTML = \"&gt;&gt;\";\r\n        } else {\r\n            controls.style.display = \"block\"\r\n            controlsContainer.style.width = \"20rem\"\r\n            btn.innerHTML = \"&lt;&lt\";\r\n        }\r\n        this.isControlShow = !this.isControlShow\r\n    }\r\n\r\n    initArray(func) {\r\n        this.arrayVisualizer.initArray(func, this.arrayVisualizer.getArrLength(), true)\r\n    }\r\n\r\n    shuffleArray(func) {\r\n        this.stopSort()\r\n        this.arrayVisualizer.shuffleArray(func)\r\n        // func(this.arrayVisualizer)\r\n    }\r\n\r\n    sortArray(sortName) {\r\n        this.stopSort()\r\n        this.sorts.runSort(sortName, 0, this.arrayVisualizer.getArrLength() - 1)\r\n    }\r\n\r\n    stopSort() {\r\n        this.arrayVisualizer.stopSort()\r\n        // this.Delays.resetDelays()\r\n        // this.arrayVisualizer.nullify()\r\n    }\r\n\r\n    abortSort() {\r\n        this.stopSort()\r\n        this.initArray(initFunctions.linear)\r\n    }\r\n\r\n    genInitFunctions() {\r\n        // console.log(initFunctions)\r\n        let tmp = []\r\n        for (let i in initFunctions) {\r\n            tmp.push(\r\n                <button key={i} onClick={this.initArray.bind(this, initFunctions[i])}>{i}</button>\r\n            )\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    getSorts() {\r\n        let tmp = []\r\n        let sortsNames = this.sorts.getSortsPaths()\r\n        for (let i of sortsNames) {\r\n            tmp.push(\r\n                <button key={i} onClick={this.sortArray.bind(this, i)}>{i}</button>)\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    getShuffles() {\r\n        let tmp = []\r\n        for (let i in shuffles) {\r\n            tmp.push(\r\n                <button key={i} onClick={this.shuffleArray.bind(this, shuffles[i])}>{i}</button>\r\n            )\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    toggleShowAuxArrays() {\r\n        let element = document.getElementById(\"auxArrShowCB\")\r\n        this.arrayVisualizer.setShowAuxArrays(element.checked)\r\n    }\r\n\r\n    toggleBarsStroke() {\r\n        let element = document.getElementById(\"enableStrokeCB\")\r\n        this.arrayVisualizer.setEnableBarsStroke(element.checked)\r\n    }\r\n\r\n    toggleEnableMarks() {\r\n        let element = document.getElementById(\"enableMarksCB\")\r\n        this.arrayVisualizer.setEnableMarks(element.checked)\r\n    }\r\n\r\n    toggleVisualStyle(val) {\r\n        this.arrayVisualizer.setVisualStyle(val)\r\n    }\r\n\r\n    toggleRainbow(val){\r\n        this.arrayVisualizer.getMarks().setRainbow(val)\r\n    }\r\n\r\n    restoreArray(){\r\n        this.arrayVisualizer.restoreArray()\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div id={styles.controlsContainer}>\r\n                {/*<div onClick={this.toggleControlShow.bind(this)} id={styles.showToggleBtn}>&lt;&lt;</div>*/}\r\n                <div id={styles.controls}>\r\n                    <div>\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Array Size</div>\r\n                            <input id={styles.slider} type=\"range\" min=\"10\" max=\"500\"\r\n                                   defaultValue={this.arrayVisualizer.DEFAULT_ARR_LEN}\r\n                                   step=\"10\"\r\n                                   onChange={this.updateArrLength.bind(this)}/>\r\n                        </div>\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Visuals</div>\r\n                            <div style={{display: \"flex\", justifyContent:\"center\"}}>\r\n                                <div style={{textAlign: \"left\"}}>\r\n                                    <div className={styles.checkBoxContainer}>\r\n                                        <input onChange={this.toggleShowAuxArrays.bind(this)} type=\"checkbox\"\r\n                                               id=\"auxArrShowCB\"\r\n                                               name=\"auxArrShowCB\" defaultChecked={true}/>\r\n                                        <label htmlFor=\"auxArrShowCB\">Show Aux Arrays</label>\r\n                                    </div>\r\n                                    <div className={styles.checkBoxContainer}>\r\n                                        <input onChange={this.toggleBarsStroke.bind(this)} type=\"checkbox\"\r\n                                               id=\"enableStrokeCB\"\r\n                                               name=\"enableStrokeCB\" defaultChecked={true}/>\r\n                                        <label htmlFor=\"enableStrokeCB\">Enable Bars Stroke</label>\r\n                                    </div>\r\n                                    <div className={styles.checkBoxContainer}>\r\n                                        <input onChange={this.toggleEnableMarks.bind(this)} type=\"checkbox\"\r\n                                               id=\"enableMarksCB\"\r\n                                               name=\"enableMarksCB\" defaultChecked={true}/>\r\n                                        <label htmlFor=\"enableMarksCB\">Enable Marks(Disable to reduce lags)</label>\r\n                                    </div>\r\n                                    <div className={styles.checkBoxContainer}>\r\n                                        <button onClick={this.toggleRainbow.bind(this, true)}>Paint to Rainbow</button>\r\n                                        <button onClick={this.toggleRainbow.bind(this, false)}>Clear Color</button>\r\n                                    </div>\r\n                                </div>\r\n                            </div>\r\n                        </div>\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Visual Styles</div>\r\n                            <div>\r\n                                <input onChange={this.toggleVisualStyle.bind(this, \"bars\")} type=\"radio\"\r\n                                       id=\"barsRadioBtn\"\r\n                                       name=\"visualStyle\" value=\"bars\" defaultChecked={true}/>\r\n                                <label htmlFor=\"barsRadioBtn\">Bars</label>\r\n\r\n                                <input onChange={this.toggleVisualStyle.bind(this, \"dots\")} type=\"radio\"\r\n                                       id=\"dotsRadioBtn\"\r\n                                       name=\"visualStyle\" value=\"dots\"/>\r\n                                <label htmlFor=\"dotsRadioBtn\">Dots</label>\r\n                            </div>\r\n                        </div>\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Init Array</div>\r\n                            <div>{this.genInitFunctions()}</div>\r\n                            <div><button onClick={this.restoreArray.bind(this)}>RESTORE ARRAY</button></div>\r\n                        </div>\r\n\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Shuffle Array</div>\r\n                            <div>\r\n                                {/*<button onClick={this.shuffleArray.bind(this)}>Random</button>*/}\r\n                                <div>{this.getShuffles()}</div>\r\n                            </div>\r\n                        </div>\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Sort control</div>\r\n                            <div>\r\n                                <button onClick={this.abortSort.bind(this)}>Abort Sort(Recommended)</button>\r\n                                <button onClick={this.stopSort.bind(this)}>Stop Sort(Not Recommended)</button>\r\n                            </div>\r\n                        </div>\r\n                        <div>\r\n                            <div className={styles.sectionHeader}>Sort Array</div>\r\n                            <div>\r\n                                {this.getSorts()}\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}","export class Sounds{\r\n    arrayVisualizer\r\n    ctx\r\n    Delays\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.Delays = arrayVisualizer.getDelays()\r\n        this.ctx = new (window.AudioContext || window.webkitAudioContext)();\r\n    }\r\n    playSound(value) {\r\n        let osc = this.ctx.createOscillator();\r\n        osc.type = 'sine';\r\n\r\n        let k = value / this.arrayVisualizer.getArrLength()\r\n        osc.frequency.value = 2000 * k + 200;\r\n\r\n        let addTime = 50\r\n\r\n        let gainNode = this.ctx.createGain()\r\n        gainNode.gain.value = 0;\r\n        osc.connect(gainNode)\r\n        gainNode.connect(this.ctx.destination)\r\n        // console.log(this.Delays.getDelayInc())\r\n        gainNode.gain.linearRampToValueAtTime(0.05, this.ctx.currentTime + (this.Delays.getDelayInc() + addTime) / 1000 / 2)\r\n        gainNode.gain.linearRampToValueAtTime(0, this.ctx.currentTime + (this.Delays.getDelayInc() + addTime) / 1000)\r\n\r\n        osc.start();\r\n        osc.stop(this.ctx.currentTime + (this.Delays.getDelayInc() + addTime) / 1000);\r\n    }\r\n}","import {HSL2RGB, randomInt} from \"../utils/utils\";\r\n\r\nexport const colors = {\r\n    \"Unmarked\": [255, 255, 255],\r\n    \"Default\": [255, 0, 0],\r\n    \"Additional\": [randomInt(0, 256), randomInt(0, 256), randomInt(0, 256)],\r\n    \"Sorted\": [0, 255, 0],\r\n    \"Analysis\": [0, 0, 255]\r\n}\r\nexport class Marks{\r\n    arrayVisualizer\r\n    Delays\r\n\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.Delays = arrayVisualizer.getDelays()\r\n    }\r\n\r\n    mark(index, args, saveArr = true) {\r\n        if(!this.arrayVisualizer.getEnableMarks()){\r\n            return;\r\n        }\r\n        let type = \"Default\"\r\n        let color = colors[\"Default\"]\r\n        let tmpArr = this.arrayVisualizer.getMainArray()\r\n        // Additional\r\n        if (args.type === \"Additional\") {\r\n            type = \"Additional\"\r\n            color = args.color\r\n            // console.log(color)\r\n        }\r\n        //Default\r\n        else if (args.type === \"Default\") {\r\n            type = \"Default\"\r\n            color = colors[\"Default\"]\r\n        } else {\r\n            type = args.type\r\n            color = args.color\r\n            // console.log(color)\r\n        }\r\n\r\n        tmpArr[index].setType(type)\r\n        tmpArr[index].setMarkColor(color)\r\n        if (saveArr) {\r\n            this.arrayVisualizer.setState({\r\n                array: tmpArr\r\n            })\r\n        } else {\r\n            return tmpArr\r\n        }\r\n        // console.log(color);\r\n    }\r\n\r\n    markMany(indexes, args, saveArr) {\r\n        let tmpArr = this.arrayVisualizer.getMainArray()\r\n        for (let i of indexes) {\r\n            if (saveArr) {\r\n                this.mark(i, args, saveArr)\r\n            } else {\r\n                tmpArr = this.mark(i, args, saveArr)\r\n            }\r\n        }\r\n        if (!saveArr) {\r\n            return tmpArr\r\n        }\r\n    }\r\n\r\n    unmark(index, saveArr = true) {\r\n        let tmpArr = this.arrayVisualizer.getMainArray()\r\n        // tmpArr[index].setMarkColor(colors[\"Unmarked\"])\r\n        tmpArr[index].setType(\"Unmarked\")\r\n        if (saveArr) {\r\n            this.arrayVisualizer.setState({\r\n                array: tmpArr\r\n            })\r\n        } else {\r\n            return tmpArr\r\n        }\r\n    }\r\n\r\n    unmarkMany(indexes, saveArr, saveOnce) {\r\n        let tmpArr = this.arrayVisualizer.getMainArray()\r\n        for (let i of indexes) {\r\n            if (saveArr) {\r\n                this.unmark(i, saveArr)\r\n            } else {\r\n                tmpArr = this.unmark(i, saveArr)\r\n            }\r\n        }\r\n        if (saveOnce) {\r\n            this.arrayVisualizer.setState({\r\n                array: tmpArr\r\n            })\r\n        }\r\n        if (!saveArr) {\r\n            return tmpArr\r\n        }\r\n    }\r\n\r\n    setRainbow(val){\r\n        let tmpArr = this.arrayVisualizer.getMainArray()\r\n        if(val){\r\n            for(let i = 0; i < tmpArr.length; ++i){\r\n                let hsl = [i / tmpArr.length, 0.8, 0.5]\r\n                let rgb = HSL2RGB(hsl[0], hsl[1], hsl[2])\r\n                tmpArr[i].setColor(rgb)\r\n            }\r\n        }else{\r\n            for(let i of tmpArr){\r\n                i.setColor([255, 255, 255])\r\n            }\r\n        }\r\n        this.arrayVisualizer.setState({\r\n            array: tmpArr\r\n        })\r\n    }\r\n\r\n    markUnmarkMany(markIndexes, markArgs) {\r\n        this.markMany(markIndexes, markArgs, true)\r\n        this.Delays.push(setTimeout(this.unmarkMany.bind(this), this.Delays.incDelay(\"Unmark\", this.Delays.getDelayInc() / 500), markIndexes, false, true))\r\n    }\r\n\r\n    clearAllMarks(){\r\n        this.unmarkMany(Array.from(Array(this.arrayVisualizer.getArrLength()).keys()), false, true)\r\n    }\r\n\r\n}","import {Delays} from \"./Delays\";\r\nimport {Marks} from \"./Marks\";\r\nimport {Sounds} from \"./Sounds\";\r\n\r\nexport class Reads{\r\n    arrayVisualizer;\r\n    Sounds\r\n    Delays\r\n    Marks\r\n    constructor(arrayVisualizer){\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.Sounds = arrayVisualizer.getSounds()\r\n        this.Delays = arrayVisualizer.getDelays()\r\n        this.Marks = arrayVisualizer.getMarks()\r\n    }\r\n\r\n    readValue(index, arr = this.arrayVisualizer.getPseudoArray()) {\r\n        return arr[index].getValue()\r\n    }\r\n\r\n    compareInArr(a, b, arr = this.arrayVisualizer.getPseudoArray()) {\r\n        let curComparisons = this.arrayVisualizer.getState().comparisons + 1\r\n        this.arrayVisualizer.setState({\r\n            comparisons: curComparisons\r\n        })\r\n        this.compareWithDelay([a,b], [])\r\n        return this.compareValues(arr[a], arr[b])\r\n    }\r\n\r\n    get(index, arr = this.arrayVisualizer.getPseudoArray()){\r\n        return arr[index];\r\n    }\r\n\r\n    //TODO: add marks\r\n    compareValues(a, b){\r\n        let toMark = []\r\n        let toSound = []\r\n        let tmpA\r\n        let tmpB\r\n        if(typeof a === \"object\"){\r\n            tmpA = a.getValue()\r\n            let index = this.arrayVisualizer.getPseudoArray().findIndex(element => {return element.getValue() === tmpA})\r\n            if(index !== -1){\r\n                toMark.push(index)\r\n            }\r\n        }else{\r\n            tmpA = a\r\n        }\r\n\r\n        if(typeof b === \"object\"){\r\n            tmpB = b.getValue()\r\n            let index = this.arrayVisualizer.getPseudoArray().findIndex(element => {return element.getValue() === tmpB})\r\n            if(index !== -1) {\r\n                toMark.push(index)\r\n            }\r\n        }else{\r\n            tmpB = b\r\n        }\r\n\r\n        toSound = [tmpA, tmpB]\r\n\r\n        // let tmpA = typeof a === \"object\" ? a.getValue() : a\r\n        // let tmpB = typeof b === \"object\" ? b.getValue() : b\r\n\r\n        this.compareWithDelay(toMark, toSound)\r\n        return tmpA - tmpB;\r\n    }\r\n\r\n    compareWithDelay(toMark, toSound, delay = this.Delays.getDelayInc()/5){\r\n        this.Delays.push(setTimeout(this.compareStub.bind(this), this.Delays.incDelay(\"Write\", delay), toMark, toSound))\r\n    }\r\n\r\n    compareStub(toMark = [], toSound = []){\r\n        let curComparisons = this.arrayVisualizer.getState().comparisons + 1\r\n        this.arrayVisualizer.setState({\r\n            comparisons: curComparisons\r\n        })\r\n        for(let i of toSound){\r\n            this.Sounds.playSound(i)\r\n        }\r\n        // console.log(toMark)\r\n        // this.Marks.markUnmarkMany(toMark,{type: \"Additional\", color: [0,255,0]})\r\n        this.Marks.markUnmarkMany(toMark,{type: \"Default\"})\r\n    }\r\n\r\n    auxGet(index, arrIndex, isPseudo = true){\r\n        if(isPseudo){\r\n            return this.arrayVisualizer.getPseudoAuxArrays()[arrIndex][index]\r\n        }else {\r\n            return this.arrayVisualizer.getAuxArrays()[arrIndex][index]\r\n        }\r\n    }\r\n\r\n\r\n    auxReadValue(index, arrIndex, isPseudo = true){\r\n        if(isPseudo){\r\n            return this.arrayVisualizer.getPseudoAuxArrays()[arrIndex][index].getValue()\r\n        }else {\r\n            return this.arrayVisualizer.getAuxArrays()[arrIndex][index].getValue()\r\n        }\r\n    }\r\n}","import React from 'react';\r\nimport {arraysEquals, deepArrayCopy, getAllMethods, objLength, randomInt} from \"../utils/utils\";\r\nimport {Sorts} from \"../Sorts/Sorts\"\r\nimport {ArrayWindow} from \"../ArrayWindow/ArrayWindow\";\r\nimport {Element} from \"../classes/Element\";\r\nimport {Stats} from \"../Stats/Stats\";\r\nimport {Controls} from \"../Controls/Controls\";\r\nimport {initFunctions} from \"../utils/initFunctions\";\r\nimport {Delays} from \"../ArrayAccess/Delays\";\r\nimport {Sounds} from \"../ArrayAccess/Sounds\";\r\nimport {Marks} from \"../ArrayAccess/Marks\";\r\nimport {Reads} from \"../ArrayAccess/Reads\";\r\nimport {Writes} from \"../ArrayAccess/Writes\";\r\n\r\nconst colors = {\r\n    \"Unmarked\": [255, 255, 255],\r\n    \"Default\": [255, 0, 0],\r\n    \"Additional\": [randomInt(0, 256), randomInt(0, 256), randomInt(0, 256)],\r\n    \"Sorted\": [0, 255, 0],\r\n    \"Analysis\": [0, 0, 255]\r\n}\r\n\r\nexport class ArrayVisualizer extends React.Component {\r\n    delays;\r\n    delayInc;\r\n    pseudoArray;\r\n    pseudoAuxArrays;\r\n\r\n    Sorts\r\n    delayIncConst\r\n    showAuxArrays\r\n    enableBarsStroke\r\n    visualStyle\r\n    enableMarks\r\n\r\n    Delays\r\n    Sounds\r\n    Marks\r\n    Reads\r\n    Writes\r\n\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.DEFAULT_ARR_LEN = 100\r\n        this.state = {\r\n            array: this.initArray(initFunctions.linear, this.DEFAULT_ARR_LEN),\r\n            sortName: \"\",\r\n            comparisons: 0,\r\n            maiWrites: 0,\r\n            auxWrites: 0,\r\n            auxArrays: {}\r\n        }\r\n        this.pseudoArray = deepArrayCopy(this.state.array)\r\n        this.Delays = new Delays(this)\r\n        this.Sounds = new Sounds(this)\r\n        this.Marks = new Marks(this)\r\n        this.Reads = new Reads(this)\r\n\r\n        this.prevArray = []\r\n\r\n        this.Writes = new Writes(this)\r\n        this.pseudoAuxArrays = []\r\n        this.Sorts = new Sorts(this);\r\n        this.showAuxArrays = true\r\n        this.enableBarsStroke = true\r\n        this.enableMarks = true\r\n        this.visualStyle = {\r\n            // style: \"bars\",\r\n            style: \"bars\",\r\n            barsStroke: true,\r\n        }\r\n    }\r\n\r\n    initArray(func, length, setToState=false) {\r\n        let arr = []\r\n        for (let i = 0; i < length; ++i) {\r\n            let element = new Element(func(i, length), \"Unmarked\", [255, 255, 255], [0,0,0,0])\r\n            arr.push(element)\r\n        }\r\n        if(setToState){\r\n            this.setState({\r\n                array: arr\r\n            })\r\n        }else {\r\n            return arr;\r\n        }\r\n    }\r\n\r\n    nullify() {\r\n        this.Delays.resetDelays()\r\n        this.setState(\r\n            {\r\n                comparisons: 0,\r\n                mainWrites: 0,\r\n                auxWrites: 0\r\n            }\r\n        )\r\n        // eslint-disable-next-line react/no-direct-mutation-state\r\n        this.state.writes = 0;\r\n        // eslint-disable-next-line react/no-direct-mutation-state\r\n        this.state.comparisons = 0;\r\n    }\r\n\r\n    setShowAuxArrays(val){\r\n        this.showAuxArrays = val\r\n    }\r\n\r\n    setEnableBarsStroke(val){\r\n        this.visualStyle.barsStroke = val;\r\n        this.forceMainArrayUpdate()\r\n    }\r\n\r\n    setVisualStyle(val){\r\n        this.visualStyle.style = val;\r\n        this.forceMainArrayUpdate()\r\n    }\r\n\r\n    setEnableMarks(val){\r\n        this.enableMarks = val;\r\n        if(!val){\r\n            this.Marks.clearAllMarks()\r\n        }\r\n    }\r\n\r\n    getEnableMarks(){\r\n        return this.enableMarks;\r\n    }\r\n\r\n    getArrayVisualizer() {\r\n        return this;\r\n    }\r\n\r\n    getPseudoArray() {\r\n        return this.pseudoArray;\r\n    }\r\n\r\n    getState(){\r\n        return this.state\r\n    }\r\n\r\n    getArrLength(){\r\n        return this.state.array.length;\r\n    }\r\n\r\n    getMainArray(){\r\n        return this.state.array\r\n    }\r\n\r\n    getPseudoAuxArrays(){\r\n        return this.pseudoAuxArrays\r\n    }\r\n\r\n    getDelays(){\r\n        return this.Delays\r\n    }\r\n\r\n    getSounds(){\r\n        return this.Sounds;\r\n    }\r\n\r\n    getMarks(){\r\n        return this.Marks;\r\n    }\r\n\r\n    getAuxArrays(){\r\n        return this.state.auxArrays\r\n    }\r\n\r\n    getReads(){\r\n        return this.Reads;\r\n    }\r\n\r\n    getWrites(){\r\n        return this.Writes\r\n    }\r\n\r\n\r\n    stopSort(){\r\n        // this.resetDelay()\r\n        this.Delays.resetDelays()\r\n        this.Marks.clearAllMarks()\r\n        this.setState({\r\n                auxArrays: []\r\n            }\r\n        )\r\n    }\r\n\r\n    shuffleArray(func) {\r\n        this.nullify()\r\n        this.setState({\r\n            sortName: \"Shuffle\"\r\n        })\r\n        this.backupArray()\r\n        func(this);\r\n        // let instructions = func(this);\r\n        // for(let i of instructions){\r\n        //     if(i.cmd === \"swap\"){\r\n        //         this.Writes.swapWithDelay(i.a, i.b, this.state.array, true, this.Delays.getDelayInc()/5, true)\r\n        //     }\r\n        // }\r\n\r\n    }\r\n\r\n    restoreArray(){\r\n        this.setState({\r\n            array: deepArrayCopy(this.prevArray)\r\n        })\r\n    }\r\n\r\n    backupArray(){\r\n        this.prevArray = deepArrayCopy(this.state.array)\r\n    }\r\n\r\n\r\n    setSortName(sortName){\r\n        this.setState({\r\n            sortName: sortName\r\n        })\r\n    }\r\n\r\n    initPseudoArray(){\r\n        this.pseudoArray = deepArrayCopy(this.state.array)\r\n    }\r\n\r\n    sortClickEvent() {\r\n    }\r\n\r\n    forceMainArrayUpdate(){\r\n        let tmp = this.state.array;\r\n        this.setState({\r\n            array: tmp\r\n        })\r\n    }\r\n\r\n    updateDelayInc(val){\r\n        this.delayInc = val/this.getArrLength();\r\n    }\r\n\r\n    updateArrLength(len){\r\n        this.setState({\r\n            array: this.initArray(initFunctions.linear, len)\r\n        })\r\n        this.pseudoArray = deepArrayCopy(this.state.array)\r\n\r\n        this.Sorts.arrLength = this.getArrLength()\r\n        // this.updateDelayInc(this.delayIncConst)\r\n        this.Delays.updateDelayInc();\r\n    }\r\n\r\n    genArrayWindows(){\r\n        let tmp = []\r\n        if(this.showAuxArrays) {\r\n            for (let i = objLength(this.state.auxArrays) - 1; i >= 0; i--) {\r\n                tmp.push(\r\n                    <ArrayWindow key={objLength(this.state.auxArrays) - i} array={this.state.auxArrays[i]}\r\n                                 mainArray={this.state.array} height={100 / (1 + objLength(this.state.auxArrays))} visualProps = {this.visualStyle} />\r\n                )\r\n            }\r\n        }\r\n        return tmp\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <Stats sortName={this.state.sortName} comparisons={this.state.comparisons} mainWrites={this.state.mainWrites} auxWrites={this.state.auxWrites} arrLength={this.getArrLength()}/>\r\n                <div style={{height: \"100vh\"}}>\r\n                {/*<div>*/}\r\n                    {this.genArrayWindows()}\r\n                    <ArrayWindow array={this.state.array} mainArray={this.state.array} height={this.showAuxArrays ? 100/(1+objLength(this.state.auxArrays)) : 100} visualProps={this.visualStyle}/>\r\n                </div>\r\n                <div>\r\n                    <Controls arrayVisualizer={this} sorts={this.Sorts}/>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport {ArrayVisualizer} from \"./components/ArrayVisualizer/ArrayVisualizer\";\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\n\r\n\r\n\r\n\r\n\r\nReactDOM.render(\r\n    <ArrayVisualizer></ArrayVisualizer>,\r\n  document.getElementById('root')\r\n);\r\n\r\n\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}