{"version":3,"sources":["components/Sorts/Sort.js","components/Controls/Controls.module.scss","components/ArrayWindow/ArrayWindow.module.scss","components/Sorts/Sorts.js","components/Stats/Stats.module.scss","components/Sorts sync /^/.*/.js$","components/Sorts/BubbleSort.js","components/Sorts/HeapSort.js","components/Sorts/InsertionSort.js","components/Sorts/LLQuickSort.js","components/Sorts/MergeSort.js","components/Sorts/PseudoTimSort.js","components/Sorts/SelectionSort.js","components/Sorts/SlowSort.js","components/Sorts/StoogeSort.js","components/Sorts/TimSort.js","components/Sorts/TimSortOrig.js","components/Sorts/TimSortPartalWorking.js","components/Sorts/timsortnotworking.js","components/classes/Element.js","components/utils/utils.js","components/ArrayWindow/ArrayWindow.js","components/Stats/Stats.js","components/utils/initFunctions.js","components/utils/shuffles.js","components/Controls/Controls.js","components/ArrayVisualizer/ArrayVisualizer.js","reportWebVitals.js","index.js"],"names":["Sort","arrayVisualizer","this","state","getState","compare","bind","swap","read","write","createAuxArray","removeAuxArray","auxRead","auxWrite","arrLength","getArrLength","sortName","warnLen","isDisabled","low","high","bucketsNum","module","exports","Sorts","sortsPaths","sortPath","require","sort","getSortObject","getWarnLen","window","confirm","initPseudoArray","setSortName","getSortName","runSort","sortClickEvent","map","webpackContext","req","id","webpackContextResolve","__webpack_require__","o","e","Error","code","keys","Object","resolve","BubbleSort","len","i","j","HeapSort","n","largest","l","r","heapify","Math","trunc","InsertionSort","length","key","LLQuickSort","lo","hi","pivot","p","partition","MergeSort","mid","leftArrayLen","rightArrayLen","leftArrayIndex","rightArrayIndex","leftIndex","rightIndex","merge","PseudoTimSort","MIN_MERGE","left","right","temp","m","len1","len2","x","k","minRun","minRunLength","insertionSort","min","size","timSort","SelectionSort","minIndex","SlowSort","floor","StoogeSort","t","TimSort","minGallop","tmpStorageLength","tmp","stackLength","runStart","Array","runLength","stackSize","runHi","reverseRun","start","value","isAux","hint","lastOffset","maxOffset","offset","mergeAt","start1","length1","start2","length2","gallopRight","gallopLeft","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","customCursor","customDest","remaining","makeAscendingRun","binaryInsertionSort","force","pushRun","mergeRuns","forceMergeRuns","results","POWERS_OF_TEN","log10","alphabeticalCompare","a","b","al","bl","aStr","String","bStr","array","pivotIndex","tmpIndex","isArray","TypeError","ts","MIN_GALLOP","runBase","runLen","rangeCheck","nRemaining","initRunLen","countRunAndMakeAscending","binarySort","runLenVar","mergeCollapse","mergeForceCollapse","reverseRange","runBaseArg","runLenArg","base1","base2","mergeLo","mergeHi","base","lastOfs","ofs","maxOfs","outer","console","log","arrayLen","fromIndex","toIndex","Element","type","color","randomInt","random","deepArrayCopy","arr","out","getValue","getType","getColor","push","arraysEquals","every","v","ArrayWindow","props","mainArray","height","styleSheet","backgroundColor","style","className","styles","bar","width","arrayContainer","Stats","statsContainer","writes","initFunctions","linear","reverse","pipeOrgan","inversedPipeOrgan","shuffles","fullShuffle","instructions","randomIndex","cmd","almostSorted","randomIndexA","randomIndexB","Controls","DEFAULT_ARR_LEN","isControlShow","sorts","updateArrLength","initArray","slider","document","getElementById","controlsContainer","controls","btn","showToggleBtn","display","innerHTML","func","shuffleArray","stopSort","onClick","sortsNames","getSortsPaths","sortArray","element","setShowAuxArrays","checked","textCenter","max","defaultValue","step","onChange","toggleShowAuxArrays","name","defaultChecked","htmlFor","genInitFunctions","getShuffles","abortSort","getSorts","React","Component","colors","ArrayVisualizer","comparisons","auxArrays","delays","Swap","Write","Comp","Unmark","CreateAuxArray","RemoveAuxArray","delayIncConst","timeoutArray","pseudoArray","pseudoAuxArrays","delayInc","showAuxArrays","ctx","AudioContext","webkitAudioContext","osc","createOscillator","frequency","gainNode","createGain","gain","connect","destination","linearRampToValueAtTime","currentTime","stop","clearTimeout","resetDelay","setState","index","args","saveArr","tmpArr","setType","setColor","indexes","mark","saveOnce","unmark","markIndexes","markArgs","markMany","setTimeout","unmarkMany","delay","playSound","swapInArr","markUnmarkMany","curWrites","setValue","writeInArr","sign","curComparisons","isPseudo","auxArrIndex","splice","arrIndex","val","from","setToState","nullify","includes","arrName","getNameByArray","arrNameInv","inverseArrayName","getArrayByName","swapWithDelay","writeWithDelay","auxWriteWithDelay","createAuxArrayWithDelay","removeAuxArrayWithDelay","updateDelayInc","genArrayWindows","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render"],"mappings":"2LAAaA,EAAb,WAoBI,WAAYC,GAAkB,oBAC1BC,KAAKD,gBAAkBA,EACvBC,KAAKC,MAAQD,KAAKD,gBAAgBG,WAClCF,KAAKG,QAAUH,KAAKD,gBAAgBI,QAAQC,KAAKL,GACjDC,KAAKK,KAAOL,KAAKD,gBAAgBM,KAAKD,KAAKL,GAC3CC,KAAKM,KAAON,KAAKD,gBAAgBO,KAAKF,KAAKL,GAC3CC,KAAKO,MAAQP,KAAKD,gBAAgBQ,MAAMH,KAAKL,GAC7CC,KAAKQ,eAAiBR,KAAKD,gBAAgBS,eAAeJ,KAAKL,GAC/DC,KAAKS,eAAiBT,KAAKD,gBAAgBU,eAAeL,KAAKL,GAC/DC,KAAKU,QAAUV,KAAKD,gBAAgBW,QAAQN,KAAKL,GACjDC,KAAKW,SAAWX,KAAKD,gBAAgBY,SAASP,KAAKL,GACnDC,KAAKY,UAAYZ,KAAKD,gBAAgBc,eACtCb,KAAKc,SAAW,GAChBd,KAAKe,SAAW,EAChBf,KAAKgB,YAAa,EAlC1B,+CAqCI,WACI,OAAOhB,KAAKc,WAtCpB,wBAyCI,WACI,OAAOd,KAAKe,UA1CpB,qBA6CI,SAAQE,EAAKC,EAAMC,QA7CvB,M,gBCCAC,EAAOC,QAAU,CAAC,WAAa,6BAA6B,SAAW,2BAA2B,cAAgB,gCAAgC,OAAS,2B,qBCA3JD,EAAOC,QAAU,CAAC,eAAiB,oCAAoC,IAAM,2B,6FCDhEC,EAAb,WAII,WAAYvB,GAAkB,oBAC1BC,KAAKD,gBAAkBA,EACvBC,KAAKuB,WAAa,CAAC,aAAc,YAAa,cAAe,gBAAiB,gBAAiB,UAAW,gBAAiB,WAAY,WAAY,cAN3J,iDASI,WACI,OAAOvB,KAAKuB,aAVpB,2BAaI,SAAcC,GAEV,OAAO,IAAI1B,EADA2B,MAAQ,KAAOD,EAAW,OAAOA,IAC5BxB,KAAKD,mBAf7B,qBAkBI,SAAQe,EAAUG,EAAKC,EAAMC,GACzB,IAAIO,EAAO1B,KAAK2B,cAAcb,GAC1BC,EAAUW,EAAKE,cACF,IAAbb,GAAkBf,KAAKD,gBAAgBc,eAAiBE,IAAYc,OAAOC,QAAQ,8BAAgC9B,KAAKD,gBAAgBc,eAArD,2BACxDE,EAAU,sDAGzCf,KAAKD,gBAAgBgC,kBACrB/B,KAAKD,gBAAgBiC,YAAYN,EAAKO,eACtCP,EAAKQ,QAAQjB,EAAKC,EAAMC,GACxBnB,KAAKD,gBAAgBoC,sBA5B7B,M,iBCCAf,EAAOC,QAAU,CAAC,eAAiB,gC,uCCDnC,IAAIe,EAAM,CACT,kBAAmB,GACnB,gBAAiB,GACjB,qBAAsB,GACtB,mBAAoB,GACpB,iBAAkB,GAClB,qBAAsB,GACtB,qBAAsB,GACtB,gBAAiB,GACjB,YAAa,EACb,aAAc,GACd,kBAAmB,GACnB,eAAgB,GAChB,mBAAoB,GACpB,4BAA6B,GAC7B,yBAA0B,IAI3B,SAASC,EAAeC,GACvB,IAAIC,EAAKC,EAAsBF,GAC/B,OAAOG,EAAoBF,GAE5B,SAASC,EAAsBF,GAC9B,IAAIG,EAAoBC,EAAEN,EAAKE,GAAM,CACpC,IAAIK,EAAI,IAAIC,MAAM,uBAAyBN,EAAM,KAEjD,MADAK,EAAEE,KAAO,mBACHF,EAEP,OAAOP,EAAIE,GAEZD,EAAeS,KAAO,WACrB,OAAOC,OAAOD,KAAKV,IAEpBC,EAAeW,QAAUR,EACzBpB,EAAOC,QAAUgB,EACjBA,EAAeE,GAAK,I,+GClCPU,EAAb,kDACI,WAAYlD,GAAkB,IAAD,8BACzB,cAAMA,IACDe,SAAW,aAFS,EADjC,8CAKI,WAEI,IADA,IAAIoC,EAAMlD,KAAKY,UACNuC,EAAI,EAAGA,EAAID,EAAKC,IACrB,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAMC,EAAI,EAAGC,IACzBpD,KAAKG,QAAQiD,EAAGA,EAAI,EAAG,MACvBpD,KAAKK,KAAK+C,EAAGA,EAAI,KAVrC,qBAgBI,SAAQnC,EAAKC,GACTlB,KAAKiD,WAAWhC,EAAKC,OAjB7B,G,KAAgCpB,O,6GCAnBuD,EAAb,kDACI,WAAYtD,GAAkB,IAAD,8BACzB,cAAMA,IACDe,SAAW,WAFS,EADjC,2CAMI,SAAQwC,EAAGH,GACP,IAAII,EAAUJ,EAEVK,EAAI,EAAIL,EAAI,EACZM,EAAI,EAAIN,EAAI,EAEZK,EAAIF,GAAKtD,KAAKG,QAAQqD,EAAGD,EAAS,OAClCA,EAAUC,GAEVC,EAAIH,GAAKtD,KAAKG,QAAQsD,EAAGF,EAAS,OAClCA,EAAUE,GAGVF,IAAYJ,IACZnD,KAAKK,KAAK8C,EAAGI,GACbvD,KAAK0D,QAAQJ,EAAGC,MArB5B,sBAyBI,WAII,IAHA,IAAID,EAAItD,KAAKY,UAGJuC,EAAIQ,KAAKC,MAAMN,EAAI,GAAK,EAAGH,GAAK,EAAGA,IACxCnD,KAAK0D,QAAQJ,EAAGH,GAGpB,IAAK,IAAIA,EAAIG,EAAI,EAAGH,GAAK,EAAGA,IACxBnD,KAAKK,KAAK,EAAG8C,GACbnD,KAAK0D,QAAQP,EAAG,KAnC5B,qBAuCI,SAAQlC,EAAKC,GACTlB,KAAKqD,SAASpC,EAAKC,OAxC3B,G,KAA8BpB,O,kHCAjB+D,EAAb,kDACI,WAAY9D,GAAkB,IAAD,8BACzB,cAAMA,IACDe,SAAW,gBAFS,EADjC,iDAMI,WAEI,IADA,IAAIgD,EAAS9D,KAAKY,UACTuC,EAAI,EAAGA,EAAIW,EAAQX,IAAK,CAG7B,IAFA,IAAIY,EAAM/D,KAAKM,KAAK6C,GAChBC,EAAID,EAAI,EACLC,GAAK,GAAKpD,KAAKM,KAAK8C,GAAKW,GAC5B/D,KAAKO,MAAM6C,EAAI,EAAGpD,KAAKM,KAAK8C,IAC5BA,GAAQ,EAEZpD,KAAKO,MAAM6C,EAAI,EAAGW,MAf9B,qBAmBI,SAAQ9C,EAAKC,GACTlB,KAAK6D,cAAc5C,EAAKC,OApBhC,G,KAAmCpB,O,gHCAtBkE,EAAb,kDACI,WAAYjE,GAAkB,IAAD,8BACzB,cAAMA,IACDe,SAAW,cAFS,EADjC,6CAKI,SAAUmD,EAAIC,GAGV,IAFA,IAAIC,EAAQD,EACRf,EAAIc,EACCb,EAAIa,EAAIb,EAAIc,EAAId,IACjBpD,KAAKG,QAAQiD,EAAGe,EAAO,OACvBnE,KAAKK,KAAK8C,EAAGC,GACbD,KAIR,OADAnD,KAAKK,KAAK8C,EAAGe,GACNf,IAff,yBAkBI,SAAYc,EAAIC,GACZ,GAAID,EAAKC,EAAI,CACT,IAAIE,EAAIpE,KAAKqE,UAAUJ,EAAIC,GAC3BlE,KAAKgE,YAAYC,EAAIG,EAAI,GACzBpE,KAAKgE,YAAYI,EAAI,EAAGF,MAtBpC,qBAyBI,SAAQjD,EAAKC,GACTlB,KAAKgE,YAAY/C,EAAKC,OA1B9B,G,KAAiCpB,O,8GCApBwE,EAAb,kDACI,WAAYvE,GAAkB,IAAD,8BACzB,cAAMA,IACDe,SAAW,YAFS,EADjC,yCAKI,SAAMG,EAAKsD,EAAKrD,GAUZ,IANA,IAAIsD,EAAeD,EAAMtD,EAAM,EAC3BwD,EAAgBvD,EAAOqD,EAEvBG,EAAiB1E,KAAKQ,eAAegE,GACrCG,EAAkB3E,KAAKQ,eAAeiE,GAEjCtB,EAAI,EAAGA,EAAIqB,EAAcrB,IAE9BnD,KAAKW,SAASwC,EAAGnD,KAAKM,KAAKW,EAAMkC,GAAIuB,GAEzC,IAAK,IAAIvB,EAAI,EAAGA,EAAIsB,EAAetB,IAE/BnD,KAAKW,SAASwC,EAAGnD,KAAKM,KAAKiE,EAAMpB,EAAI,GAAIwB,GAM7C,IAHA,IAAIC,EAAY,EACZC,EAAa,EAER1B,EAAIlC,EAAKkC,EAAIjC,EAAO,EAAGiC,IACxByB,EAAYJ,GAAgBK,EAAaJ,EAErCzE,KAAKU,QAAQkE,EAAWF,GAAkB1E,KAAKU,QAAQmE,EAAYF,IACnE3E,KAAKO,MAAM4C,EAAGnD,KAAKU,QAAQkE,EAAWF,IACtCE,MAEA5E,KAAKO,MAAM4C,EAAGnD,KAAKU,QAAQmE,EAAYF,IACvCE,KAEGD,EAAYJ,GACnBxE,KAAKO,MAAM4C,EAAGnD,KAAKU,QAAQkE,EAAWF,IACtCE,KACOC,EAAaJ,IACpBzE,KAAKO,MAAM4C,EAAGnD,KAAKU,QAAQmE,EAAYF,IACvCE,KAKR7E,KAAKS,eAAekE,GACpB3E,KAAKS,eAAeiE,KAhD5B,uBAmDI,SAAUzD,EAAKC,GACX,KAAIA,GAAQD,GAAZ,CAEA,IAAIsD,EAAMZ,KAAKC,OAAO3C,EAAMC,GAAQ,GACpClB,KAAKsE,UAAUrD,EAAKsD,GACpBvE,KAAKsE,UAAUC,EAAM,EAAGrD,GACxBlB,KAAK8E,MAAM7D,EAAKsD,EAAKrD,MAzD7B,qBA4DI,SAAQD,EAAKC,GACTlB,KAAKsE,UAAUrD,EAAKC,OA7D5B,G,KAA+BpB,O,kHCAlBiF,EAAb,kDAEI,WAAYhF,GAAkB,IAAD,8BACzB,cAAMA,IACDe,SAAW,gBAChB,EAAKkE,UAAY,GAHQ,EAFjC,gDAQI,SAAa1B,GAET,IADA,IAAIG,EAAI,EACDH,GAAKtD,KAAKgF,WAEbvB,GAAU,EAAJH,EACNA,IAAM,EAEV,OAAOA,EAAIG,IAfnB,2BAkBI,SAAcwB,EAAMC,GAChB,IAAK,IAAI/B,EAAI8B,EAAO,EAAG9B,GAAK+B,EAAO/B,IAAK,CAGpC,IAFA,IAAIgC,EAAOnF,KAAKM,KAAK6C,GACjBC,EAAID,EAAI,EACLC,GAAK6B,GAAQjF,KAAKM,KAAK8C,GAAK+B,GAC/BnF,KAAKO,MAAM6C,EAAI,EAAGpD,KAAKM,KAAK8C,IAC5BA,IAEJpD,KAAKO,MAAM6C,EAAI,EAAG+B,MA1B9B,mBA8BI,SAAM3B,EAAG4B,EAAG3B,GAIR,IAHA,IAAI4B,EAAOD,EAAI5B,EAAI,EAAG8B,EAAO7B,EAAI2B,EAC7BH,EAAOjF,KAAKQ,eAAe6E,GAC3BH,EAAQlF,KAAKQ,eAAe8E,GACxBC,EAAI,EAAGA,EAAIF,EAAME,IAGrBvF,KAAKW,SAAS4E,EAAGvF,KAAKM,KAAKkD,EAAE+B,GAAIN,GAErC,IAAI,IAAIM,EAAI,EAAGA,EAAID,EAAMC,IAGrBvF,KAAKW,SAAS4E,EAAGvF,KAAKM,KAAK8E,EAAI,EAAIG,GAAIL,GAO3C,IAJA,IAAI/B,EAAI,EACJC,EAAI,EACJoC,EAAIhC,EAEDL,EAAIkC,GAAQjC,EAAIkC,GAGhBtF,KAAKU,QAAQyC,EAAG8B,IAASjF,KAAKU,QAAQ0C,EAAG8B,IAGxClF,KAAKO,MAAMiF,EAAGxF,KAAKU,QAAQyC,EAAG8B,IAC9B9B,MAKAnD,KAAKO,MAAMiF,EAAGxF,KAAKU,QAAQ0C,EAAG8B,IAC9B9B,KAEJoC,IAGJ,KAAOrC,EAAIkC,GAEPrF,KAAKO,MAAMiF,EAAGxF,KAAKU,QAAQyC,EAAG8B,IAC9BO,IACArC,IAGJ,KAAOC,EAAIkC,GACPtF,KAAKO,MAAMiF,EAAGxF,KAAKU,QAAQ0C,EAAG8B,IAC9BM,IACApC,IAEJpD,KAAKS,eAAeyE,GACpBlF,KAAKS,eAAewE,KAhF5B,qBAmFI,SAAQ3B,GAIJ,IAFA,IAAImC,EAASzF,KAAK0F,aAAa1F,KAAKgF,WAE5B7B,EAAI,EAAGA,EAAIG,EAAGH,GAAKsC,EAEvBzF,KAAK2F,cAAcxC,EAAGQ,KAAKiC,IACtBzC,EAAInD,KAAKgF,UAAY,EAAK1B,EAAI,IAGvC,IAAI,IAAIuC,EAAOJ,EAAQI,EAAOvC,EAAGuC,GAAO,EACpC,IAAI,IAAIZ,EAAO,EAAGA,EAAO3B,EAAG2B,GAAQ,EAAIY,EAAM,CAC1C,IAAItB,EAAMU,EAAOY,EAAO,EACpBX,EAAQvB,KAAKiC,IAAKX,EAAO,EAAIY,EAAO,EAAKvC,EAAI,GAC9CiB,EAAMW,GACLlF,KAAK8E,MAAMG,EAAMV,EAAKW,MAlG1C,qBAwGI,SAAQjE,EAAKC,GACTlB,KAAK8F,QAAQ5E,EAAK,OAzG1B,G,KAAmCpB,O,kHCAtBiG,EAAb,kDACI,WAAYhG,GAAkB,IAAD,8BACzB,cAAMA,IACDe,SAAW,gBAFS,EADjC,iDAMI,WACI,IAAK,IAAIqC,EAAE,EAAGA,EAAInD,KAAKY,UAAWuC,IAAK,CAEnC,IADA,IAAI6C,EAAW7C,EACNC,EAAED,EAAGC,EAAIpD,KAAKY,UAAWwC,IAC1BpD,KAAKG,QAAQiD,EAAG4C,EAAU,OAC1BA,EAAW5C,GAIfpD,KAAKG,QAAQgD,EAAG6C,EAAU,MAC1BhG,KAAKK,KAAK8C,EAAG6C,MAhB7B,qBAqBI,SAAQ/E,EAAKC,GACTlB,KAAK+F,cAAc9E,EAAKC,OAtBhC,G,KAAmCpB,O,6GCAtBmG,EAAb,kDACI,WAAYlG,GAAkB,IAAD,8BACzB,cAAMA,IACDe,SAAW,WAChB,EAAKC,QAAU,IAHU,EADjC,4CAOI,SAASoC,EAAGC,GACR,KAAID,GAAKC,GAAT,CAGA,IAAIgC,EAAIzB,KAAKuC,OAAO/C,EAAIC,GAAK,GAC7BpD,KAAKiG,SAAS9C,EAAGiC,GACjBpF,KAAKiG,SAASb,EAAI,EAAGhC,GACjBpD,KAAKG,QAAQiD,EAAGgC,EAAG,MACnBpF,KAAKK,KAAK+C,EAAGgC,GAEjBpF,KAAKiG,SAAS9C,EAAGC,EAAI,MAjB7B,qBAoBI,SAAQnC,EAAKC,GACTlB,KAAKiG,SAAShF,EAAKC,OArB3B,G,KAA8BpB,O,+GCAjBqG,EAAb,kDACI,WAAYpG,GAAkB,IAAD,8BACzB,cAAMA,IACDe,SAAW,aAFS,EADjC,8CAMI,SAAWqC,EAAGC,GAIV,GAHIpD,KAAKG,QAAQgD,EAAGC,EAAG,MACnBpD,KAAKK,KAAK8C,EAAGC,GAEbA,EAAID,EAAI,EAAG,CACX,IAAIiD,EAAIzC,KAAKC,OAAOR,EAAID,EAAI,GAAK,GACjCnD,KAAKmG,WAAWhD,EAAGC,EAAIgD,GACvBpG,KAAKmG,WAAWhD,EAAIiD,EAAGhD,GACvBpD,KAAKmG,WAAWhD,EAAGC,EAAIgD,MAdnC,qBAkBI,SAAQnF,EAAKC,GACTlB,KAAKmG,WAAWlF,EAAKC,OAnB7B,G,KAAgCpB,O,mHC6IzB,IAAMuG,EAAb,kDACI,WAAYtG,GAAkB,IAAD,8BACzB,cAAMA,IAEDuG,UAzIiB,EA2ItB,EAAKC,iBAAmB,EAAK3F,UAAY,IACnC,EAAKA,YAAc,EAtIE,IA0I3B,EAAK4F,IAAM,EAAKhG,eAAe,EAAK+F,kBAEpC,EAAKE,YAAc,EAAK7F,UAAY,IAC9B,EACA,EAAKA,UAAY,KACb,GACA,EAAKA,UAAY,OACb,GACA,GAEd,EAAK8F,SAAW,IAAIC,MAAM,EAAKF,aAC/B,EAAKG,UAAY,IAAID,MAAM,EAAKF,aAEhC,EAAKI,UAAY,EACjB,EAAK/F,SAAW,UAxBS,EADjC,oDA4BI,SAAiBmD,EAAIC,GACjB,IAAI4C,EAAQ7C,EAAK,EAEjB,GAAI6C,IAAU5C,EACV,OAAO,EAKX,GAAIlE,KAAKG,QAAQ2G,IAAS7C,EAAI,KAAM,CAEhC,KAAO6C,EAAQ5C,GAAMlE,KAAKG,QAAQ2G,EAAOA,EAAQ,EAAG,MAChDA,IAIJ9G,KAAK+G,WAAW9C,EAAI6C,QAKpB,KAAOA,EAAQ5C,GAAMlE,KAAKG,QAAQ2G,EAAOA,EAAQ,EAAG,OAChDA,IAIR,OAAOA,EAAQ7C,IAtDvB,wBAkEI,SAAWA,EAAIC,GAGX,IAFAA,IAEOD,EAAKC,GAAI,CAIZ,IAAMkC,EAAIpG,KAAKM,KAAK2D,GACpBjE,KAAKO,MAAM0D,IAAMjE,KAAKM,KAAK4D,IAC3BlE,KAAKO,MAAM2D,IAAMkC,MA3E7B,iCA2FI,SAAoBnC,EAAIC,EAAI8C,GAKxB,IAJIA,IAAU/C,GACV+C,IAGGA,EAAQ9C,EAAI8C,IAAS,CAcxB,IAZA,IAAM7C,EAAQnE,KAAKM,KAAK0G,GAKpB/B,EAAOhB,EACPiB,EAAQ8B,EAML/B,EAAOC,GAAO,CACjB,IAAMX,EAAOU,EAAOC,IAAW,EAG3Bf,EAAQnE,KAAKM,KAAKiE,GAClBW,EAAQX,EAERU,EAAOV,EAAM,EASrB,IAAIjB,EAAI0D,EAAQ/B,EAEhB,OAAQ3B,GACJ,KAAK,EAEDtD,KAAKO,MAAM0E,EAAO,EAAGjF,KAAKM,KAAK2E,EAAO,IAE1C,KAAK,EAEDjF,KAAKO,MAAM0E,EAAO,EAAGjF,KAAKM,KAAK2E,EAAO,IAE1C,KAAK,EAEDjF,KAAKO,MAAM0E,EAAO,EAAGjF,KAAKM,KAAK2E,IAC/B,MACJ,QACI,KAAO3B,EAAI,GAEPtD,KAAKO,MAAM0E,EAAO3B,EAAGtD,KAAKM,KAAK2E,EAAO3B,EAAI,IAC1CA,IAKZtD,KAAKO,MAAM0E,EAAMd,MAtJ7B,wBA0KI,SAAW8C,EAAOC,EAAOF,EAAOlD,EAAQqD,GACpC,IAAIC,EAAa,EACbC,EAAY,EACZC,EAAS,EACb,GAAKJ,EAqEE,CAEH,GAAID,EAAQjH,KAAKU,QAAQsG,EAAQG,EAAMnH,KAAKwG,KAAM,CAG9C,IAFAa,EAAYvD,EAASqD,EAGjBG,EAASD,GAENJ,EAAQjH,KAAKU,QAAQsG,EAAQG,EAAOG,EAAQtH,KAAKwG,MAEpDY,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIbD,GAAcD,EACdG,GAAUH,MAGP,CAEH,IADAE,EAAYF,EAAO,EAEfG,EAASD,GAGNJ,GAASjH,KAAKU,QAAQsG,EAAQG,EAAOG,EAAQtH,KAAKwG,MAErDY,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAGbC,EAASD,IACTC,EAASD,GAIb,IAAMb,EAAMY,EACZA,EAAaD,EAAOG,EACpBA,EAASH,EAAOX,EAUpB,IADAY,IACOA,EAAaE,GAAQ,CACxB,IAAMlC,EAAIgC,GAAeE,EAASF,IAAgB,GAG9CH,EAAQjH,KAAKU,QAAQsG,EAAQ5B,EAAGpF,KAAKwG,KACrCY,EAAahC,EAAI,EAEjBkC,EAASlC,OAvIT,CAER,GAAI6B,EAAQjH,KAAKM,KAAK0G,EAAQG,GAAO,CAGjC,IAFAE,EAAYvD,EAASqD,EAGjBG,EAASD,GAENJ,EAAQjH,KAAKM,KAAK0G,EAAQG,EAAOG,IAEpCF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIbD,GAAcD,EACdG,GAAUH,MAGP,CAEH,IADAE,EAAYF,EAAO,EAEfG,EAASD,GAGNJ,GAASjH,KAAKM,KAAK0G,EAAQG,EAAOG,IAErCF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAGbC,EAASD,IACTC,EAASD,GAIb,IAAMb,EAAMY,EACZA,EAAaD,EAAOG,EACpBA,EAASH,EAAOX,EAUpB,IADAY,IACOA,EAAaE,GAAQ,CACxB,IAAMlC,EAAIgC,GAAeE,EAASF,IAAgB,GAG9CH,EAAQjH,KAAKM,KAAK0G,EAAQ5B,GAC1BgC,EAAahC,EAAI,EAEjBkC,EAASlC,GAyErB,OAAOkC,IAzTf,yBA2UI,SAAYL,EAAOC,EAAOF,EAAOlD,EAAQqD,GACrC,IAAIC,EAAa,EACbC,EAAY,EACZC,EAAS,EAEb,GAAKJ,EAwEE,CAGH,GAAID,EAAQjH,KAAKU,QAAQsG,EAAQG,EAAMnH,KAAKwG,KAAM,CAG9C,IAFAa,EAAYF,EAAO,EAGfG,EAASD,GAENJ,EAAQjH,KAAKU,QAAQsG,EAAQG,EAAOG,EAAQtH,KAAKwG,MAEpDY,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIb,IAAMb,EAAMY,EACZA,EAAaD,EAAOG,EACpBA,EAASH,EAAOX,MAGb,CAGH,IAFAa,EAAYvD,EAASqD,EAGjBG,EAASD,GAENJ,GAASjH,KAAKU,QAAQsG,EAAQG,EAAOG,EAAQtH,KAAKwG,MAErDY,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIbD,GAAcD,EACdG,GAAUH,EAWd,IAFAC,IAEOA,EAAaE,GAAQ,CACxB,IAAMlC,EAAIgC,GAAeE,EAASF,IAAgB,GAG9CH,EAAQjH,KAAKU,QAAQsG,EAAQ5B,EAAGpF,KAAKwG,KACrCc,EAASlC,EAETgC,EAAahC,EAAI,OA7IjB,CAER,GAAI6B,EAAQjH,KAAKM,KAAK0G,EAAQG,GAAO,CAGjC,IAFAE,EAAYF,EAAO,EAGfG,EAASD,GAENJ,EAAQjH,KAAKM,KAAK0G,EAAQG,EAAOG,IAEpCF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIb,IAAMb,EAAMY,EACZA,EAAaD,EAAOG,EACpBA,EAASH,EAAOX,MAGb,CAGH,IAFAa,EAAYvD,EAASqD,EAGjBG,EAASD,GAENJ,GAASjH,KAAKM,KAAK0G,EAAQG,EAAOG,IAErCF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIbD,GAAcD,EACdG,GAAUH,EAWd,IAFAC,IAEOA,EAAaE,GAAQ,CACxB,IAAMlC,EAAIgC,GAAeE,EAASF,IAAgB,GAG9CH,EAAQjH,KAAKM,KAAK0G,EAAQ5B,GAC1BkC,EAASlC,EAETgC,EAAahC,EAAI,GA8E7B,OAAOkC,IAlef,qBA4eI,SAAQZ,EAAUE,GACd5G,KAAK0G,SAAS1G,KAAK6G,WAAaH,EAChC1G,KAAK4G,UAAU5G,KAAK6G,WAAaD,EACjC5G,KAAK6G,WAAa,IA/e1B,uBAufI,WACI,KAAO7G,KAAK6G,UAAY,GAAG,CACvB,IAAIvD,EAAItD,KAAK6G,UAAY,EAEzB,GAEQvD,GAAK,GACFtD,KAAK4G,UAAUtD,EAAI,IAAMtD,KAAK4G,UAAUtD,GAAKtD,KAAK4G,UAAUtD,EAAI,IAGnEA,GAAK,GACFtD,KAAK4G,UAAUtD,EAAI,IAAMtD,KAAK4G,UAAUtD,GAAKtD,KAAK4G,UAAUtD,EAAI,GAGnEtD,KAAK4G,UAAUtD,EAAI,GAAKtD,KAAK4G,UAAUtD,EAAI,IAC3CA,SAED,GAAItD,KAAK4G,UAAUtD,GAAKtD,KAAK4G,UAAUtD,EAAI,GAC9C,MAEJtD,KAAKuH,QAAQjE,MA3gBzB,4BAkhBI,WACI,KAAOtD,KAAK6G,UAAY,GAAG,CACvB,IAAIvD,EAAItD,KAAK6G,UAAY,EAErBvD,EAAI,GAAKtD,KAAK4G,UAAUtD,EAAI,GAAKtD,KAAK4G,UAAUtD,EAAI,IACpDA,IAGJtD,KAAKuH,QAAQjE,MA1hBzB,qBAoiBI,SAAQH,GACJ,IAAIqE,EAASxH,KAAK0G,SAASvD,GACvBsE,EAAUzH,KAAK4G,UAAUzD,GACvBuE,EAAS1H,KAAK0G,SAASvD,EAAI,GAC7BwE,EAAU3H,KAAK4G,UAAUzD,EAAI,GAEjCnD,KAAK4G,UAAUzD,GAAKsE,EAAUE,EAE1BxE,IAAMnD,KAAK6G,UAAY,IACvB7G,KAAK0G,SAASvD,EAAI,GAAKnD,KAAK0G,SAASvD,EAAI,GACzCnD,KAAK4G,UAAUzD,EAAI,GAAKnD,KAAK4G,UAAUzD,EAAI,IAG/CnD,KAAK6G,YAOL,IAAMrB,EAAIxF,KAAK4H,YAAY5H,KAAKM,KAAKoH,IAAS,EAAOF,EAAQC,EAAS,GACtED,GAAUhC,EAGM,KAFhBiC,GAAWjC,IA2BK,KAThBmC,EAAU3H,KAAK6H,WAEX7H,KAAKM,KAAKkH,EAASC,EAAU,IAC7B,EACAC,EACAC,EACAA,EAAU,MAWVF,GAAWE,EACX3H,KAAK8H,SAASN,EAAQC,EAASC,EAAQC,GAEvC3H,KAAK+H,UAAUP,EAAQC,EAASC,EAAQC,MAhmBpD,sBAinBI,SAASH,EAAQC,EAASC,EAAQC,GAS9B,IAAIxE,EAAI,EAER,IAAKA,EAAI,EAAGA,EAAIsE,EAAStE,IAErBnD,KAAKW,SAASwC,EAAGnD,KAAKM,KAAKkH,EAASrE,GAAInD,KAAKwG,KAGjD,IAAIwB,EAAU,EACVC,EAAUP,EACVQ,EAAOV,EAUX,GANAxH,KAAKO,MAAM2H,EAAMlI,KAAKM,KAAK2H,IAG3BC,IACAD,IAEkB,MAAZN,EAQN,GAAgB,IAAZF,EAAJ,CAaA,IAjDuC,IA+ClCnB,EAAatG,KAAbsG,YAEQ,CACT,IAAI6B,EAAS,EACTC,EAAS,EACTC,GAAO,EAEX,GAEI,GAAIrI,KAAKM,KAAK2H,GAAWjI,KAAKU,QAAQsH,EAAShI,KAAKwG,MAQhD,GANAxG,KAAKO,MAAM2H,EAAMlI,KAAKM,KAAK2H,IAC3BC,IACAD,IACAG,IACAD,EAAS,EAES,MAAZR,EAAe,CACjBU,GAAO,EACP,YAUJ,GANArI,KAAKO,MAAM2H,EAAMlI,KAAKU,QAAQsH,EAAShI,KAAKwG,MAE5C0B,IACAF,IACAG,IACAC,EAAS,EACS,MAAZX,EAAe,CACjBY,GAAO,EACP,cAGFF,EAASC,GAAU9B,GAE7B,GAAI+B,EACA,MAGJ,EAAG,CAIC,GAAe,KAFfF,EAASnI,KAAK4H,YAAY5H,KAAKM,KAAK2H,IAAU,EAAMD,EAASP,EAAS,IAEpD,CACd,IAAKtE,EAAI,EAAGA,EAAIgF,EAAQhF,IAGpBnD,KAAKO,MAAM2H,EAAO/E,EAAGnD,KAAKU,QAAQsH,EAAU7E,EAAGnD,KAAKwG,MAMxD,GAHA0B,GAAQC,EACRH,GAAWG,GACXV,GAAWU,IACI,EAAG,CACdE,GAAO,EACP,OAWR,GALArI,KAAKO,MAAM2H,EAAMlI,KAAKM,KAAK2H,IAE3BC,IACAD,IAEkB,MAAZN,EAAe,CACjBU,GAAO,EACP,MAMJ,GAAe,KAFfD,EAASpI,KAAK6H,WAAW7H,KAAKU,QAAQsH,EAAShI,KAAKwG,MAAM,EAAOyB,EAASN,EAAS,IAEjE,CACd,IAAKxE,EAAI,EAAGA,EAAIiF,EAAQjF,IAGpBnD,KAAKO,MAAM2H,EAAO/E,EAAGnD,KAAKM,KAAK2H,EAAU9E,IAO7C,GAJA+E,GAAQE,EACRH,GAAWG,EAGK,KAFhBT,GAAWS,GAEQ,CACfC,GAAO,EACP,OAWR,GALArI,KAAKO,MAAM2H,EAAMlI,KAAKU,QAAQsH,EAAShI,KAAKwG,MAE5C0B,IACAF,IAEkB,MAAZP,EAAe,CACjBY,GAAO,EACP,MAGJ/B,UAEA6B,GA/4Bc,GAg5BXC,GAh5BW,GAm5BlB,GAAIC,EACA,MAGA/B,EAAY,IACZA,EAAY,GAGhBA,GAAa,EASjB,GANAtG,KAAKsG,UAAYA,EAEbA,EAAY,IACZtG,KAAKsG,UAAY,GAGL,IAAZmB,EAAe,CACf,IAAKtE,EAAI,EAAGA,EAAIwE,EAASxE,IAGrBnD,KAAKO,MAAM2H,EAAO/E,EAAGnD,KAAKM,KAAK2H,EAAU9E,IAI7CnD,KAAKO,MAAM2H,EAAOP,EAAS3H,KAAKU,QAAQsH,EAAShI,KAAKwG,UACnD,IAAgB,IAAZiB,EACP,MAAM,IAAI7E,MAAM,6CAEhB,IAAKO,EAAI,EAAGA,EAAIsE,EAAStE,IAGrBnD,KAAKO,MAAM2H,EAAO/E,EAAGnD,KAAKU,QAAQsH,EAAU7E,EAAGnD,KAAKwG,WAzJ5D,CACI,IAAKrD,EAAI,EAAGA,EAAIwE,EAASxE,IAGrBnD,KAAKO,MAAM2H,EAAO/E,EAAGnD,KAAKM,KAAK2H,EAAU9E,IAG7CnD,KAAKO,MAAM2H,EAAOP,EAAS3H,KAAKU,QAAQsH,EAAShI,KAAKwG,WAdtD,IAAKrD,EAAI,EAAGA,EAAIsE,EAAStE,IAErBnD,KAAKO,MAAM2H,EAAO/E,EAAGnD,KAAKU,QAAQsH,EAAU7E,EAAGnD,KAAKwG,QAhpBpE,uBAg0BI,SAAUgB,EAAQC,EAASC,EAAQC,GAK/B,IAAIxE,EAAI,EAER,IAAKA,EAAI,EAAGA,EAAIwE,EAASxE,IAErBnD,KAAKW,SAASwC,EAAGnD,KAAKM,KAAKoH,EAASvE,GAAInD,KAAKwG,KAGjD,IAAIwB,EAAUR,EAASC,EAAU,EAC7BQ,EAAUN,EAAU,EACpBO,EAAOR,EAASC,EAAU,EAC1BW,EAAe,EACfC,EAAa,EAQjB,GALAvI,KAAKO,MAAM2H,EAAMlI,KAAKM,KAAK0H,IAE3BE,IACAF,IAEkB,MAAZP,EAWN,GAAgB,IAAZE,EAAJ,CAkBA,IArDwC,IAmDnCrB,EAAatG,KAAbsG,YAEQ,CACT,IAAI6B,EAAS,EACTC,EAAS,EACTC,GAAO,EAEX,GAEI,GAAIrI,KAAKU,QAAQuH,EAASjI,KAAKwG,KAAOxG,KAAKM,KAAK0H,IAO5C,GALAhI,KAAKO,MAAM2H,EAAMlI,KAAKM,KAAK0H,IAC3BE,IACAF,IACAG,IACAC,EAAS,EACS,MAAZX,EAAe,CACjBY,GAAO,EACP,YASJ,GALArI,KAAKO,MAAM2H,EAAMlI,KAAKU,QAAQuH,EAASjI,KAAKwG,MAC5C0B,IACAD,IACAG,IACAD,EAAS,EACS,MAAZR,EAAe,CACjBU,GAAO,EACP,cAGFF,EAASC,GAAU9B,GAE7B,GAAI+B,EACA,MAGJ,EAAG,CAiBC,GAAe,KARfF,EAASV,EAAUzH,KAAK4H,YACpB5H,KAAKU,QAAQuH,EAASjI,KAAKwG,MAC3B,EACAgB,EACAC,EACAA,EAAU,IAGI,CAOd,IAJAA,GAAWU,EACXI,GAHAL,GAAQC,GAGY,EACpBG,GAHAN,GAAWG,GAGc,EAEpBhF,EAAIgF,EAAS,EAAGhF,GAAK,EAAGA,IAEzBnD,KAAKO,MAAMgI,EAAapF,EAAGnD,KAAKM,KAAKgI,EAAenF,IAGxD,GAAgB,IAAZsE,EAAe,CACfY,GAAO,EACP,OAUR,GALArI,KAAKO,MAAM2H,EAAMlI,KAAKU,QAAQuH,EAASjI,KAAKwG,MAE5C0B,IACAD,IAEkB,MAAZN,EAAe,CACjBU,GAAO,EACP,MAoBJ,GAAe,KARfD,EAAST,EAAU3H,KAAK6H,WACpB7H,KAAKM,KAAK0H,IACV,EACA,EACAL,EACAA,EAAU,IAGI,CAOd,IAJAA,GAAWS,EACXG,GAHAL,GAAQE,GAGY,EACpBE,GAHAL,GAAWG,GAGc,EAEpBjF,EAAI,EAAGA,EAAIiF,EAAQjF,IAEpBnD,KAAKO,MAAMgI,EAAapF,EAAGnD,KAAKU,QAAQ4H,EAAenF,EAAGnD,KAAKwG,MAGnE,GAAImB,GAAW,EAAG,CACdU,GAAO,EACP,OAUR,GALArI,KAAKO,MAAM2H,EAAMlI,KAAKM,KAAK0H,IAE3BE,IACAF,IAEkB,MAAZP,EAAe,CACjBY,GAAO,EACP,MAGJ/B,UAEA6B,GA5nCc,GA6nCXC,GA7nCW,GAgoClB,GAAIC,EACA,MAGA/B,EAAY,IACZA,EAAY,GAGhBA,GAAa,EASjB,GANAtG,KAAKsG,UAAYA,EAEbA,EAAY,IACZtG,KAAKsG,UAAY,GAGL,IAAZqB,EAAe,CAMf,IAHAY,GAFAL,GAAQT,GAEY,EACpBa,GAFAN,GAAWP,GAEc,EAEpBtE,EAAIsE,EAAU,EAAGtE,GAAK,EAAGA,IAE1BnD,KAAKO,MAAMgI,EAAapF,EAAGnD,KAAKM,KAAKgI,EAAenF,IAMxDnD,KAAKO,MAAM2H,EAAMlI,KAAKU,QAAQuH,EAASjI,KAAKwG,UAGzC,IAAgB,IAAZmB,EACP,MAAM,IAAI/E,MAAM,8CAGhB,IADA0F,EAAeJ,GAAQP,EAAU,GAC5BxE,EAAI,EAAGA,EAAIwE,EAASxE,IAErBnD,KAAKO,MAAM+H,EAAenF,EAAGnD,KAAKU,QAAQyC,EAAGnD,KAAKwG,WAhM1D,CAMI,IAHA+B,GAFAL,GAAQT,GAEY,EACpBa,GAFAN,GAAWP,GAEc,EAEpBtE,EAAIsE,EAAU,EAAGtE,GAAK,EAAGA,IAE1BnD,KAAKO,MAAMgI,EAAapF,EAAGnD,KAAKM,KAAKgI,EAAenF,IAIxDnD,KAAKO,MAAM2H,EAAMlI,KAAKU,QAAQuH,EAASjI,KAAKwG,WApB5C,IAFA8B,EAAeJ,GAAQP,EAAU,GAE5BxE,EAAI,EAAGA,EAAIwE,EAASxE,IAErBnD,KAAKO,MAAM+H,EAAenF,EAAGnD,KAAKU,QAAQyC,EAAGnD,KAAKwG,QA71BlE,qBAmjCI,SAAQvF,EAAKC,GACTlB,KAAK0B,KAAKT,EAAKC,EAAK,KApjC5B,kBAujCI,SAAK+C,EAAIC,GAEL,IAEIsE,EAAYtE,EAAKD,EAGrB,KAAIuE,EAAY,GAAhB,CAIA,IAAI5B,EAAY,EAEZ4B,EA9sCc,KA+sCd5B,EAAY5G,KAAKyI,iBAAiBxE,EAAIC,GACtClE,KAAK0I,oBAAoBzE,EAAIC,EAAID,EAAK2C,IAI1C,IAAMnB,EAjmCd,SAAsBnC,GAGlB,IAFA,IAAIG,EAAI,EAEDH,GAtHe,IAuHlBG,GAAU,EAAJH,EACNA,IAAM,EAGV,OAAOA,EAAIG,EAylCQiC,CAAa8C,GAE5B,EAAG,CAEC,IADA5B,EAAY5G,KAAKyI,iBAAiBxE,EAAIC,IACtBuB,EAAQ,CACpB,IAAIkD,EAAQH,EACRG,EAAQlD,IACRkD,EAAQlD,GAGZzF,KAAK0I,oBAAoBzE,EAAIA,EAAK0E,EAAO1E,EAAK2C,GAC9CA,EAAY+B,EAGhB3I,KAAK4I,QAAQ3E,EAAI2C,GACjB5G,KAAK6I,YAGLL,GAAa5B,EACb3C,GAAM2C,QACa,IAAd4B,GAGTxI,KAAK8I,iBACL9I,KAAKS,eAAeT,KAAKwG,UAlmCjC,GAA6B1G,S,oDCzHzBiJ,E,cAFEC,EAAgB,CAAC,EAAK,GAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAU9DC,EAAQ,SAAA1D,GAAC,OAAIA,EAAI,IACjBA,EAAI,IACAA,EAAI,GACA,EACA,EACJA,EAAI,IACAA,EAAI,IACA,EACA,EACJ,EACRA,EAAI,IACAA,EAAI,IACA,EACA,EACJA,EAAI,IACAA,EAAI,IACA,EACA,EACJ,GAUd,SAAS2D,EAAqBC,EAAGC,GAC7B,GAAID,IAAMC,EACN,OAAO,EAGX,KAAQD,IAAMA,KAASC,IAAMA,EAAG,CAC5B,GAAU,IAAND,GAAiB,IAANC,EACX,OAAOD,EAAIC,GAAM,EAAI,EAGzB,GAAID,EAAI,GAAKC,EAAI,EAAG,CAChB,GAAIA,GAAK,EACL,OAAS,EAGb,GAAID,GAAK,EACL,OAAO,EAGXA,GAAMA,EACNC,GAAMA,EAGV,IAAMC,EAAKJ,EAAME,GACXG,EAAKL,EAAMG,GAEbhD,EAAI,EAYR,OAVIiD,EAAKC,GACLH,GAAKH,EAAcM,EAAKD,EAAK,GAC7BD,GAAK,GACLhD,GAAM,GACCiD,EAAKC,IACZF,GAAKJ,EAAcK,EAAKC,EAAK,GAC7BH,GAAK,GACL/C,EAAI,GAGJ+C,IAAMC,EACChD,EAGJ+C,EAAIC,GAAM,EAAI,EAGzB,IAAMG,EAAOC,OAAOL,GACdM,EAAOD,OAAOJ,GAEpB,OAAIG,IAASE,EACF,EAGJF,EAAOE,GAAS,EAAI,EA8B/B,SAAShB,EAAkBiB,EAAOzF,EAAIC,EAAI/D,GACtC,IAAI2G,EAAQ7C,EAAK,EAEjB,GAAI6C,IAAU5C,EACV,OAAO,EAIX,GAAI/D,EAAQuJ,EAAM5C,KAAW4C,EAAMzF,IAAO,EAAG,CACzC,KAAO6C,EAAQ5C,GAAM/D,EAAQuJ,EAAM5C,GAAQ4C,EAAM5C,EAAQ,IAAM,GAC3DA,IAGJC,EAAW2C,EAAOzF,EAAI6C,GACtBC,EAAWgC,EAAS9E,EAAI6C,QAGxB,KAAOA,EAAQ5C,GAAM/D,EAAQuJ,EAAM5C,GAAQ4C,EAAM5C,EAAQ,KAAO,GAC5DA,IAIR,OAAOA,EAAQ7C,EAUnB,SAAS8C,EAAY2C,EAAOzF,EAAIC,GAG5B,IAFAA,IAEOD,EAAKC,GAAI,CACZ,IAAMkC,EAAIsD,EAAMzF,GAChByF,EAAMzF,KAASyF,EAAMxF,GACrBwF,EAAMxF,KAASkC,GAcvB,SAASsC,EAAqBgB,EAAOzF,EAAIC,EAAI8C,EAAO7G,GAKhD,IAJI6G,IAAU/C,GACV+C,IAGGA,EAAQ9C,EAAI8C,IAAU,CAYzB,IAXA,IAAM7C,EAAQuF,EAAM1C,GACd2C,EAAaZ,EAAQ/B,GAGvB/B,EAAOhB,EACPiB,EAAQ8B,EAML/B,EAAOC,GAAO,CACjB,IAAMX,EAAOU,EAAOC,IAAW,EAE3B/E,EAAQgE,EAAOuF,EAAMnF,IAAQ,EAC7BW,EAAQX,EAERU,EAAOV,EAAM,EASrB,IAAIjB,EAAI0D,EAAQ/B,EAEhB,OAAQ3B,GACJ,KAAK,EACDoG,EAAMzE,EAAO,GAAKyE,EAAMzE,EAAO,GAC/B8D,EAAQ9D,EAAO,GAAK8D,EAAQ9D,EAAO,GAEvC,KAAK,EACDyE,EAAMzE,EAAO,GAAKyE,EAAMzE,EAAO,GAC/B8D,EAAQ9D,EAAO,GAAK8D,EAAQ9D,EAAO,GAEvC,KAAK,EACDyE,EAAMzE,EAAO,GAAKyE,EAAMzE,GACxB8D,EAAQ9D,EAAO,GAAK8D,EAAQ9D,GAC5B,MACJ,QACI,KAAO3B,EAAI,GACPoG,EAAMzE,EAAO3B,GAAKoG,EAAMzE,EAAO3B,EAAI,GACnCyF,EAAQ9D,EAAO3B,GAAKyF,EAAQ9D,EAAO3B,EAAI,GACvCA,IAIZoG,EAAMzE,GAAQd,EACd4E,EAAQ9D,GAAQ0E,GAiBxB,SAAS9B,EAAYZ,EAAOyC,EAAO1C,EAAOlD,EAAQqD,EAAMhH,GACpD,IAAIiH,EAAa,EACbC,EAAY,EACZC,EAAS,EAEb,GAAInH,EAAQ8G,EAAOyC,EAAM1C,EAAQG,IAAS,EAAG,CAGzC,IAFAE,EAAYvD,EAASqD,EAGjBG,EAASD,GACNlH,EAAQ8G,EAAOyC,EAAM1C,EAAQG,EAAOG,IAAW,GAElDF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIbD,GAAcD,EACdG,GAAUH,MAGP,CAEH,IADAE,EAAYF,EAAO,EAEfG,EAASD,GACNlH,EAAQ8G,EAAOyC,EAAM1C,EAAQG,EAAOG,KAAY,GAEnDF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAGbC,EAASD,IACTC,EAASD,GAIb,IAAMb,EAAMY,EACZA,EAAaD,EAAOG,EACpBA,EAASH,EAAOX,EAUpB,IADAY,IACOA,EAAaE,GAAQ,CACxB,IAAMlC,EAAIgC,GAAeE,EAASF,IAAgB,GAE9CjH,EAAQ8G,EAAOyC,EAAM1C,EAAQ5B,IAAM,EACnCgC,EAAahC,EAAI,EAEjBkC,EAASlC,EAGjB,OAAOkC,EAgBX,SAASM,EAAaX,EAAOyC,EAAO1C,EAAOlD,EAAQqD,EAAMhH,GACrD,IAAIiH,EAAa,EACbC,EAAY,EACZC,EAAS,EAEb,GAAInH,EAAQ8G,EAAOyC,EAAM1C,EAAQG,IAAS,EAAG,CAGzC,IAFAE,EAAYF,EAAO,EAGfG,EAASD,GACNlH,EAAQ8G,EAAOyC,EAAM1C,EAAQG,EAAOG,IAAW,GAElDF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIb,IAAMb,EAAMY,EACZA,EAAaD,EAAOG,EACpBA,EAASH,EAAOX,MAGb,CAGH,IAFAa,EAAYvD,EAASqD,EAGjBG,EAASD,GACNlH,EAAQ8G,EAAOyC,EAAM1C,EAAQG,EAAOG,KAAY,GAEnDF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIbD,GAAcD,EACdG,GAAUH,EAWd,IAFAC,IAEOA,EAAaE,GAAQ,CACxB,IAAMlC,EAAIgC,GAAeE,EAASF,IAAgB,GAE9CjH,EAAQ8G,EAAOyC,EAAM1C,EAAQ5B,IAAM,EACnCkC,EAASlC,EAETgC,EAAahC,EAAI,EAIzB,OAAOkC,E,IAGLjB,E,WACF,WAAaqD,EAAOvJ,GAAU,oBAC1BH,KAAK0J,MAAQA,EACb1J,KAAKG,QAAUA,EAFU,IAIlB2D,EAAU4F,EAAV5F,OAEP9D,KAAK8D,OAASA,EACd9D,KAAKsG,UAxaiB,EA0atBtG,KAAKuG,iBAAmBzC,EAAS,IAC3BA,IAAW,EAraU,IAwa3B9D,KAAKwG,IAAM,IAAIG,MAAM3G,KAAKuG,kBAC1BvG,KAAK4J,SAAW,IAAIjD,MAAM3G,KAAKuG,kBAE/BvG,KAAKyG,YAAc3C,EAAS,IACtB,EACAA,EAAS,KACL,GACAA,EAAS,OACL,GACA,GAEd9D,KAAK0G,SAAW,IAAIC,MAAM3G,KAAKyG,aAC/BzG,KAAK4G,UAAY,IAAID,MAAM3G,KAAKyG,aAEhCzG,KAAK6G,UAAY,E,2CASrB,SAASH,EAAUE,GACf5G,KAAK0G,SAAS1G,KAAK6G,WAAaH,EAChC1G,KAAK4G,UAAU5G,KAAK6G,WAAaD,EACjC5G,KAAK6G,WAAa,I,uBAQtB,WACI,KAAO7G,KAAK6G,UAAY,GAAG,CACvB,IAAIvD,EAAItD,KAAK6G,UAAY,EAEzB,GAEQvD,GAAK,GACFtD,KAAK4G,UAAUtD,EAAI,IAAMtD,KAAK4G,UAAUtD,GAAKtD,KAAK4G,UAAUtD,EAAI,IAGnEA,GAAK,GACFtD,KAAK4G,UAAUtD,EAAI,IAAMtD,KAAK4G,UAAUtD,GAAKtD,KAAK4G,UAAUtD,EAAI,GAGnEtD,KAAK4G,UAAUtD,EAAI,GAAKtD,KAAK4G,UAAUtD,EAAI,IAC3CA,SAED,GAAItD,KAAK4G,UAAUtD,GAAKtD,KAAK4G,UAAUtD,EAAI,GAC9C,MAEJtD,KAAKuH,QAAQjE,M,4BAOrB,WACI,KAAOtD,KAAK6G,UAAY,GAAG,CACvB,IAAIvD,EAAItD,KAAK6G,UAAY,EAErBvD,EAAI,GAAKtD,KAAK4G,UAAUtD,EAAI,GAAKtD,KAAK4G,UAAUtD,EAAI,IACpDA,IAGJtD,KAAKuH,QAAQjE,M,qBAUrB,SAASH,GAAI,IACFhD,EAAWH,KAAXG,QACAuJ,EAAS1J,KAAT0J,MAEHlC,EAASxH,KAAK0G,SAASvD,GACvBsE,EAAUzH,KAAK4G,UAAUzD,GACvBuE,EAAS1H,KAAK0G,SAASvD,EAAI,GAC7BwE,EAAU3H,KAAK4G,UAAUzD,EAAI,GAEjCnD,KAAK4G,UAAUzD,GAAKsE,EAAUE,EAE1BxE,IAAMnD,KAAK6G,UAAY,IACvB7G,KAAK0G,SAASvD,EAAI,GAAKnD,KAAK0G,SAASvD,EAAI,GACzCnD,KAAK4G,UAAUzD,EAAI,GAAKnD,KAAK4G,UAAUzD,EAAI,IAG/CnD,KAAK6G,YAML,IAAMrB,EAAIoC,EAAY8B,EAAMhC,GAASgC,EAAOlC,EAAQC,EAAS,EAAGtH,GAChEqH,GAAUhC,EAGM,KAFhBiC,GAAWjC,IAmBK,KAThBmC,EAAUE,EACN6B,EAAMlC,EAASC,EAAU,GACzBiC,EACAhC,EACAC,EACAA,EAAU,EACVxH,MAWAsH,GAAWE,EACX3H,KAAK8H,SAASN,EAAQC,EAASC,EAAQC,GAEvC3H,KAAK+H,UAAUP,EAAQC,EAASC,EAAQC,M,sBAiBhD,SAAUH,EAAQC,EAASC,EAAQC,GAAU,IAClCxH,EAAWH,KAAXG,QACAuJ,EAAS1J,KAAT0J,MACAlD,EAAOxG,KAAPwG,IACAoD,EAAY5J,KAAZ4J,SACHzG,EAAI,EAER,IAAKA,EAAI,EAAGA,EAAIsE,EAAStE,IACrBqD,EAAIrD,GAAKuG,EAAMlC,EAASrE,GACxByG,EAASzG,GAAK4F,EAAQvB,EAASrE,GAGnC,IAAI6E,EAAU,EACVC,EAAUP,EACVQ,EAAOV,EAQX,GANAkC,EAAMxB,GAAQwB,EAAMzB,GACpBc,EAAQb,GAAQa,EAAQd,GAExBC,IACAD,IAEmB,MAAZN,EAAP,CAQA,GAAgB,IAAZF,EAAe,CACf,IAAKtE,EAAI,EAAGA,EAAIwE,EAASxE,IACrBuG,EAAMxB,EAAO/E,GAAKuG,EAAMzB,EAAU9E,GAClC4F,EAAQb,EAAO/E,GAAK4F,EAAQd,EAAU9E,GAI1C,OAFAuG,EAAMxB,EAAOP,GAAWnB,EAAIwB,QAC5Be,EAAQb,EAAOP,GAAWiC,EAAS5B,IAMvC,IA1CwC,IAwCnC1B,EAAatG,KAAbsG,YAEQ,CACT,IAAI6B,EAAS,EACTC,EAAS,EACTC,GAAO,EAEX,GACI,GAAIlI,EAAQuJ,EAAMzB,GAAUzB,EAAIwB,IAAY,GAQxC,GAPA0B,EAAMxB,GAAQwB,EAAMzB,GACpBc,EAAQb,GAAQa,EAAQd,GACxBC,IACAD,IACAG,IACAD,EAAS,EAEU,MAAZR,EAAe,CAClBU,GAAO,EACP,YASJ,GANAqB,EAAMxB,GAAQ1B,EAAIwB,GAClBe,EAAQb,GAAQ0B,EAAS5B,GACzBE,IACAF,IACAG,IACAC,EAAS,EACU,MAAZX,EAAe,CAClBY,GAAO,EACP,cAGFF,EAASC,GAAU9B,GAE7B,GAAI+B,EACA,MAGJ,EAAG,CAGC,GAAe,KAFfF,EAASP,EAAY8B,EAAMzB,GAAUzB,EAAKwB,EAASP,EAAS,EAAGtH,IAE7C,CACd,IAAKgD,EAAI,EAAGA,EAAIgF,EAAQhF,IACpBuG,EAAMxB,EAAO/E,GAAKqD,EAAIwB,EAAU7E,GAChC4F,EAAQb,EAAO/E,GAAKyG,EAAS5B,EAAU7E,GAM3C,GAHA+E,GAAQC,EACRH,GAAWG,GACXV,GAAWU,IACI,EAAG,CACdE,GAAO,EACP,OAUR,GANAqB,EAAMxB,GAAQwB,EAAMzB,GACpBc,EAAQb,GAAQa,EAAQd,GAExBC,IACAD,IAEmB,MAAZN,EAAe,CAClBU,GAAO,EACP,MAKJ,GAAe,KAFfD,EAASP,EAAWrB,EAAIwB,GAAU0B,EAAOzB,EAASN,EAAS,EAAGxH,IAE5C,CACd,IAAKgD,EAAI,EAAGA,EAAIiF,EAAQjF,IACpBuG,EAAMxB,EAAO/E,GAAKuG,EAAMzB,EAAU9E,GAClC4F,EAAQb,EAAO/E,GAAK4F,EAAQd,EAAU9E,GAO1C,GAJA+E,GAAQE,EACRH,GAAWG,EAGK,KAFhBT,GAAWS,GAEQ,CACfC,GAAO,EACP,OAQR,GALAqB,EAAMxB,GAAQ1B,EAAIwB,GAClBe,EAAQb,GAAQ0B,EAAS5B,GACzBE,IACAF,IAEmB,MAAZP,EAAe,CAClBY,GAAO,EACP,MAGJ/B,UAEA6B,GA5sBc,GA6sBXC,GA7sBW,GAgtBlB,GAAIC,EACA,MAGA/B,EAAY,IACZA,EAAY,GAGhBA,GAAa,EASjB,GANAtG,KAAKsG,UAAYA,EAEbA,EAAY,IACZtG,KAAKsG,UAAY,GAGL,IAAZmB,EAAe,CACf,IAAKtE,EAAI,EAAGA,EAAIwE,EAASxE,IACrBuG,EAAMxB,EAAO/E,GAAKuG,EAAMzB,EAAU9E,GAClC4F,EAAQb,EAAO/E,GAAK4F,EAAQd,EAAU9E,GAE1CuG,EAAMxB,EAAOP,GAAWnB,EAAIwB,GAC5Be,EAAQb,EAAOP,GAAWiC,EAAS5B,OAChC,IAAgB,IAAZP,EACP,MAAM,IAAI7E,MAAM,6CAEhB,IAAKO,EAAI,EAAGA,EAAIsE,EAAStE,IACrBuG,EAAMxB,EAAO/E,GAAKqD,EAAIwB,EAAU7E,GAChC4F,EAAQb,EAAO/E,GAAKyG,EAAS5B,EAAU7E,SAlJ3C,IAAKA,EAAI,EAAGA,EAAIsE,EAAStE,IACrBuG,EAAMxB,EAAO/E,GAAKqD,EAAIwB,EAAU7E,GAChC4F,EAAQb,EAAO/E,GAAKyG,EAAS5B,EAAU7E,K,uBAkKnD,SAAWqE,EAAQC,EAASC,EAAQC,GAAU,IACnCxH,EAAWH,KAAXG,QACAuJ,EAAS1J,KAAT0J,MACAlD,EAAOxG,KAAPwG,IACAoD,EAAY5J,KAAZ4J,SACHzG,EAAI,EAER,IAAKA,EAAI,EAAGA,EAAIwE,EAASxE,IACrBqD,EAAIrD,GAAKuG,EAAMhC,EAASvE,GACxByG,EAASzG,GAAK4F,EAAQrB,EAASvE,GAGnC,IAAI6E,EAAUR,EAASC,EAAU,EAC7BQ,EAAUN,EAAU,EACpBO,EAAOR,EAASC,EAAU,EAC1BW,EAAe,EACfC,EAAa,EAQjB,GANAmB,EAAMxB,GAAQwB,EAAM1B,GACpBe,EAAQb,GAAQa,EAAQf,GAExBE,IACAF,IAEmB,MAAZP,EAAP,CAWA,GAAgB,IAAZE,EAAe,CAMf,IAHAY,GAFAL,GAAQT,GAEY,EACpBa,GAFAN,GAAWP,GAEc,EAEpBtE,EAAIsE,EAAU,EAAGtE,GAAK,EAAGA,IAC1BuG,EAAMnB,EAAapF,GAAKuG,EAAMpB,EAAenF,GAC7C4F,EAAQR,EAAapF,GAAK4F,EAAQT,EAAenF,GAKrD,OAFAuG,EAAMxB,GAAQ1B,EAAIyB,QAClBc,EAAQb,GAAQ0B,EAAS3B,IAM7B,IArDyC,IAmDpC3B,EAAatG,KAAbsG,YAEQ,CACT,IAAI6B,EAAS,EACTC,EAAS,EACTC,GAAO,EAEX,GACI,GAAIlI,EAAQqG,EAAIyB,GAAUyB,EAAM1B,IAAY,GAOxC,GANA0B,EAAMxB,GAAQwB,EAAM1B,GACpBe,EAAQb,GAAQa,EAAQf,GACxBE,IACAF,IACAG,IACAC,EAAS,EACU,MAAZX,EAAe,CAClBY,GAAO,EACP,YASJ,GANAqB,EAAMxB,GAAQ1B,EAAIyB,GAClBc,EAAQb,GAAQ0B,EAAS3B,GACzBC,IACAD,IACAG,IACAD,EAAS,EACU,MAAZR,EAAe,CAClBU,GAAO,EACP,cAGFF,EAASC,GAAU9B,GAE7B,GAAI+B,EACA,MAGJ,EAAG,CAUC,GAAe,KATfF,EAASV,EAAUG,EACfpB,EAAIyB,GACJyB,EACAlC,EACAC,EACAA,EAAU,EACVtH,IAGc,CAOd,IAJAsH,GAAWU,EACXI,GAHAL,GAAQC,GAGY,EACpBG,GAHAN,GAAWG,GAGc,EAEpBhF,EAAIgF,EAAS,EAAGhF,GAAK,EAAGA,IACzBuG,EAAMnB,EAAapF,GAAKuG,EAAMpB,EAAenF,GAC7C4F,EAAQR,EAAapF,GAAK4F,EAAQT,EAAenF,GAGrD,GAAgB,IAAZsE,EAAe,CACfY,GAAO,EACP,OASR,GALAqB,EAAMxB,GAAQ1B,EAAIyB,GAClBc,EAAQb,GAAQ0B,EAAS3B,GACzBC,IACAD,IAEmB,MAAZN,EAAe,CAClBU,GAAO,EACP,MAYJ,GAAe,KATfD,EAAST,EAAUE,EACf6B,EAAM1B,GACNxB,EACA,EACAmB,EACAA,EAAU,EACVxH,IAGc,CAOd,IAJAwH,GAAWS,EACXG,GAHAL,GAAQE,GAGY,EACpBE,GAHAL,GAAWG,GAGc,EAEpBjF,EAAI,EAAGA,EAAIiF,EAAQjF,IACpBuG,EAAMnB,EAAapF,GAAKqD,EAAI8B,EAAenF,GAC3C4F,EAAQR,EAAapF,GAAKyG,EAAStB,EAAenF,GAGtD,GAAIwE,GAAW,EAAG,CACdU,GAAO,EACP,OASR,GALAqB,EAAMxB,GAAQwB,EAAM1B,GACpBe,EAAQb,GAAQa,EAAQf,GACxBE,IACAF,IAEmB,MAAZP,EAAe,CAClBY,GAAO,EACP,MAGJ/B,UAEA6B,GAp6Bc,GAq6BXC,GAr6BW,GAw6BlB,GAAIC,EACA,MAGA/B,EAAY,IACZA,EAAY,GAGhBA,GAAa,EASjB,GANAtG,KAAKsG,UAAYA,EAEbA,EAAY,IACZtG,KAAKsG,UAAY,GAGL,IAAZqB,EAAe,CAMf,IAHAY,GAFAL,GAAQT,GAEY,EACpBa,GAFAN,GAAWP,GAEc,EAEpBtE,EAAIsE,EAAU,EAAGtE,GAAK,EAAGA,IAC1BuG,EAAMnB,EAAapF,GAAKuG,EAAMpB,EAAenF,GAC7C4F,EAAQR,EAAapF,GAAK4F,EAAQT,EAAenF,GAGrDuG,EAAMxB,GAAQ1B,EAAIyB,GAClBc,EAAQb,GAAQ0B,EAAS3B,OACtB,IAAgB,IAAZN,EACP,MAAM,IAAI/E,MAAM,8CAGhB,IADA0F,EAAeJ,GAAQP,EAAU,GAC5BxE,EAAI,EAAGA,EAAIwE,EAASxE,IACrBuG,EAAMpB,EAAenF,GAAKqD,EAAIrD,GAC9B4F,EAAQT,EAAenF,GAAKyG,EAASzG,SAlLzC,IAFAmF,EAAeJ,GAAQP,EAAU,GAE5BxE,EAAI,EAAGA,EAAIwE,EAASxE,IACrBuG,EAAMpB,EAAenF,GAAKqD,EAAIrD,GAC9B4F,EAAQT,EAAenF,GAAKyG,EAASzG,O,KAiRrD/B,EAAOC,QAAU,CACbK,KAlFJ,SAAegI,EAAOvJ,EAAS8D,EAAIC,GAC/B,IAAKyC,MAAMkD,QAAQH,GACf,MAAM,IAAII,UAAJ,0DACiDJ,IAI3DX,EAAU,GAMV,IAbmC,IAS5BjF,EAAU4F,EAAV5F,OAEHX,EAAI,EAEDA,EAAIW,GACPiF,EAAQ5F,GAAKA,IAOZhD,EAEyB,oBAAZA,IACd+D,EAAKD,EACLA,EAAK9D,EACLA,EAAU+I,GAJV/I,EAAU+I,EAOTjF,IACDA,EAAK,GAEJC,IACDA,EAAKJ,GAGT,IAAI0E,EAAYtE,EAAKD,EAGrB,GAAIuE,EAAY,EACZ,OAAOO,EAGX,IAAInC,EAAY,EAEhB,GAAI4B,EA9gCkB,GAihClB,OADAE,EAAoBgB,EAAOzF,EAAIC,EAAID,GADnC2C,EAAY6B,EAAiBiB,EAAOzF,EAAIC,EAAI/D,IACOA,GAC5C4I,EAGX,IAAMgB,EAAK,IAAI1D,EAAQqD,EAAOvJ,GAExBsF,EAn6BV,SAAuBnC,GAGnB,IAFA,IAAIG,EAAI,EAEDH,GAtHe,IAuHlBG,GAAU,EAAJH,EACNA,IAAM,EAGV,OAAOA,EAAIG,EA25BIiC,CAAa8C,GAE5B,EAAG,CAEC,IADA5B,EAAY6B,EAAiBiB,EAAOzF,EAAIC,EAAI/D,IAC5BsF,EAAQ,CACpB,IAAIkD,EAAQH,EACRG,EAAQlD,IACRkD,EAAQlD,GAGZiD,EAAoBgB,EAAOzF,EAAIA,EAAK0E,EAAO1E,EAAK2C,EAAWzG,GAC3DyG,EAAY+B,EAGhBoB,EAAGnB,QAAQ3E,EAAI2C,GACfmD,EAAGlB,YAGHL,GAAa5B,EACb3C,GAAM2C,QACa,IAAd4B,GAKT,OAFAuB,EAAGjB,iBAEIC,K,kIChjCE1C,EAAb,kDAKI,WAAYtG,GAAkB,IAAD,8BACzB,cAAMA,IACDiF,UAAY,GACjB,EAAKgF,WAAa,EAClB,EAAKC,QAAU,GACf,EAAKC,OAAS,GACd,EAAKrD,UAAY,EACjB,EAAK/F,SAAW,UAPS,EALjC,2CAqBI,SAAQmD,EAAIC,GAORlE,KAAK6G,UAAY,EACjB7G,KAAKiK,QAAU,GACfjK,KAAKkK,OAAS,GAEdlK,KAAKmK,WAAWnK,KAAKY,UAAWqD,EAAIC,GACpC,IAAIkG,EAAalG,EAAKD,EACtB,KAAImG,EAAa,GAGjB,GAAIA,EAAapK,KAAKgF,UAAtB,CACI,IAAIqF,EAAarK,KAAKsK,yBAAyBrG,EAAIC,GACnDlE,KAAKuK,WAAWtG,EAAIC,EAAID,EAAKoG,OAFjC,CAUA,IAAI5E,EAASzF,KAAK0F,aAAa0E,GAC/B,EAAG,CAEC,IAAII,EAAYxK,KAAKsK,yBAAyBrG,EAAIC,GAGlD,GAAIsG,EAAY/E,EAAQ,CACpB,IAAIkD,EAAQyB,GAAc3E,EAAS2E,EAAa3E,EAChDzF,KAAKuK,WAAWtG,EAAIA,EAAK0E,EAAO1E,EAAKuG,GACrCA,EAAY7B,EAIhB3I,KAAK4I,QAAQ3E,EAAIuG,GACjBxK,KAAKyK,gBAGLxG,GAAMuG,EACNJ,GAAcI,QACM,IAAfJ,GAGTpK,KAAK0K,wBArEb,wBAuFI,SAAWzG,EAAIC,EAAI8C,GAEf,IADIA,IAAU/C,GAAI+C,IACXA,EAAQ9C,EAAI8C,IAAS,CAUxB,IARA,IAAI7C,EAAQnE,KAAKM,KAAK0G,GAGlB/B,EAAOhB,EACPiB,EAAQ8B,EAIL/B,EAAOC,GAAO,CACjB,IAAIX,EAAOU,EAAOC,IAAW,EAEzBf,EAAQnE,KAAKM,KAAKiE,GAClBW,EAAQX,EAERU,EAAOV,EAAM,EAOrB,IAAIjB,EAAI0D,EAAQ/B,EAEhB,OAAQ3B,GACJ,KAAK,EAEDtD,KAAKO,MAAM0E,EAAO,EAAGjF,KAAKM,KAAK2E,EAAO,IACtC,MACJ,KAAK,EAEDjF,KAAKO,MAAM0E,EAAO,EAAGjF,KAAKM,KAAK2E,IAC/B,MACJ,QAEI,KAAO3B,EAAI,GAEPtD,KAAKO,MAAM0E,EAAO3B,EAAGtD,KAAKM,KAAK2E,EAAO3B,EAAI,IAC1CA,IAIZtD,KAAKO,MAAM0E,EAAMd,MApI7B,sCA8JI,SAAyBF,EAAIC,GACzB,IAAI4C,EAAQ7C,EAAK,EACjB,GAAI6C,IAAU5C,EACV,OAAO,EAKX,GAAIlE,KAAKG,QAAQ2G,EAAO7C,EAAI,KAAM,CAE9B,KAAO6C,EAAQ5C,GAAMlE,KAAKG,QAAQ2G,EAAOA,EAAQ,EAAG,MAChDA,IAEJ9G,KAAK2K,aAAa1G,EAAI6C,QAGtB,KAAOA,EAAQ5C,GAAMlE,KAAKG,QAAQ2G,EAAOA,EAAQ,EAAG,OAChDA,IAIR,OAAOA,EAAQ7C,IAnLvB,0BA+LI,SAAmCA,EAAYC,GAE3C,IADAA,IACOD,EAAKC,GAAI,CAIZ,IAAIkC,EAAIpG,KAAKM,KAAK2D,GAClBjE,KAAKO,MAAM0D,IAAMC,GACjBlE,KAAKO,MAAM2D,IAAMkC,MAvM7B,0BA6NI,SAAqB9C,GAYjB,IAFA,IAAIG,EAAI,EAEDH,GAAKtD,KAAKgF,WACbvB,GAAU,EAAJH,EACNA,IAAM,EAGV,OAAOA,EAAIG,IA9OnB,qBAuPI,SAAQmH,EAAYC,GAIhB7K,KAAKiK,QAAQjK,KAAK6G,WAAa+D,EAI/B5K,KAAKkK,OAAOlK,KAAK6G,WAAagE,EAC9B7K,KAAK6G,cAhQb,2BA2QI,WACI,KAAO7G,KAAK6G,UAAY,GAAG,CACvB,IAAIvD,EAAItD,KAAK6G,UAAY,EACzB,GAAIvD,EAAI,GAAKtD,KAAKkK,OAAO5G,EAAI,IAAMtD,KAAKkK,OAAO5G,GAAKtD,KAAKkK,OAAO5G,EAAI,GAC5DtD,KAAKkK,OAAO5G,EAAI,GAAKtD,KAAKkK,OAAO5G,EAAI,IAAIA,IAC7CtD,KAAKuH,QAAQjE,OACV,MAAItD,KAAKkK,OAAO5G,IAAMtD,KAAKkK,OAAO5G,EAAI,IAGzC,MAFAtD,KAAKuH,QAAQjE,OAlR7B,gCA4RI,WACI,KAAOtD,KAAK6G,UAAY,GAAG,CACvB,IAAIvD,EAAItD,KAAK6G,UAAY,EACrBvD,EAAI,GAAKtD,KAAKkK,OAAO5G,EAAI,GAAKtD,KAAKkK,OAAO5G,EAAI,IAAIA,IACtDtD,KAAKuH,QAAQjE,MAhSzB,qBA2SI,SAAQH,GAEJ,IAAI2H,EAAQ9K,KAAKiK,QAAQ9G,GACrBkC,EAAOrF,KAAKkK,OAAO/G,GACnB4H,EAAQ/K,KAAKiK,QAAQ9G,EAAI,GACzBmC,EAAOtF,KAAKkK,OAAO/G,EAAI,GAO3BnD,KAAKkK,OAAO/G,GAAKkC,EAAOC,EACpBnC,IAAMnD,KAAK6G,UAAY,IACvB7G,KAAKiK,QAAQ9G,EAAI,GAAKnD,KAAKiK,QAAQ9G,EAAI,GACvCnD,KAAKkK,OAAO/G,EAAI,GAAKnD,KAAKkK,OAAO/G,EAAI,IAEzCnD,KAAK6G,YAQL,IAAIrB,EAAIxF,KAAK4H,YAAY5H,KAAKM,KAAKyK,IAAQ,EAAMD,EAAOzF,EAAM,GAC9DyF,GAAStF,EAEI,KADbH,GAAQG,IAUK,KAFbF,EAAOtF,KAAK6H,WAAW7H,KAAKM,KAAKwK,EAAQzF,EAAO,IAAI,EAAM0F,EAAOzF,EAAMA,EAAO,MAK1ED,GAAQC,EACRtF,KAAKgL,QAAQF,EAAOzF,EAAM0F,EAAOzF,GAEjCtF,KAAKiL,QAAQH,EAAOzF,EAAM0F,EAAOzF,MAtV7C,wBAyWI,SAAWvB,EAAKmD,EAAOgE,EAAMhI,EAAKiE,GAC9B,IAAIgE,EAAU,EACVC,EAAM,EACV,GAAKlE,EAiDE,CAEH,GAAInD,EAAM/D,KAAKU,QAAQwK,EAAO/D,EAAM,GAAI,CAIpC,IAFA,IAAIkE,EAASnI,EAAMiE,EAEZiE,EAAMC,GAAUtH,EAAM/D,KAAKU,QAAQwK,EAAO/D,EAAOiE,EAAK,IACzDD,EAAUC,GACVA,EAAmB,GAAZA,GAAO,KACH,IACPA,EAAMC,GAEVD,EAAMC,IAAQD,EAAMC,GAGxBF,GAAWhE,EACXiE,GAAOjE,MACJ,CAIH,IAFA,IAAIkE,EAASlE,EAAO,EAEbiE,EAAMC,GAAUtH,GAAO/D,KAAKU,QAAQwK,EAAO/D,EAAOiE,EAAK,IAC1DD,EAAUC,GACVA,EAAmB,GAAZA,GAAO,KACH,IACPA,EAAMC,GAEVD,EAAMC,IAAQD,EAAMC,GAGxB,IAAI7E,EAAM2E,EACVA,EAAUhE,EAAOiE,EACjBA,EAAMjE,EAAOX,EAQjB,IADA2E,IACOA,EAAUC,GAAK,CAClB,IAAIhG,EAAI+F,GAAYC,EAAMD,IAAa,GAGnCpH,EAAM/D,KAAKU,QAAQwK,EAAO9F,EAAG,GAC7B+F,EAAU/F,EAAI,EAEdgG,EAAMhG,OAhGN,CAER,GAAIrB,EAAM/D,KAAKM,KAAK4K,EAAO/D,GAAO,CAI9B,IAFA,IAAIkE,EAASnI,EAAMiE,EAEZiE,EAAMC,GAAUtH,EAAM/D,KAAKM,KAAK4K,EAAO/D,EAAOiE,IACjDD,EAAUC,GACVA,EAAmB,GAAZA,GAAO,KACH,IACPA,EAAMC,GAEVD,EAAMC,IAAQD,EAAMC,GAGxBF,GAAWhE,EACXiE,GAAOjE,MACJ,CAIH,IAFA,IAAIkE,EAASlE,EAAO,EAEbiE,EAAMC,GAAUtH,GAAO/D,KAAKM,KAAK4K,EAAO/D,EAAOiE,IAClDD,EAAUC,GACVA,EAAmB,GAAZA,GAAO,KACH,IACPA,EAAMC,GAEVD,EAAMC,IAAQD,EAAMC,GAGxB,IAAI7E,EAAM2E,EACVA,EAAUhE,EAAOiE,EACjBA,EAAMjE,EAAOX,EAQjB,IADA2E,IACOA,EAAUC,GAAK,CAClB,IAAIhG,EAAI+F,GAAYC,EAAMD,IAAa,GAGnCpH,EAAM/D,KAAKM,KAAK4K,EAAO9F,GACvB+F,EAAU/F,EAAI,EAEdgG,EAAMhG,GAoDlB,OAAOgG,IA/cf,yBA+dI,SAAYrH,EAAKmD,EAAOgE,EAAMhI,EAAKiE,GAC/B,IAAIiE,EAAM,EACND,EAAU,EACd,GAAKjE,EAiDE,CAEH,GAAInD,EAAM/D,KAAKU,QAAQwK,EAAO/D,EAAM,GAAI,CAIpC,IAFA,IAAIkE,EAASlE,EAAO,EAEbiE,EAAMC,GAAUtH,EAAM/D,KAAKU,QAAQwK,EAAO/D,EAAOiE,EAAK,IACzDD,EAAUC,GACVA,EAAmB,GAAZA,GAAO,KACH,IACPA,EAAMC,GAEVD,EAAMC,IAAQD,EAAMC,GAGxB,IAAI7E,EAAM2E,EACVA,EAAUhE,EAAOiE,EACjBA,EAAMjE,EAAOX,MACV,CAIH,IAFA,IAAI6E,EAASnI,EAAMiE,EAEZiE,EAAMC,GAAUtH,GAAO/D,KAAKU,QAAQwK,EAAO/D,EAAOiE,EAAK,IAC1DD,EAAUC,GACVA,EAAmB,GAAZA,GAAO,KACH,IACPA,EAAMC,GAEVD,EAAMC,IAAQD,EAAMC,GAGxBF,GAAWhE,EACXiE,GAAOjE,EAQX,IADAgE,IACOA,EAAUC,GAAK,CAClB,IAAIhG,EAAI+F,GAAYC,EAAMD,IAAa,GAGnCpH,EAAM/D,KAAKU,QAAQwK,EAAO9F,EAAG,GAC7BgG,EAAMhG,EAEN+F,EAAU/F,EAAI,OAhGd,CAER,GAAIrB,EAAM/D,KAAKM,KAAK4K,EAAO/D,GAAO,CAI9B,IAFA,IAAIkE,EAASlE,EAAO,EAEbiE,EAAMC,GAAUtH,EAAM/D,KAAKM,KAAK4K,EAAO/D,EAAOiE,IACjDD,EAAUC,GACVA,EAAmB,GAAZA,GAAO,KACH,IACPA,EAAMC,GAEVD,EAAMC,IAAQD,EAAMC,GAGxB,IAAI7E,EAAM2E,EACVA,EAAUhE,EAAOiE,EACjBA,EAAMjE,EAAOX,MACV,CAIH,IAFA,IAAI6E,EAASnI,EAAMiE,EAEZiE,EAAMC,GAAUtH,GAAO/D,KAAKM,KAAK4K,EAAO/D,EAAOiE,IAClDD,EAAUC,GACVA,EAAmB,GAAZA,GAAO,KACH,IACPA,EAAMC,GAEVD,EAAMC,IAAQD,EAAMC,GAGxBF,GAAWhE,EACXiE,GAAOjE,EAQX,IADAgE,IACOA,EAAUC,GAAK,CAClB,IAAIhG,EAAI+F,GAAYC,EAAMD,IAAa,GAGnCpH,EAAM/D,KAAKM,KAAK4K,EAAO9F,GACvBgG,EAAMhG,EAEN+F,EAAU/F,EAAI,GAoD1B,OAAOgG,IArkBf,qBAqlBI,SAAQN,EAAOrD,EAASsD,EAAOpD,GAO3B,IAFA,IAAInB,EAAMxG,KAAKQ,eAAesK,EAAQrD,GAE7BtE,EAAI,EAAGA,EAAIsE,EAAStE,IAEzBnD,KAAKW,SAASwC,EAAGnD,KAAKM,KAAKwK,EAAM3H,GAAIqD,GAIzC,IAAIwB,EAAU,EACVC,EAAU8C,EACV7C,EAAO4C,EAKX,GADA9K,KAAKO,MAAM2H,IAAQlI,KAAKM,KAAK2H,MACX,MAAZN,EAQN,GAAgB,IAAZF,EAAJ,CAeA,IAAInB,EAAYtG,KAAKgK,WACrBsB,EACI,OAAa,CACT,IAAInD,EAAS,EACTC,EAAS,EAKb,GAEI,GAAIpI,KAAKM,KAAK2H,GAAWjI,KAAKU,QAAQsH,EAASxB,IAK3C,GAHAxG,KAAKO,MAAM2H,IAAQlI,KAAKM,KAAK2H,MAC7BG,IACAD,EAAS,EACS,MAAZR,EAAe,MAAM2D,OAM3B,GAHAtL,KAAKO,MAAM2H,IAAQlI,KAAKM,KAAK0H,MAC7BG,IACAC,EAAS,EACS,MAAZX,EAAe,MAAM6D,SAEzBnD,EAASC,GAAU9B,GAM7B,EAAG,CAGC,GAAe,KADf6B,EAASnI,KAAK4H,YAAY5H,KAAKM,KAAK2H,IAAU,EAAMD,EAASP,EAAS,IACpD,CAEd,IAAK,IAAItE,EAAI,EAAGA,EAAIgF,EAAQhF,IACxBnD,KAAKO,MAAM2H,EAAO/E,EAAGnD,KAAKU,QAAQsH,EAAU7E,EAAGqD,IAKnD,GAHA0B,GAAQC,EACRH,GAAWG,GACXV,GAAWU,IACI,EACX,MAAMmD,EAId,GADAtL,KAAKO,MAAM2H,IAAQlI,KAAKM,KAAK2H,MACX,MAAZN,EAAe,MAAM2D,EAG3B,GAAe,KADflD,EAASpI,KAAK6H,WAAWrB,EAAIwB,IAAU,EAAOC,EAASN,EAAS,IAC9C,CAEd,IAAK,IAAIxE,EAAI,EAAGA,EAAIiF,EAAQjF,IAExBnD,KAAKO,MAAM2H,EAAO/E,EAAGnD,KAAKM,KAAK2H,EAAU9E,IAK7C,GAHA+E,GAAQE,EACRH,GAAWG,EAEK,KADhBT,GAAWS,GACQ,MAAMkD,EAI7B,GADAtL,KAAKO,MAAM2H,IAAQlI,KAAKU,QAAQsH,IAAWxB,IACzB,MAAZiB,EAAe,MAAM6D,EAC3BhF,UACK6B,GAAUnI,KAAKgK,YAAc5B,GAAUpI,KAAKgK,YACjD1D,EAAY,IAAGA,EAAY,GAC/BA,GAAa,EAIrB,GAFAtG,KAAKsG,UAAYA,EAAY,EAAI,EAAIA,EAErB,IAAZmB,EAAe,CAGf,IAAK,IAAItE,EAAI,EAAGA,EAAIwE,EAASxE,IACzBnD,KAAKO,MAAM2H,EAAO/E,EAAGnD,KAAKM,KAAK2H,EAAU9E,IAE7CnD,KAAKO,MAAM2H,EAAOP,EAAS3H,KAAKU,QAAQsH,EAASxB,QAC9C,IAAgB,IAAZiB,EACP,MAAM,IAAI7E,MAAM,8EAGhB,IAAK,IAAIO,EAAI,EAAGA,EAAIsE,EAAStE,IACzBnD,KAAKO,MAAM2H,EAAO/E,EAAGnD,KAAKU,QAAQsH,EAAU7E,EAAGqD,IAGvDxG,KAAKS,eAAe+F,OApGpB,CAII,IAAK,IAAIrD,EAAI,EAAGA,EAAIwE,EAASxE,IAEzBnD,KAAKO,MAAM2H,EAAO/E,EAAGnD,KAAKM,KAAK2H,EAAU9E,IAG7CnD,KAAKO,MAAM2H,EAAOP,EAAS3H,KAAKU,QAAQsH,EAASxB,SAfjD,IAAK,IAAIrD,EAAI,EAAGA,EAAIsE,EAAStE,IAEzBnD,KAAKO,MAAM2H,EAAO/E,EAAGnD,KAAKU,QAAQsH,EAAU7E,EAAGqD,MA7mB/D,qBAmuBI,SAAQsE,EAAOzF,EAAM0F,EAAOzF,GAQxB,IAFA,IAAIkB,EAAMxG,KAAKQ,eAAeuK,EAAQzF,GAE7BnC,EAAI,EAAGA,EAAI4H,EAAO5H,IACvBoI,QAAQC,IAAIT,EAAM,GAClB/K,KAAKW,SAASwC,EAAGnD,KAAKM,KAAKyK,EAAM5H,GAAIqD,GAIzC,IAAIwB,EAAU8C,EAAQzF,EAAO,EACzB4C,EAAU3C,EAAO,EACjB4C,EAAO6C,EAAQzF,EAAO,EAK1B,GADAtF,KAAKO,MAAM2H,IAAQlI,KAAKM,KAAK0H,MACd,MAAT3C,EAWN,GAAa,IAATC,EAAJ,CAmBA,IAAIgB,EAAYtG,KAAKgK,WACrBsB,EACI,OAAa,CACT,IAAInD,EAAS,EACTC,EAAS,EAKb,GAEI,GAAIpI,KAAKU,QAAQuH,EAASzB,GAAOxG,KAAKM,KAAK0H,IAKvC,GAHAhI,KAAKO,MAAM2H,IAAQlI,KAAKM,KAAK0H,MAC7BG,IACAC,EAAS,EACM,MAAT/C,EAAY,MAAMiG,OAMxB,GAHAtL,KAAKO,MAAM2H,IAAQlI,KAAKU,QAAQuH,IAAWzB,IAC3C4B,IACAD,EAAS,EACM,MAAT7C,EAAY,MAAMgG,SAEtBnD,EAASC,GAAU9B,GAM7B,EAAG,CAGC,GAAe,KADf6B,EAAS9C,EAAOrF,KAAK4H,YAAYpB,EAAIyB,IAAU,EAAO6C,EAAOzF,EAAMA,EAAO,IACxD,CAGdA,GAAQ8C,EAIR,IAHA,IAAII,GAHJL,GAAQC,GAGgB,EACpBG,GAHJN,GAAWG,GAGkB,EAEpBhF,EAAIgF,EAAS,EAAGhF,GAAK,EAAGA,IAC7BnD,KAAKO,MAAMgI,EAAapF,EAAGnD,KAAKM,KAAKgI,EAAenF,IAGxD,GAAa,IAATkC,EAAY,MAAMiG,EAI1B,GADAtL,KAAKO,MAAM2H,IAAQlI,KAAKU,QAAQuH,IAAWzB,IAC5B,MAATlB,EAAY,MAAMgG,EAIxB,GAAe,KADflD,EAAS9C,EAAOtF,KAAK6H,WAAW7H,KAAKM,KAAK0H,IAAU,EAAM,EAAG1C,EAAMA,EAAO,IACxD,CAGdA,GAAQ8C,EAIR,IAHA,IAAIG,GAHJL,GAAQE,GAGgB,EACpBE,GAHJL,GAAWG,GAGkB,EAEpBjF,EAAI,EAAGA,EAAIiF,EAAQjF,IACxBnD,KAAKO,MAAMgI,EAAapF,EAAGnD,KAAKU,QAAQ4H,EAAenF,EAAGqD,IAE9D,GAAIlB,GAAQ,EACR,MAAMgG,EAId,GADAtL,KAAKO,MAAM2H,IAAQlI,KAAKM,KAAK0H,MACd,MAAT3C,EAAY,MAAMiG,EACxBhF,UACK6B,GAAUnI,KAAKgK,YAAc5B,GAAUpI,KAAKgK,YACjD1D,EAAY,IAAGA,EAAY,GAC/BA,GAAa,EAIrB,GAFAtG,KAAKsG,UAAYA,EAAY,EAAI,EAAIA,EAExB,IAAThB,EAAY,CASZ,IAHA,IAAIiD,GALJL,GAAQ7C,GAKgB,EACpBiD,GALJN,GAAW3C,GAKkB,EAEpBlC,EAAIkC,EAAO,EAAGlC,GAAK,EAAGA,IAE3BnD,KAAKO,MAAMgI,EAAapF,EAAGnD,KAAKM,KAAKgI,EAAenF,IAKxDnD,KAAKO,MAAM2H,EAAMlI,KAAKU,QAAQuH,EAASzB,QAEpC,IAAa,IAATlB,EACP,MAAM,IAAI1C,MAAM,8EAIhB,IADA,IAAI0F,EAAeJ,GAAQ5C,EAAO,GACzBnC,EAAI,EAAGA,EAAImC,EAAMnC,IAEtBnD,KAAKO,MAAM+H,EAAenF,EAAGnD,KAAKU,QAAQyC,EAAGqD,IAGrDxG,KAAKS,eAAe+F,OA1HpB,CAQI,IAHA,IAAI+B,GAJJL,GAAQ7C,GAIgB,EACpBiD,GAJJN,GAAW3C,GAIkB,EAEpBlC,EAAIkC,EAAO,EAAGlC,GAAK,EAAGA,IAE3BnD,KAAKO,MAAMgI,EAAapF,EAAGnD,KAAKM,KAAKgI,EAAenF,IAIxDnD,KAAKO,MAAM2H,EAAMlI,KAAKU,QAAQuH,EAASzB,SApBvC,IAFA,IAAI8B,EAAeJ,GAAQ6C,EAAQ,GAE1B5H,EAAI,EAAGA,EAAI4H,EAAO5H,IACvBnD,KAAKO,MAAM+H,EAAenF,EAAGnD,KAAKU,QAAQyC,EAAGqD,MA9vB7D,wBA04BI,SAAWiF,EAAUC,EAAWC,GAC5B,GAAID,EAAYC,EAAS,MAAM,IAAI/I,MAAM,6BAA+B8I,EAAY,eAAiBC,EAAU,KAC/G,GAAID,EAAY,EAAG,MAAM,IAAI9I,MAAM,yBAA2B8I,GAC9D,GAAIC,EAAUF,EAAU,MAAM,IAAI7I,MAAM,yBAA2B+I,OA74B3E,G,KAA6B7L,O,mHCoBvBkJ,EAAgB,CAAC,EAAK,GAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAUvD3C,EAAb,kDAWI,WAAYtG,GAAkB,IAAD,8BACzB,cAAMA,IATVuG,UAzB0B,EAiCG,EAN7BC,iBArB+B,IA2BF,EAL7BE,YAAc,EAKe,EAJ7BC,SAAW,KAIkB,EAH7BE,UAAY,KAGiB,EAF7BC,UAAY,EAKR,EAAK/C,OAAS,EAAKlD,UAEf,EAAKkD,OAAS,MACd,EAAKyC,iBAAmB,EAAKzC,SAAW,GAG5C,EAAK0C,IAAM,EAAKhG,eAAe,EAAK+F,kBAIpC,EAAKE,YACA,EAAK3C,OAAS,IAAM,EACjB,EAAKA,OAAS,KAAO,GACjB,EAAKA,OAAS,OAAS,GAAK,GAExC,EAAK4C,SAAW,IAAIC,MAAM,EAAKF,aAC/B,EAAKG,UAAY,IAAID,MAAM,EAAKF,aAnBP,EAXjC,yCAiCI,SAAMlB,GACF,OAAIA,EAAI,IACAA,EAAI,IACGA,EAAI,GAAM,EAAI,EAGrBA,EAAI,IACGA,EAAI,IAAM,EAAI,EAGlB,EAGPA,EAAI,IACGA,EAAI,IAAM,EAAI,EAGrBA,EAAI,IACGA,EAAI,IAAM,EAAI,EAGlB,IAtDf,iCAiEI,SAAoB4D,EAAGC,GACnB,GAAID,IAAMC,EACN,OAAO,EAGX,KAAMD,IAAMA,KAAOC,IAAMA,EAAG,CACxB,GAAU,IAAND,GAAiB,IAANC,EACX,OAAOD,EAAIC,GAAK,EAAI,EAGxB,GAAID,EAAI,GAAKC,EAAI,EAAG,CAChB,GAAIA,GAAK,EACL,OAAQ,EAGZ,GAAID,GAAK,EACL,OAAO,EAGXA,GAAKA,EACLC,GAAKA,EAGT,IAAMC,EAAKrJ,KAAKiJ,MAAME,GAChBG,EAAKtJ,KAAKiJ,MAAMG,GAElBhD,EAAI,EAYR,OAVIiD,EAAKC,GACLH,GAAKH,EAAcM,EAAKD,EAAK,GAC7BD,GAAK,GACLhD,GAAK,GACEiD,EAAKC,IACZF,GAAKJ,EAAcK,EAAKC,EAAK,GAC7BH,GAAK,GACL/C,EAAI,GAGJ+C,IAAMC,EACChD,EAGJ+C,EAAIC,GAAK,EAAI,EAGxB,IAAIG,EAAOC,OAAOL,GACdM,EAAOD,OAAOJ,GAElB,OAAIG,IAASE,EACF,EAGJF,EAAOE,GAAQ,EAAI,IArHlC,0BA6HI,SAAanG,GAGT,IAFA,IAAIG,EAAI,EAEDH,GA3JW,IA4JdG,GAAU,EAAJH,EACNA,IAAM,EAGV,OAAOA,EAAIG,IArInB,8BAmJI,SAAiBQ,EAAIC,GACjB,IAAI4C,EAAQ7C,EAAK,EAEjB,GAAI6C,IAAU5C,EACV,OAAO,EAKX,GAAIlE,KAAKG,QAAQ2G,IAAS7C,EAAI,KAAM,CAEhC,KAAO6C,EAAQ5C,GAAMlE,KAAKG,QAAQ2G,EAAOA,EAAQ,EAAG,MAChDA,IAGJ9G,KAAK+G,WAAW9C,EAAI6C,QAIpB,KAAOA,EAAQ5C,GAAMlE,KAAKG,QAAQ2G,EAAOA,EAAQ,EAAG,OAChDA,IAIR,OAAOA,EAAQ7C,IA3KvB,wBAqLI,SAAWA,EAAIC,GAGX,IAFAA,IAEOD,EAAKC,GAAI,CAEZ,IAAIkC,EAAIpG,KAAKM,KAAK2D,GAElBjE,KAAKO,MAAM0D,IAAMjE,KAAKM,KAAK4D,IAE3BlE,KAAKO,MAAM2D,IAAMkC,MA9L7B,iCA4MI,SAAqBnC,EAAIC,EAAI8C,GAKzB,IAJIA,IAAU/C,GACV+C,IAGGA,EAAQ9C,EAAI8C,IAAS,CAYxB,IAVA,IAAI7C,EAAQnE,KAAKM,KAAK0G,GAGlB/B,EAAOhB,EACPiB,EAAQ8B,EAML/B,EAAOC,GAAO,CACjB,IAAIX,EAAOU,EAAOC,IAAW,EAGzBf,EAAQnE,KAAKM,KAAKiE,GAAO,EACzBW,EAAQX,EAERU,EAAOV,EAAM,EASrB,IAAIjB,EAAI0D,EAAQ/B,EAEhB,OAAQ3B,GACJ,KAAK,EAEDtD,KAAKO,MAAM0E,EAAK,EAAGjF,KAAKM,KAAK2E,EAAK,IAEtC,KAAK,EAEDjF,KAAKO,MAAM0E,EAAK,EAAGjF,KAAKM,KAAK2E,EAAK,IAEtC,KAAK,EAEDjF,KAAKO,MAAM0E,EAAK,EAAGjF,KAAKM,KAAK2E,IAC7B,MACJ,QACI,KAAO3B,EAAI,GAEPtD,KAAKO,MAAM0E,EAAK3B,EAAGtD,KAAKM,KAAK2E,EAAK3B,EAAE,IACpCA,IAKZtD,KAAKO,MAAM0E,EAAMd,MArQ7B,wBAsRI,SAAW8C,EAAOC,EAAOF,EAAOlD,EAAQqD,GACpC,IAAIC,EAAa,EACbC,EAAY,EACZC,EAAS,EACb,IAAKJ,EAAO,CAER,GAAID,EAAQjH,KAAKM,KAAK0G,EAAQG,GAAO,CAIjC,IAHAE,EAAYvD,EAASqD,EAGdG,EAASD,GAAaJ,EAAQjH,KAAKM,KAAK0G,EAAQG,EAAOG,IAC1DF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIbD,GAAcD,EACdG,GAAUH,MAGP,CAGH,IAFAE,EAAYF,EAAO,EAEZG,EAASD,GAAaJ,GAASjH,KAAKM,KAAK0G,EAAQG,EAAOG,IAC3DF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAGbC,EAASD,IACTC,EAASD,GAIb,IAAIb,EAAMY,EACVA,EAAaD,EAAOG,EACpBA,EAASH,EAAOX,EAUpB,IADAY,IACOA,EAAaE,GAAQ,CACxB,IAAIlC,EAAIgC,GAAeE,EAASF,IAAgB,GAG5CH,EAAQjH,KAAKM,KAAK0G,EAAQ5B,GAC1BgC,EAAahC,EAAI,EAGjBkC,EAASlC,EAGjB,OAAOkC,EAGP,GAAIL,EAAQjH,KAAKU,QAAQsG,EAAQG,EAAM,GAAI,CAIvC,IAHAE,EAAYvD,EAASqD,EAGdG,EAASD,GAAaJ,EAAQjH,KAAKU,QAAQsG,EAAQG,EAAOG,EAAQ,IACrEF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIbD,GAAcD,EACdG,GAAUH,MAGP,CAGH,IAFAE,EAAYF,EAAO,EAEZG,EAASD,GAAaJ,GAASjH,KAAKU,QAAQsG,EAAQG,EAAOG,EAAQ,IACtEF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAGbC,EAASD,IACTC,EAASD,GAIb,IAAIb,EAAMY,EACVA,EAAaD,EAAOG,EACpBA,EAASH,EAAOX,EAUpB,IADAY,IACOA,EAAaE,GAAQ,CACxB,IAAIlC,EAAIgC,GAAeE,EAASF,IAAgB,GAG5CH,EAAQjH,KAAKU,QAAQsG,EAAQ5B,EAAG,GAChCgC,EAAahC,EAAI,EAGjBkC,EAASlC,EAIrB,OAAOkC,IA1Zf,yBAyaI,SAAYL,EAAMC,EAAOF,EAAOlD,EAAQqD,GACpC,IAAIC,EAAa,EACbC,EAAY,EACZC,EAAS,EACb,GAAIJ,EAiEC,CACD,GAAID,EAAQjH,KAAKU,QAAQsG,EAAQG,EAAM,GAAI,CAIvC,IAHAE,EAAYF,EAAO,EAGZG,EAASD,GAAaJ,EAAQjH,KAAKU,QAAQsG,EAAQG,EAAOG,EAAQ,IACrEF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIb,IAAIb,EAAMY,EACVA,EAAaD,EAAOG,EACpBA,EAASH,EAAOX,MAGb,CAKH,IAHAa,EAAYvD,EAASqD,EAGdG,EAASD,GAAaJ,GAASjH,KAAKU,QAAQsG,EAAQG,EAAOG,EAAQ,IACtEF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIbD,GAAcD,EACdG,GAAUH,EAWd,IAFAC,IAEOA,EAAaE,GAAQ,CACxB,IAAIlC,EAAIgC,GAAeE,EAASF,IAAgB,GAG5CH,EAAQjH,KAAKU,QAAQsG,EAAQ5B,EAAG,GAChCkC,EAASlC,EAGTgC,EAAahC,EAAI,OAhIlB,CACP,GAAI6B,EAAQjH,KAAKM,KAAK0G,EAAQG,GAAO,CAIjC,IAHAE,EAAYF,EAAO,EAGZG,EAASD,GAAaJ,EAAQjH,KAAKM,KAAK0G,EAAQG,EAAOG,IAC1DF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIb,IAAIb,EAAMY,EACVA,EAAaD,EAAOG,EACpBA,EAASH,EAAOX,MAGb,CAIH,IAHAa,EAAYvD,EAASqD,EAGdG,EAASD,GAAaJ,GAASjH,KAAKM,KAAK0G,EAAQG,EAAOG,IAC3DF,EAAaE,GACbA,EAAyB,GAAfA,GAAU,KAEN,IACVA,EAASD,GAIbC,EAASD,IACTC,EAASD,GAIbD,GAAcD,EACdG,GAAUH,EAWd,IAFAC,IAEOA,EAAaE,GAAQ,CACxB,IAAIlC,EAAIgC,GAAeE,EAASF,IAAgB,GAG5CH,EAAQjH,KAAKM,KAAK0G,EAAQ5B,GAC1BkC,EAASlC,EAGTgC,EAAahC,EAAI,GAsE7B,OAAOkC,IAjjBf,qBA0jBI,SAAQZ,EAAUE,GACd5G,KAAK0G,SAAS1G,KAAK6G,WAAaH,EAChC1G,KAAK4G,UAAU5G,KAAK6G,WAAaD,EACjC5G,KAAK6G,WAAa,IA7jB1B,uBAqkBI,WACI,KAAO7G,KAAK6G,UAAY,GAAG,CACvB,IAAIvD,EAAItD,KAAK6G,UAAY,EAEzB,GAAKvD,GAAK,GACNtD,KAAK4G,UAAUtD,EAAI,IAAMtD,KAAK4G,UAAUtD,GAAKtD,KAAK4G,UAAUtD,EAAI,IAC/DA,GAAK,GACFtD,KAAK4G,UAAUtD,EAAI,IAAMtD,KAAK4G,UAAUtD,GAAKtD,KAAK4G,UAAUtD,EAAI,GAEhEtD,KAAK4G,UAAUtD,EAAI,GAAKtD,KAAK4G,UAAUtD,EAAI,IAC3CA,SAGD,GAAItD,KAAK4G,UAAUtD,GAAKtD,KAAK4G,UAAUtD,EAAI,GAC9C,MAEJtD,KAAKuH,QAAQjE,MArlBzB,4BA4lBI,WACI,KAAOtD,KAAK6G,UAAY,GAAG,CACvB,IAAIvD,EAAItD,KAAK6G,UAAY,EAErBvD,EAAI,GAAKtD,KAAK4G,UAAUtD,EAAI,GAAKtD,KAAK4G,UAAUtD,EAAI,IACpDA,IAGJtD,KAAKuH,QAAQjE,MApmBzB,qBA8mBI,SAAQH,GACJ,IAAIqE,EAASxH,KAAK0G,SAASvD,GACvBsE,EAAUzH,KAAK4G,UAAUzD,GACzBuE,EAAS1H,KAAK0G,SAASvD,EAAI,GAC3BwE,EAAU3H,KAAK4G,UAAUzD,EAAI,GAEjCnD,KAAK4G,UAAUzD,GAAKsE,EAAUE,EAE1BxE,IAAMnD,KAAK6G,UAAY,IACvB7G,KAAK0G,SAASvD,EAAI,GAAKnD,KAAK0G,SAASvD,EAAI,GACzCnD,KAAK4G,UAAUzD,EAAI,GAAKnD,KAAK4G,UAAUzD,EAAI,IAG/CnD,KAAK6G,YAQL,IAAIrB,EAAIxF,KAAK4H,YAAY5H,KAAKM,KAAKoH,IAAS,EAAOF,EAAQC,EAAS,GACpED,GAAUhC,EAGM,KAFhBiC,GAAWjC,IAcK,KAFhBmC,EAAU3H,KAAK6H,WAAW7H,KAAKM,KAAKkH,EAASC,EAAU,IAAI,EAAOC,EAAQC,EAASA,EAAU,MAUzFF,GAAWE,EACX3H,KAAK8H,SAASN,EAAQC,EAASC,EAAQC,GAGvC3H,KAAK+H,UAAUP,EAAQC,EAASC,EAAQC,MA/pBpD,sBAgrBI,SAASH,EAAQC,EAASC,EAAQC,GAE9B,IAAInB,EAAMxG,KAAKwG,IACXrD,EAAI,EAER,IAAKA,EAAI,EAAGA,EAAIsE,EAAStE,IAErBnD,KAAKW,SAASwC,EAAGnD,KAAKM,KAAKkH,EAAOrE,GAAIqD,GAG1C,IAAIwB,EAAU,EACVC,EAAUP,EACVQ,EAAOV,EAKX,GAFAxH,KAAKO,MAAM2H,EAAMlI,KAAKM,KAAK2H,MAET,MAAZN,EAQN,GAAgB,IAAZF,EAAJ,CAYA,IAFA,IAAInB,EAAYtG,KAAKsG,YAER,CACT,IAAI6B,EAAS,EACTC,EAAS,EACTC,GAAO,EAEX,GAEI,GAAIrI,KAAKM,KAAK2H,GAAWjI,KAAKU,QAAQsH,EAASxB,IAM3C,GAJAxG,KAAKO,MAAM2H,IAAQlI,KAAKM,KAAK2H,MAC7BG,IACAD,EAAS,EAES,MAAZR,EAAe,CACjBU,GAAO,EACP,YAQJ,GAHArI,KAAKO,MAAM2H,IAAQlI,KAAKU,QAAQsH,IAAWxB,IAC3C2B,IACAC,EAAS,EACS,MAAZX,EAAe,CACjBY,GAAO,EACP,cAGFF,EAASC,GAAU9B,GAE7B,GAAI+B,EACA,MAGJ,EAAG,CAIC,GAAe,KAFfF,EAASnI,KAAK4H,YAAY5H,KAAKM,KAAK2H,IAAU,EAAMD,EAASP,EAAS,IAEpD,CACd,IAAKtE,EAAI,EAAGA,EAAIgF,EAAQhF,IAEpBnD,KAAKO,MAAM2H,EAAK/E,EAAGnD,KAAKU,QAAQsH,EAAQ7E,EAAGqD,IAM/C,GAHA0B,GAAQC,EACRH,GAAWG,GACXV,GAAWU,IACI,EAAG,CACdE,GAAO,EACP,OAOR,GAFArI,KAAKO,MAAM2H,IAAQlI,KAAKM,KAAK2H,MAEX,MAAZN,EAAe,CACjBU,GAAO,EACP,MAMJ,GAAe,KAFfD,EAASpI,KAAK6H,WAAW7H,KAAKU,QAAQsH,EAASxB,IAAM,EAAOyB,EAASN,EAAS,IAE5D,CACd,IAAKxE,EAAI,EAAGA,EAAIiF,EAAQjF,IAEpBnD,KAAKO,MAAM2H,EAAK/E,EAAGnD,KAAKM,KAAK2H,EAAQ9E,IAOzC,GAJA+E,GAAQE,EACRH,GAAWG,EAGK,KAFhBT,GAAWS,GAEQ,CACfC,GAAO,EACP,OAMR,GAFArI,KAAKO,MAAM2H,IAAQlI,KAAKU,QAAQsH,IAAWxB,IAEzB,MAAZiB,EAAe,CACjBY,GAAO,EACP,MAGJ/B,UAEK6B,GAp0BS,GAo0B0BC,GAp0B1B,GAs0BlB,GAAIC,EACA,MAGA/B,EAAY,IACZA,EAAY,GAGhBA,GAAa,EASjB,GANAtG,KAAKsG,UAAYA,EAEbA,EAAY,IACZtG,KAAKsG,UAAY,GAGL,IAAZmB,EAAe,CACf,IAAKtE,EAAI,EAAGA,EAAIwE,EAASxE,IAErBnD,KAAKO,MAAM2H,EAAK/E,EAAGnD,KAAKM,KAAK2H,EAAQ9E,IAGzCnD,KAAKO,MAAM2H,EAAOP,EAAS3H,KAAKU,QAAQsH,EAASxB,QAG9C,IAAgB,IAAZiB,EACP,MAAM,IAAI7E,MAAM,6CAGhB,IAAKO,EAAI,EAAGA,EAAIsE,EAAStE,IAErBnD,KAAKO,MAAM2H,EAAK/E,EAAGnD,KAAKU,QAAQsH,EAAQ7E,EAAGqD,SAvInD,CACI,IAAKrD,EAAI,EAAGA,EAAIwE,EAASxE,IAErBnD,KAAKO,MAAM2H,EAAK/E,EAAGnD,KAAKM,KAAK2H,EAAQ9E,IAGzCnD,KAAKO,MAAM2H,EAAKP,EAAS3H,KAAKU,QAAQsH,EAASxB,SAb/C,IAAKrD,EAAI,EAAGA,EAAIsE,EAAStE,IAErBnD,KAAKO,MAAM2H,EAAK/E,EAAGnD,KAAKU,QAAQsH,EAAQ7E,EAAGqD,MApsB3D,uBAk2BI,SAAUgB,EAAQC,EAASC,EAAQC,GAC/B,IAAInB,EAAMxG,KAAKwG,IACXrD,EAAI,EAER,IAAKA,EAAI,EAAGA,EAAIwE,EAASxE,IAErBoI,QAAQC,IAAI9D,EAAOvE,GACnBnD,KAAKW,SAASwC,EAAGnD,KAAKM,KAAKoH,EAAOvE,GAAIqD,GAG1C,IAAIwB,EAAUR,EAASC,EAAU,EAC7BQ,EAAUN,EAAU,EACpBO,EAAOR,EAASC,EAAU,EAC1BW,EAAe,EACfC,EAAa,EAKjB,GAFAvI,KAAKO,MAAM2H,IAAQlI,KAAKM,KAAK0H,MAEX,MAAZP,EAWN,GAAgB,IAAZE,EAAJ,CAkBA,IAFA,IAAIrB,EAAYtG,KAAKsG,YAER,CACT,IAAI6B,EAAS,EACTC,EAAS,EACTC,GAAO,EAEX,GAEI,GAAIrI,KAAKU,QAAQuH,EAASzB,GAAOxG,KAAKM,KAAK0H,IAKvC,GAHAhI,KAAKO,MAAM2H,IAAQlI,KAAKM,KAAK0H,MAC7BG,IACAC,EAAS,EACS,MAAZX,EAAe,CACjBY,GAAO,EACP,YAQJ,GAHArI,KAAKO,MAAM2H,IAAQlI,KAAKU,QAAQuH,IAAWzB,IAC3C4B,IACAD,EAAS,EACS,MAAZR,EAAe,CACjBU,GAAO,EACP,cAIFF,EAASC,GAAU9B,GAE7B,GAAI+B,EACA,MAGJ,EAAG,CAIC,GAAe,KAFfF,EAASV,EAAUzH,KAAK4H,YAAY5H,KAAKU,QAAQuH,EAASzB,IAAM,EAAOgB,EAAQC,EAASA,EAAU,IAEhF,CAOd,IAJAA,GAAWU,EACXI,GAHAL,GAAQC,GAGY,EACpBG,GAHAN,GAAWG,GAGc,EAEpBhF,EAAIgF,EAAS,EAAGhF,GAAK,EAAGA,IAEzBnD,KAAKO,MAAMgI,EAAapF,EAAGnD,KAAKM,KAAKgI,EAAenF,IAGxD,GAAgB,IAAZsE,EAAe,CACfY,GAAO,EACP,OAOR,GAFArI,KAAKO,MAAM2H,IAAQlI,KAAKU,QAAQuH,IAAWzB,IAEzB,MAAZmB,EAAe,CACjBU,GAAO,EACP,MAMJ,GAAe,KAFfD,EAAST,EAAU3H,KAAK6H,WAAW7H,KAAKM,KAAK0H,IAAU,EAAM,EAAGL,EAASA,EAAU,IAEjE,CAOd,IAJAA,GAAWS,EACXG,GAHAL,GAAQE,GAGY,EACpBE,GAHAL,GAAWG,GAGc,EAEpBjF,EAAI,EAAGA,EAAIiF,EAAQjF,IAEpBnD,KAAKO,MAAMgI,EAAapF,EAAGnD,KAAKU,QAAQ4H,EAAenF,EAAGqD,IAG9D,GAAImB,GAAW,EAAG,CACdU,GAAO,EACP,OAOR,GAFArI,KAAKO,MAAM2H,IAAQlI,KAAKM,KAAK0H,MAEX,MAAZP,EAAe,CACjBY,GAAO,EACP,MAGJ/B,UAEK6B,GAvgCS,GAugC0BC,GAvgC1B,GAygClB,GAAIC,EACA,MAGA/B,EAAY,IACZA,EAAY,GAGhBA,GAAa,EASjB,GANAtG,KAAKsG,UAAYA,EAEbA,EAAY,IACZtG,KAAKsG,UAAY,GAGL,IAAZqB,EAAe,CAMf,IAHAY,GAFAL,GAAQT,GAEY,EACpBa,GAFAN,GAAWP,GAEc,EAEpBtE,EAAIsE,EAAU,EAAGtE,GAAK,EAAGA,IAE1BnD,KAAKO,MAAMgI,EAAapF,EAAGnD,KAAKM,KAAKgI,EAAenF,IAKxDnD,KAAKO,MAAM2H,EAAMlI,KAAKU,QAAQuH,EAASzB,QAEpC,IAAgB,IAAZmB,EACP,MAAM,IAAI/E,MAAM,8CAIhB,IADA0F,EAAeJ,GAAQP,EAAU,GAC5BxE,EAAI,EAAGA,EAAIwE,EAASxE,IAErBnD,KAAKO,MAAM+H,EAAenF,EAAGnD,KAAKU,QAAQyC,EAAGqD,SA1JrD,CAMI,IAHA+B,GAFAL,GAAQT,GAEY,EACpBa,GAFAN,GAAWP,GAEc,EAEpBtE,EAAIsE,EAAU,EAAGtE,GAAK,EAAGA,IAE1BnD,KAAKO,MAAMgI,EAAapF,EAAGnD,KAAKM,KAAKgI,EAAenF,IAIxDnD,KAAKO,MAAM2H,EAAMlI,KAAKU,QAAQuH,EAASzB,SApBvC,IAFA8B,EAAeJ,GAAQP,EAAU,GAE5BxE,EAAI,EAAGA,EAAIwE,EAASxE,IAErBnD,KAAKO,MAAM+H,EAAenF,EAAGnD,KAAKU,QAAQyC,EAAGqD,MA13B7D,qBA8hCI,SAAQvF,EAAKC,EAAMC,GAEf,IAAIqH,EAAYtH,EAAOD,EAGvB,KAAIuH,EAAY,GAAhB,CAIA,IAAI5B,EAAY,EAEhB,GAAI4B,EApkCc,GAukCd,OAFA5B,EAAY5G,KAAKyI,iBAAiBxH,EAAKC,QACvClB,KAAK0I,oBAAoBzH,EAAKC,EAAMD,EAAM2F,GAK9C,IAAInB,EAASzF,KAAK0F,aAAa8C,GAE/B,EAAG,CAEC,IADA5B,EAAY5G,KAAKyI,iBAAiBxH,EAAKC,IACvBuE,EAAQ,CACpB,IAAIkD,EAAQH,EACRG,EAAQlD,IACRkD,EAAQlD,GAGZzF,KAAK0I,oBAAoBzH,EAAKA,EAAM0H,EAAO1H,EAAM2F,GACjDA,EAAY+B,EAGhB3I,KAAK4I,QAAQ3H,EAAK2F,GAClB5G,KAAK6I,YAGLL,GAAa5B,EACb3F,GAAO2F,QAEY,IAAd4B,GAGTxI,KAAK8I,sBAxkCb,GAA6BhJ,S,6HCxBhB8L,G,MAAb,WAYI,WAAY3E,EAAO4E,EAAMC,GAAQ,oBACzB9L,KAAKiH,MAAQA,EACbjH,KAAK6L,KAAOA,EACZ7L,KAAK8L,MAAQA,EAfzB,4CAkBI,WACI,OAAO9L,KAAKiH,QAnBpB,sBAqBI,SAASA,GACLjH,KAAKiH,MAAQA,IAtBrB,sBAyBI,WACI,OAAOjH,KAAK8L,QA1BpB,sBA4BI,SAASA,GACL9L,KAAK8L,MAAQA,IA7BrB,qBAgCI,WACI,OAAO9L,KAAK6L,OAjCpB,qBAmCI,SAAQA,GACJ7L,KAAK6L,KAAOA,MApCpB,MCHO,SAASE,EAAU5C,EAAGC,GACzB,OAAOzF,KAAKC,MALT,SAAgBuF,EAAGC,GACtB,OAAOzF,KAAKqI,UAAY5C,EAAID,GAAKA,EAIf6C,CAAO7C,EAAGC,IA6BzB,SAAS6C,EAAcC,GAC1B,IAD8B,EAC1BC,EAAM,GADoB,cAEjBD,GAFiB,IAE9B,IAAI,EAAJ,qBAAiB,CAAC,IAAV/I,EAAS,QACT8D,EAAQ9D,EAAEiJ,WACVP,EAAO1I,EAAEkJ,UACTP,EAAQ3I,EAAEmJ,WACdH,EAAII,KAAK,IAAIX,EAAQ3E,EAAO4E,EAAMC,KANR,8BAQ9B,OAAOK,EAGJ,SAASK,EAAarD,EAAGC,GAC5B,OAAOD,EAAErF,SAAWsF,EAAEtF,QACtBqF,EAAEsD,OAAM,SAACC,EAAGvJ,GAAJ,OAAUuJ,IAAMtD,EAAEjG,M,oCC7CvB,SAASwJ,EAAYC,GAQxB,IAPA,IAAIlD,EAAQkD,EAAMlD,MACdmD,EAAYD,EAAMC,UAClBC,EAASF,EAAME,OAGfZ,EAAM,GAED/I,EAAI,EAAGA,EAAIuG,EAAM5F,SAAUX,EAAG,CACnC,IAAI4J,EAAa,CACbD,OAAQpD,EAAMvG,GAAGiJ,WAAaS,EAAU/I,OAAS,IAAM,IACvDkJ,gBAAiB,OAAStD,EAAMvG,GAAGmJ,WAAa,KAEpDJ,EAAIK,KAAK,qBAAaU,MAAOF,EAAYG,UAAWC,IAAOC,KAAxCjK,IAEvB,IAAI,IAAIA,EAAIuG,EAAM5F,OAAOX,EAAI0J,EAAU/I,SAASX,EAAE,CAK9C+I,EAAIK,KAAK,qBAAaU,MAJL,CACbH,OAAQ,KACRE,gBAAiB,oBAEoBE,UAAWC,IAAOC,KAAxCjK,IAEvB,OAAkB,IAAfuG,EAAM5F,OACE,wBAGP,qBAAKmJ,MAAO,CAACI,MAAO,OAAQP,OAAQA,EAAO,KAA3C,SACI,qBAAKI,UAAWC,IAAOG,eAAvB,SACKpB,M,qBC5BV,SAASqB,EAAMX,GAClB,OACI,sBAAKM,UAAWC,IAAOK,eAAvB,UACI,8BAAK,uCAAUZ,EAAM9L,cACrB,2CAAc8L,EAAMhM,aAEpB,2CAAcgM,EAAMa,a,oBCTrBC,EAAgB,CACvBC,OAAQ,SAAgBpI,EAAGzB,GACvB,OAAOyB,GAEXqI,QAAS,SAAiBrI,EAAGzB,GACzB,OAAOA,EAASyB,GAEpBsI,UAAW,SAAmBtI,EAAGzB,GAC7B,OAAIyB,EAAIzB,EAAS,EACN,EAAIyB,EAEJ,GAAKzB,EAASyB,GAAK,GAGlCuI,kBAAmB,SAA2BvI,EAAGzB,GAC7C,OAAIyB,EAAIzB,EAAS,EACLA,EAAS,EAAEyB,EAAK,EAEf,EAAFA,EAAIzB,IChBZiK,EAAW,CAClBC,YAAa,SAAU9K,GAEnB,IADA,IAAI+K,EAAe,GACV9K,EAAI,EAAGA,EAAID,IAAOC,EAAG,CAC1B,IAAI+K,EAAcnC,EAAU5I,EAAGD,GAC/B+K,EAAa1B,KACT,CACI4B,IAAK,OACLhF,EAAGhG,EACHiG,EAAE8E,IAId,OAAOD,GAGXG,aAAc,SAAUlL,GAGpB,IAFA,IAAI+K,EAAe,GAEV9K,EAAI,EAAGA,EADD,GACKD,IAAgBC,EAAG,CACnC,IAAIkL,EAAetC,EAAU5I,EAAGD,GAC5BoL,EAAevC,EAAU5I,EAAGD,GAChC+K,EAAa1B,KACT,CACI4B,IAAK,OACLhF,EAAGkF,EACHjF,EAAEkF,IAId,OAAOL,ICzBFM,EAAb,kDAKI,WAAY3B,GAAQ,IAAD,8BACf,cAAMA,IACD4B,gBAAkB,IACvB,EAAKC,eAAgB,EACrB,EAAK1O,gBAAkB6M,EAAM7M,gBAC7B,EAAK2O,MAAQ9B,EAAM8B,MACnB,EAAK3O,gBAAgB4O,gBAAgB,EAAKH,iBAC1C,EAAKzO,gBAAgB6O,UAAUlB,EAAcC,QAP9B,EALvB,mDAeI,WACI,IAAIkB,EAASC,SAASC,eAAe5B,IAAO0B,QAE5C,GAAe,OAAXA,EAAiB,CACjB,IAAI3L,EAAM2L,EAAO5H,MACjBjH,KAAKD,gBAAgB4O,gBAAgBzL,MApBjD,+BAwBI,WAEI,IAAI8L,EAAoBF,SAASC,eAAe5B,IAAO6B,mBACnDC,EAAWH,SAASC,eAAe5B,IAAO8B,UAC1CC,EAAMJ,SAASC,eAAe5B,IAAOgC,eACrCnP,KAAKyO,eACLQ,EAAShC,MAAMmC,QAAU,OACzBJ,EAAkB/B,MAAMI,MAAQ,IAChC6B,EAAIG,UAAY,aAEhBJ,EAAShC,MAAMmC,QAAU,QACzBJ,EAAkB/B,MAAMI,MAAQ,QAChC6B,EAAIG,UAAY,WAEpBrP,KAAKyO,eAAiBzO,KAAKyO,gBAtCnC,uBAyCI,SAAUa,GACNtP,KAAKD,gBAAgB6O,UAAUU,EAAMtP,KAAKD,gBAAgBa,WAAW,KA1C7E,0BA6CI,SAAa0O,GACTtP,KAAKD,gBAAgBwP,aAAaD,KA9C1C,uBAiDI,SAAUxO,GACNd,KAAK0O,MAAMxM,QAAQpB,EAAU,EAAGd,KAAKD,gBAAgBc,eAAe,EAAG,MAlD/E,sBAqDI,WACIb,KAAKD,gBAAgByP,aAtD7B,uBAyDI,WACIxP,KAAKwP,WACLxP,KAAK4O,UAAUlB,EAAcC,UA3DrC,8BA8DI,WAEI,IAAInH,EAAM,GACV,IAAK,IAAIrD,KAAKuK,EACVlH,EAAI+F,KACA,wBAAgBkD,QAASzP,KAAK4O,UAAUxO,KAAKJ,KAAM0N,EAAcvK,IAAjE,SAAuEA,GAA1DA,IAGrB,OAAOqD,IAtEf,sBAyEI,WACI,IADM,EACFA,EAAM,GACNkJ,EAAa1P,KAAK0O,MAAMiB,gBAFtB,cAGQD,GAHR,IAGN,2BAA0B,CAAC,IAAlBvM,EAAiB,QAClBqD,EAAI+F,KACA,wBAAgBkD,QAASzP,KAAK4P,UAAUxP,KAAKJ,KAAMmD,GAAnD,SAAwDA,GAA3CA,KALnB,8BAON,OAAOqD,IAhFf,yBAmFI,WACI,IAAIA,EAAM,GACV,IAAI,IAAIrD,KAAK4K,EACTvH,EAAI+F,KACA,wBAAgBkD,QAASzP,KAAKuP,aAAanP,KAAKJ,KAAM+N,EAAS5K,IAA/D,SAAqEA,GAAxDA,IAGrB,OAAOqD,IA1Ff,iCA6FI,WACI,IAAIqJ,EAAUf,SAASC,eAAe,gBACtC/O,KAAKD,gBAAgB+P,iBAAiBD,EAAQE,WA/FtD,oBAkGI,WACI,OACI,qBAAKxN,GAAI4K,IAAO6B,kBAAhB,SAEI,qBAAKzM,GAAI4K,IAAO8B,SAAhB,SACI,gCACI,qBAAK/B,UAAWC,IAAO6C,WAAvB,wBACA,uBAAOzN,GAAI4K,IAAO0B,OAAQhD,KAAK,QAAQjG,IAAI,KAAKqK,IAAI,MAAMC,aAAclQ,KAAKwO,gBACtE2B,KAAK,KACLC,SAAUpQ,KAAK2O,gBAAgBvO,KAAKJ,QAC3C,sBAAKkN,UAAWC,IAAO6C,WAAvB,UACI,0CACA,gCACI,uBAAOI,SAAUpQ,KAAKqQ,oBAAoBjQ,KAAKJ,MAAO6L,KAAK,WAAWtJ,GAAG,eAAe+N,KAAK,eAAeC,gBAAgB,IACxH,uBAAOC,QAAQ,eAAf,mCAGZ,sBAAKtD,UAAWC,IAAO6C,WAAvB,UACI,6CACA,8BAAMhQ,KAAKyQ,wBAGf,sBAAKvD,UAAWC,IAAO6C,WAAvB,UACI,gDACA,8BAEI,8BAAMhQ,KAAK0Q,qBAGnB,sBAAKxD,UAAWC,IAAO6C,WAAvB,UACI,+CACA,gCACI,wBAAQP,QAASzP,KAAK2Q,UAAUvQ,KAAKJ,MAArC,qCACA,wBAAQyP,QAASzP,KAAKwP,SAASpP,KAAKJ,MAApC,8CAGR,sBAAKkN,UAAWC,IAAO6C,WAAvB,UACI,6CACA,8BACKhQ,KAAK4Q,2BAzItC,GAA8BC,IAAMC,WCE9BC,EACU,CAAC,IAAK,IAAK,KADrBA,EAES,CAAC,IAAK,EAAG,GAMXC,GALMjF,EAAU,EAAG,KAAMA,EAAU,EAAG,KAAMA,EAAU,EAAG,KAKtE,kDAYI,WAAYa,GAAQ,IAAD,8BACf,cAAMA,IAED3M,MAAQ,CACTyJ,MAAO,EAAKkF,UAAUlB,EAAcC,OAAQ,EAAK/M,WACjDE,SAAU,GACVmQ,YAAa,EACbxD,OAAQ,EACRyD,UAAW,IAEf,EAAKC,OAAS,CACVC,KAAM,EACNC,MAAO,EACPC,KAAM,EACNC,OAAQ,EACRC,eAAgB,EAChBC,eAAgB,GAEpB,EAAKC,cAAgB,IACrB,EAAKzD,aAAe,GACpB,EAAK0D,aAAe,GACpB,EAAKC,YAAc3F,EAAc,EAAKhM,MAAMyJ,OAC5C,EAAKmI,gBAAkB,GACvB,EAAKnD,MAAQ,IAAIpN,QAAJ,gBACb,EAAKV,UAAY,EAAKX,MAAM6D,OAC5B,EAAKgO,SAAW,EAAKJ,cAAc,EAAK9Q,UACxC,EAAKmR,eAAgB,EACrB,EAAKC,IAAM,IAAKnQ,OAAOoQ,cAAgBpQ,OAAOqQ,oBA3B/B,EAZvB,6CA2CI,SAAUjL,GACN,IAAIkL,EAAMnS,KAAKgS,IAAII,mBACnBD,EAAItG,KAAO,OAEX,IAAIrG,EAAIyB,EAAQjH,KAAKY,UACrBuR,EAAIE,UAAUpL,MAAQ,IAAOzB,EAAI,IAGjC,IAEI8M,EAAWtS,KAAKgS,IAAIO,aACxBD,EAASE,KAAKvL,MAAQ,EACtBkL,EAAIM,QAAQH,GACZA,EAASG,QAAQzS,KAAKgS,IAAIU,aAE1BJ,EAASE,KAAKG,wBAAwB,IAAM3S,KAAKgS,IAAIY,aAAe5S,KAAK8R,SAP3D,IAOiF,IAAO,GACtGQ,EAASE,KAAKG,wBAAwB,EAAG3S,KAAKgS,IAAIY,aAAe5S,KAAK8R,SARxD,IAQ8E,KAE5FK,EAAInL,QACJmL,EAAIU,KAAK7S,KAAKgS,IAAIY,aAAe5S,KAAK8R,SAXxB,IAW8C,OA9DpE,wBAiEI,WACI9R,KAAKmR,OAAS,CACVC,KAAM,EACNC,MAAO,EACPC,KAAM,EACNC,OAAQ,EACRC,eAAgB,EAChBC,eAAgB,GAPX,oBASIzR,KAAK2R,cATT,IAST,IAAI,EAAJ,qBAA+B,CAAC,IAAxBxO,EAAuB,QAC3B2P,aAAa3P,IAVR,8BAYTnD,KAAK2R,aAAe,KA7E5B,qBAgFI,WACI3R,KAAK+S,aACL/S,KAAKgT,SACD,CACI/B,YAAa,EACbxD,OAAQ,IAIhBzN,KAAKC,MAAMwN,OAAS,EAEpBzN,KAAKC,MAAMgR,YAAc,IA3FjC,kBA8FI,SAAKgC,EAAOC,GAAuB,IAAjBC,IAAgB,yDAC1BtH,EAAO,UACPC,EAAQiF,EACRqC,EAASpT,KAAKC,MAAMyJ,MAkBxB,GAhBkB,eAAdwJ,EAAKrH,MACLA,EAAO,aACPC,EAAQoH,EAAKpH,OAIPoH,EAAKrH,MAAsB,YAAdqH,EAAKrH,MAIxBA,EAAOqH,EAAKrH,KACZC,EAAQoH,EAAKpH,QAJbD,EAAO,UACPC,EAAQiF,GAMZqC,EAAOH,GAAOI,QAAQxH,GACtBuH,EAAOH,GAAOK,SAASxH,IACnBqH,EAKA,OAAOC,EAJPpT,KAAKgT,SAAS,CACVtJ,MAAO0J,MArHvB,sBA6HI,SAASG,EAASL,EAAMC,GACpB,IAD6B,EACzBC,EAASpT,KAAKC,MAAMyJ,MADK,cAEf6J,GAFe,IAE7B,2BAAuB,CAAC,IAAfpQ,EAAc,QACfgQ,EACAnT,KAAKwT,KAAKrQ,EAAG+P,EAAMC,GAEnBC,EAASpT,KAAKwT,KAAKrQ,EAAG+P,EAAMC,IANP,8BAS7B,IAAKA,EACD,OAAOC,IAvInB,oBA2II,SAAOH,GAAwB,IAAjBE,IAAgB,yDACtBC,EAASpT,KAAKC,MAAMyJ,MAGxB,GAFA0J,EAAOH,GAAOK,SAASvC,GACvBqC,EAAOH,GAAOI,QAAQ,aAClBF,EAKA,OAAOC,EAJPpT,KAAKgT,SAAS,CACVtJ,MAAO0J,MAjJvB,wBAwJI,SAAWG,EAASJ,EAASM,GACzB,IADmC,EAC/BL,EAASpT,KAAKC,MAAMyJ,MADW,cAErB6J,GAFqB,IAEnC,2BAAuB,CAAC,IAAfpQ,EAAc,QACfgQ,EACAnT,KAAK0T,OAAOvQ,EAAGgQ,GAEfC,EAASpT,KAAK0T,OAAOvQ,EAAGgQ,IANG,8BAcnC,GALIM,GACAzT,KAAKgT,SAAS,CACVtJ,MAAO0J,KAGVD,EACD,OAAOC,IAvKnB,4BA4KI,SAAeO,EAAaC,GACxB5T,KAAK6T,SAASF,EAAaC,GAAU,GACrC5T,KAAK2R,aAAapF,KAAKuH,WAAW9T,KAAK+T,WAAW3T,KAAKJ,MAAOA,KAAKmR,OAAOI,QAAUvR,KAAK8R,SAAW,IAAK6B,GAAa,GAAO,MA9KrI,2BAiLI,SAAcxK,EAAGC,GAAoE,IAAjE8C,EAAgE,uDAA1DlM,KAAK4R,YAAa4B,EAAwC,uCAAlCQ,EAAkC,uDAA1BhU,KAAK8R,SAAUmC,EAAW,uCAChFjU,KAAK2R,aAAapF,KAAKuH,WAAW9T,KAAKkU,UAAU9T,KAAKJ,MAAOA,KAAKmR,OAAOC,MAAQ4C,EAAO7K,EAAGC,EAAG8C,EAAKsH,EAAMS,MAlLjH,uBAsLI,SAAU9K,EAAGC,GAA4D,IAAzD8C,EAAwD,uDAAlDlM,KAAK4R,YAAa4B,IAAgC,yDAAnBS,EAAmB,wDACjEA,GACCjU,KAAKiU,UAAU/H,EAAI9C,GAAGgD,YAE1B,IAAIgH,EAASlH,EAET1F,EAAM4M,EAAOjK,GACjBiK,EAAOjK,GAAKiK,EAAOhK,GACnBgK,EAAOhK,GAAK5C,EACRgN,GACAxT,KAAKmU,eAAe,CAAChL,EAAGC,GAAI,CAACyC,KAAM,YAEvC,IAAIuI,EAAYpU,KAAKC,MAAMwN,OAC3BzN,KAAKgT,SAAS,CACVvF,OAAQ2G,EAAY,MApMhC,kBAwMI,SAAKjL,EAAGC,GAA4B,IAAzB8C,EAAwB,uDAAlBlM,KAAK4R,YAClB5R,KAAKkU,UAAU/K,EAAGC,EAAG8C,GAAK,GAAO,GAEjClM,KAAKiO,aAAa1B,KAClB,CACI4B,IAAK,OACLjC,IAAKA,EACL/C,EAAGA,EACHC,EAAGA,MAhNf,wBAsNI,SAAW6J,EAAOhM,GAAgE,IAAzDiF,EAAwD,uDAAlDlM,KAAK4R,YAAa4B,IAAgC,yDAAnBS,EAAmB,wDAK1EA,GACCjU,KAAKiU,UAAUhN,GAEnBiF,EAAI+G,GAAOoB,SAASpN,GAChBuM,GACAxT,KAAKmU,eAAe,CAAClB,GAAQ,CAACpH,KAAM,YAExC,IAAIuI,EAAYpU,KAAKC,MAAMwN,OAC3BzN,KAAKgT,SAAS,CACVvF,OAAQ2G,EAAY,MApOhC,4BAwOI,SAAenB,EAAOhM,GAA+E,IAAxEiF,EAAuE,uDAAjElM,KAAK4R,YAAa4B,EAA+C,uCAAzCQ,EAAyC,uDAAjChU,KAAK8R,SAAUmC,IAAkB,yDAChGjU,KAAK2R,aAAapF,KAAKuH,WAAW9T,KAAKsU,WAAWlU,KAAKJ,MAAOA,KAAKmR,OAAOE,OAAS2C,EAAOf,EAAOhM,EAAOiF,EAAKsH,EAAMS,MAzO3H,mBA4OI,SAAMhB,EAAOhM,GAAgC,IAAzBiF,EAAwB,uDAAlBlM,KAAK4R,YAC3B5R,KAAKsU,WAAWrB,EAAOhM,EAAOiF,GAAK,GAAO,GAC1ClM,KAAKiO,aAAa1B,KACd,CACI4B,IAAK,QACLjC,IAAKA,EACL+G,MAAOA,EACPhM,MAAOA,MAnPvB,kBAyPI,SAAKgM,GAAgC,IAAzB/G,EAAwB,uDAAlBlM,KAAK4R,YASnB,OAPA5R,KAAKiO,aAAa1B,KACd,CACC4B,IAAK,OACLjC,IAAKA,EACL+G,MAAOA,IAGL/G,EAAI+G,GAAO7G,aAlQ1B,qBAqQI,SAAQjD,EAAGC,GAAwC,IAArCmL,EAAoC,uDAA7B,IAAKrI,EAAwB,uDAAlBlM,KAAK4R,YAEjC,MAAa,MAAT2C,EACOrI,EAAI/C,GAAGiD,WAAaF,EAAI9C,GAAGgD,WAClB,OAATmI,EACArI,EAAI/C,GAAGiD,YAAcF,EAAI9C,GAAGgD,WACnB,MAATmI,EACArI,EAAI/C,GAAGiD,WAAaF,EAAI9C,GAAGgD,WAClB,OAATmI,EACArI,EAAI/C,GAAGiD,YAAcF,EAAI9C,GAAGgD,WAE5BF,EAAI/C,GAAGiD,aAAeF,EAAI9C,GAAGgD,aAhRhD,yBAoRI,SAAYjD,EAAGC,GAAkB,IAAfoK,EAAc,wDACxBgB,EAAiBxU,KAAKC,MAAMgR,YAChCjR,KAAKgT,SAAS,CACV/B,YAAauD,EAAiB,IAElCjJ,QAAQC,IAAI,gBAAkBxL,KAAKC,MAAMgR,YAAc,IAAM9H,EAAI,IAAMC,GACnEoK,GACAxT,KAAKmU,eAAe,CAAChL,EAAGC,GAAI,CAACyC,KAAM,aAAcC,MAAO,CAAC,EAAG,EAAG,SA3R3E,kCA+RI,SAAqB3C,EAAGC,MA/R5B,4BAmSI,SAAelG,GAAsB,IAAjBuR,IAAgB,yDAChC,GAAGA,EAAU,CACT,IAAIC,EAAc1U,KAAK6R,gBAAgB/N,OAQvC,OAPA9D,KAAK6R,gBAAgBtF,KAAKvM,KAAK4O,WAAU,kBAAM,IAAG1L,GAAK,IACvDlD,KAAKiO,aAAa1B,KACd,CACI4B,IAAK,iBACLjL,IAAKA,IAGNwR,EAEP,IAAItB,EAASpT,KAAKC,MAAMiR,UACxBkC,EAAO7G,KAAKvM,KAAK4O,WAAU,kBAAM,IAAG1L,GAAK,IACzClD,KAAKgT,SAAS,CACV9B,UAAWkC,MAlT3B,qCAwTI,SAAwBlQ,EAAK8Q,GAAyB,IAAlBS,EAAiB,wDACjDzU,KAAK2R,aAAapF,KAAKuH,WAAW9T,KAAKQ,eAAeJ,KAAKJ,MAAOA,KAAKmR,OAAOE,OAAS2C,EAAO9Q,EAAKuR,MAzT3G,4BA4TI,SAAexB,GAAwB,IAAjBwB,IAAgB,yDAClC,GAAGA,EACCzU,KAAK6R,gBAAgB8C,OAAO1B,EAAO,GACnCjT,KAAKiO,aAAa1B,KACd,CACI4B,IAAK,iBACL8E,MAAOA,QAGd,CACD,IAAIzM,EAAMxG,KAAKC,MAAMiR,UACrB1K,EAAImO,OAAO1B,EAAO,GAClBjT,KAAKgT,SAAS,CACV9B,UAAW1K,OAzU3B,qCA+UI,SAAwByM,EAAOe,GAAyB,IAAlBS,EAAiB,wDACnDzU,KAAK2R,aAAapF,KAAKuH,WAAW9T,KAAKS,eAAeL,KAAKJ,MAAOA,KAAKmR,OAAOE,OAAS2C,EAAOf,EAAOwB,MAhV7G,qBAmVI,SAAQxB,EAAO2B,GAA2B,IAAjBH,IAAgB,yDACrC,OAAGA,EACQzU,KAAK6R,gBAAgB+C,GAAU3B,GAAO7G,WAEtCpM,KAAKC,MAAMiR,UAAU0D,GAAU3B,GAAO7G,aAvVzD,sBA2VI,SAAS6G,EAAOhM,EAAO2N,GAA8C,IAApCH,IAAmC,yDAAlBR,EAAkB,wDAIhE,GAHGA,GACCjU,KAAKiU,UAAUhN,GAEhBwN,EACCzU,KAAK6R,gBAAgB+C,GAAU3B,GAAOoB,SAASpN,GAC/CjH,KAAKiO,aAAa1B,KACd,CACI4B,IAAK,WACL8E,MAAOA,EACPhM,MAAOA,EACP2N,SAAUA,QAGjB,CACD5U,KAAKC,MAAMiR,UAAU0D,GAAU3B,GAAOoB,SAASpN,GAC/C,IAAIT,EAAMxG,KAAKC,MAAMiR,UACrBlR,KAAKgT,SAAS,CACV9B,UAAW1K,OA7W3B,+BAkXI,SAAkByM,EAAOhM,EAAO2N,EAAUZ,GAA6C,IAAtCS,EAAqC,wDAAnBR,IAAmB,yDAClFjU,KAAK2R,aAAapF,KAAKuH,WAAW9T,KAAKW,SAASP,KAAKJ,MAAOA,KAAKmR,OAAOE,OAAS2C,EAAOf,EAAOhM,EAAO2N,EAAUH,EAAUR,MAnXlI,4BAsXI,SAAe/H,GAEX,GAAGM,EAAaN,EAAKlM,KAAKC,MAAMyJ,OAC5B,MAAO,CAAC4G,KAAK,aAEjB,GAAG9D,EAAaN,EAAKlM,KAAK4R,aACtB,MAAO,CAACtB,KAAK,eAEjB,IAAI,IAAInN,EAAI,EAAGA,EAAInD,KAAK6R,gBAAgB/N,SAASX,EAC7C,GAAIqJ,EAAaN,EAAKlM,KAAK6R,gBAAgB1O,IACvC,MAAO,CAACmN,KAAK,iBAAkB2C,MAAM9P,GAG7C,IAAI,IAAIA,EAAI,EAAGA,EAAInD,KAAKC,MAAMiR,UAAUpN,SAASX,EAC7C,GAAIqJ,EAAaN,EAAKlM,KAAKC,MAAMiR,UAAU/N,IACvC,MAAO,CAACmN,KAAK,WAAY2C,MAAM9P,GAGvC,MAAO,aAxYf,4BA2YI,SAAe+P,GACX,IAAI5C,EAAO4C,EAAK5C,KACZ2C,EAAQC,EAAKD,MACjB,MAAW,cAAP3C,EACOtQ,KAAKC,MAAMyJ,MAEZ,gBAAP4G,EACQtQ,KAAK4R,YAEN,aAAPtB,GACC/E,QAAQC,IAAI0H,GACLlT,KAAKC,MAAMiR,UAAU+B,IAEtB,mBAAP3C,GACC/E,QAAQC,IAAI0H,GACLlT,KAAK6R,gBAAgBoB,IAEzB,KA5Zf,8BA+ZI,SAAiBC,GACb,IAAI5C,EAAO4C,EAAK5C,KACZ2C,EAAQC,EAAKD,MACjB,MAAU,gBAAP3C,EACQ,CAACA,KAAK,aACD,mBAAPA,EACE,CAACA,KAAM,WAAY2C,MAAOA,GAE9BC,IAvaf,gCA2aI,WACI,OAAOlT,OA5af,4BA+aI,WACI,OAAOA,KAAK4R,cAhbpB,sBAmbI,WACI,OAAO5R,KAAKC,QApbpB,0BAubI,WACI,OAAOD,KAAKY,YAxbpB,8BA2bI,SAAiBiU,GACb7U,KAAK+R,cAAgB8C,IA5b7B,sBA+bI,WACI7U,KAAK+S,aACL/S,KAAK+T,WAAWpN,MAAMmO,KAAKnO,MAAM3G,KAAKY,WAAWkC,SAAS,GAAO,GACjE9C,KAAKgT,SAAS,CACN9B,UAAW,OAnc3B,uBAwcI,SAAU5B,EAAMxL,GAEZ,IAFuC,IAAnBiR,EAAkB,wDAClC7I,EAAM,GACD/I,EAAI,EAAGA,EAAIW,IAAUX,EAAG,CAC7B,IAAI0M,EAAU,IAAIjE,EAAQ0D,EAAKnM,EAAGW,GAAS,EAAG,CAAC,IAAK,IAAK,MACzDoI,EAAIK,KAAKsD,GAEb,IAAGkF,EAKC,OAAO7I,EAJPlM,KAAKgT,SAAS,CACVtJ,MAAOwC,MAhdvB,0BAudI,SAAaoD,GACTtP,KAAKgV,UACLhV,KAAKgT,SAAS,CACVlS,SAAU,YAGd,IANe,EAMXmN,EAAeqB,EAAKtP,KAAKY,WANd,cAOFqN,GAPE,IAOf,IAAI,EAAJ,qBAA0B,CAAC,IAAnB9K,EAAkB,QACT,SAAVA,EAAEgL,KACD2F,WAAW9T,KAAKkU,UAAU9T,KAAKJ,MAAOA,KAAKmR,OAAOC,MAAQpR,KAAK8R,SAAW,EAAG3O,EAAEgG,EAAGhG,EAAEiG,EAAGpJ,KAAKC,MAAMyJ,OAAO,GAAM,IATxG,iCAvdvB,+BAseI,WACI1J,KAAKuP,iBAveb,yBA0eI,SAAYzO,GACRd,KAAKgT,SAAS,CACVlS,SAAUA,MA5etB,6BAgfI,WACId,KAAK4R,YAAc3F,EAAcjM,KAAKC,MAAMyJ,SAjfpD,4BAqfI,WACI1J,KAAKgV,UAmBLzJ,QAAQC,IAAI,iBACZD,QAAQC,IAAIxL,KAAK4R,aAEjBrG,QAAQC,IAAI,0BAvBC,oBAwBAxL,KAAKiO,cAxBL,IAwBb,IAAI,EAAJ,qBAA+B,CAAC,IAAxB9K,EAAuB,QACvBgL,EAAMhL,EAAEgL,IACZ,GAAG,CAAC,OAAQ,OAAQ,SAAS8G,SAAS9G,GAAM,CACxC,IAAI+G,EAAUlV,KAAKmV,eAAehS,EAAE+I,KAChCkJ,EAAapV,KAAKqV,iBAAiBH,GACnChJ,EAAMlM,KAAKsV,eAAeF,GAElB,SAARjH,EACAnO,KAAKuV,cAAcpS,EAAEgG,EAAGhG,EAAEiG,EAAG8C,GAAK,EAAMlM,KAAK8R,UAAU,GACxC,UAAR3D,GAKPnO,KAAKwV,eAAerS,EAAE8P,MAAO9P,EAAE8D,MAAOiF,GAAK,EAAMlM,KAAK8R,UAAU,GAG/D,aAAN3D,GACCnO,KAAKyV,kBAAkBtS,EAAE8P,MAAO9P,EAAE8D,MAAO9D,EAAEyR,SAAU5U,KAAK8R,UAAU,GAAO,GAEtE,mBAAN3D,GACCnO,KAAK0V,wBAAwBvS,EAAED,IAAKlD,KAAK8R,UAAU,GAE9C,mBAAN3D,GACCnO,KAAK2V,wBAAwBxS,EAAE8P,MAAOjT,KAAK8R,UAAU,IAhDhD,8BAmDb9R,KAAK6R,gBAAkB,GACvB7R,KAAKiO,aAAe,KAziB5B,4BA6iBI,SAAe4G,GACX7U,KAAK8R,SAAW+C,EAAI7U,KAAKY,YA9iBjC,6BAijBI,SAAgBsC,GACZlD,KAAKY,UAAYsC,EACjBlD,KAAKgT,SAAS,CACVtJ,MAAO1J,KAAK4O,UAAUlB,EAAcC,OAAQ3N,KAAKY,aAErDZ,KAAK4R,YAAc3F,EAAcjM,KAAKC,MAAMyJ,OAE5C1J,KAAK0O,MAAM9N,UAAYZ,KAAKa,eAC5Bb,KAAK4V,eAAe5V,KAAK0R,iBAzjBjC,6BA4jBI,WACI,IAAIlL,EAAM,GACV,GAAGxG,KAAK+R,cACJ,IAAK,IAAI5O,EAAInD,KAAKC,MAAMiR,UAAUpN,OAAS,EAAGX,GAAK,EAAGA,IAClDqD,EAAI+F,KACA,cAACI,EAAD,CAAmDjD,MAAO1J,KAAKC,MAAMiR,UAAU/N,GAClE0J,UAAW7M,KAAKC,MAAMyJ,MAAOoD,OAAQ,KAAO,EAAI9M,KAAKC,MAAMiR,UAAUpN,SADhE9D,KAAKC,MAAMiR,UAAUpN,OAASX,IAK5D,OAAOqD,IAtkBf,oBAykBI,WACI,OACI,gCACI,cAAC+G,EAAD,CAAOzM,SAAUd,KAAKC,MAAMa,SAAUmQ,YAAajR,KAAKC,MAAMgR,YAAaxD,OAAQzN,KAAKC,MAAMwN,OAAQ7M,UAAWZ,KAAKY,YACtH,sBAAKqM,MAAO,CAACH,OAAQ,SAArB,UAEK9M,KAAK6V,kBACN,cAAClJ,EAAD,CAAajD,MAAO1J,KAAKC,MAAMyJ,MAAOmD,UAAW7M,KAAKC,MAAMyJ,MAAOoD,OAAQ9M,KAAK+R,cAAgB,KAAK,EAAE/R,KAAKC,MAAMiR,UAAUpN,QAAU,SAE1I,8BACI,cAAC,EAAD,CAAU/D,gBAAiBC,KAAM0O,MAAO1O,KAAK0O,iBAnlBjE,GAAqCmC,IAAMC,YCL5BgF,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCIdQ,IAASC,OACL,cAAC,EAAD,IACF1H,SAASC,eAAe,SAQ1B+G,M","file":"static/js/main.726a7e81.chunk.js","sourcesContent":["export class Sort {\r\n    arrayVisualizer;\r\n\r\n    compare;\r\n    swap;\r\n    write;\r\n    read;\r\n\r\n    createAuxArray\r\n    removeAuxArray\r\n\r\n    auxRead\r\n    auxWrite\r\n\r\n    arrLength;\r\n\r\n    sortName;\r\n    warnLen;\r\n    isDisabled;\r\n\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.state = this.arrayVisualizer.getState()\r\n        this.compare = this.arrayVisualizer.compare.bind(arrayVisualizer)\r\n        this.swap = this.arrayVisualizer.swap.bind(arrayVisualizer)\r\n        this.read = this.arrayVisualizer.read.bind(arrayVisualizer)\r\n        this.write = this.arrayVisualizer.write.bind(arrayVisualizer)\r\n        this.createAuxArray = this.arrayVisualizer.createAuxArray.bind(arrayVisualizer)\r\n        this.removeAuxArray = this.arrayVisualizer.removeAuxArray.bind(arrayVisualizer)\r\n        this.auxRead = this.arrayVisualizer.auxRead.bind(arrayVisualizer)\r\n        this.auxWrite = this.arrayVisualizer.auxWrite.bind(arrayVisualizer)\r\n        this.arrLength = this.arrayVisualizer.getArrLength();\r\n        this.sortName = \"\"\r\n        this.warnLen = -1;\r\n        this.isDisabled = false;\r\n    }\r\n\r\n    getSortName(){\r\n        return this.sortName\r\n    }\r\n\r\n    getWarnLen(){\r\n        return this.warnLen\r\n    }\r\n\r\n    runSort(low, high, bucketsNum){\r\n    }\r\n}","// extracted by mini-css-extract-plugin\nmodule.exports = {\"textCenter\":\"Controls_textCenter__3_8jn\",\"controls\":\"Controls_controls__3X5vt\",\"showToggleBtn\":\"Controls_showToggleBtn__2CbSs\",\"slider\":\"Controls_slider__3IxWj\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"arrayContainer\":\"ArrayWindow_arrayContainer__jfaB8\",\"bar\":\"ArrayWindow_bar__30QYB\"};","export class Sorts {\r\n    arrayVisualizer;\r\n    sortsPaths\r\n\r\n    constructor(arrayVisualizer) {\r\n        this.arrayVisualizer = arrayVisualizer\r\n        this.sortsPaths = [\"BubbleSort\", \"MergeSort\", \"LLQuickSort\", \"InsertionSort\", \"SelectionSort\", \"TimSort\", \"PseudoTimSort\", \"HeapSort\", \"SlowSort\", \"StoogeSort\"]\r\n    }\r\n\r\n    getSortsPaths() {\r\n        return this.sortsPaths;\r\n    }\r\n\r\n    getSortObject(sortPath) {\r\n        let Sort = require(\"./\" + sortPath + \".js\")[sortPath]\r\n        return new Sort(this.arrayVisualizer)\r\n    }\r\n\r\n    runSort(sortName, low, high, bucketsNum) {\r\n        let sort = this.getSortObject(sortName)\r\n        let warnLen = sort.getWarnLen()\r\n        if (warnLen !== -1 && this.arrayVisualizer.getArrLength() > warnLen && !window.confirm(\"WARNING!!!\\nThe array size(\" + this.arrayVisualizer.getArrLength() + \") \" +\r\n            \"more than recommended(\" + warnLen + \")\\nApplication may freeze\\nDo you want continue?\")) {\r\n            return\r\n        }\r\n        this.arrayVisualizer.initPseudoArray()\r\n        this.arrayVisualizer.setSortName(sort.getSortName())\r\n        sort.runSort(low, high, bucketsNum)\r\n        this.arrayVisualizer.sortClickEvent()\r\n    }\r\n}","// extracted by mini-css-extract-plugin\nmodule.exports = {\"statsContainer\":\"Stats_statsContainer__1qOnq\"};","var map = {\n\t\"./BubbleSort.js\": 24,\n\t\"./HeapSort.js\": 25,\n\t\"./InsertionSort.js\": 26,\n\t\"./LLQuickSort.js\": 27,\n\t\"./MergeSort.js\": 28,\n\t\"./PseudoTimSort.js\": 29,\n\t\"./SelectionSort.js\": 30,\n\t\"./SlowSort.js\": 31,\n\t\"./Sort.js\": 5,\n\t\"./Sorts.js\": 14,\n\t\"./StoogeSort.js\": 32,\n\t\"./TimSort.js\": 33,\n\t\"./TimSortOrig.js\": 34,\n\t\"./TimSortPartalWorking.js\": 36,\n\t\"./timsortnotworking.js\": 37\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 23;","import {Sort} from \"./Sort\";\r\n\r\nexport class BubbleSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"BubbleSort\"\r\n    }\r\n    BubbleSort() {\r\n        let len = this.arrLength;\r\n        for (let i = 0; i < len; i++) {\r\n            for (let j = 0; j < len - i - 1; j++) {\r\n                if (this.compare(j, j + 1, \">\")) {\r\n                    this.swap(j, j + 1)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.BubbleSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class HeapSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"HeapSort\"\r\n    }\r\n    \r\n    heapify(n, i) {\r\n        let largest = i;\r\n\r\n        let l = 2 * i + 1;\r\n        let r = 2 * i + 2;\r\n\r\n        if (l < n && this.compare(l, largest, \">\")) {\r\n            largest = l;\r\n        }\r\n        if (r < n && this.compare(r, largest, \">\")) {\r\n            largest = r;\r\n        }\r\n\r\n        if (largest !== i) {\r\n            this.swap(i, largest);\r\n            this.heapify(n, largest);\r\n        }\r\n    }\r\n\r\n    HeapSort() {\r\n        let n = this.arrLength;\r\n\r\n\r\n        for (let i = Math.trunc(n / 2) - 1; i >= 0; i--) {\r\n            this.heapify(n, i);\r\n        }\r\n\r\n        for (let i = n - 1; i >= 0; i--) {\r\n            this.swap(0, i);\r\n            this.heapify(i, 0)\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.HeapSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class InsertionSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"InsertionSort\"\r\n    }\r\n\r\n    InsertionSort() {\r\n        let length = this.arrLength;\r\n        for (let i = 1; i < length; i++) {\r\n            let key = this.read(i);\r\n            let j = i - 1;\r\n            while (j >= 0 && this.read(j) > key) {\r\n                this.write(j + 1, this.read(j))\r\n                j = j - 1;\r\n            }\r\n            this.write(j + 1, key)\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.InsertionSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class LLQuickSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"LLQuickSort\"\r\n    }\r\n    partition(lo, hi) {\r\n        let pivot = hi;\r\n        let i = lo;\r\n        for (let j = lo; j < hi; j++) {\r\n            if (this.compare(j, pivot, \"<\")) {\r\n                this.swap(i, j);\r\n                i++;\r\n            }\r\n        }\r\n        this.swap(i, hi);\r\n        return i;\r\n    }\r\n\r\n    LLQuickSort(lo, hi) {\r\n        if (lo < hi) {\r\n            let p = this.partition(lo, hi);\r\n            this.LLQuickSort(lo, p - 1);\r\n            this.LLQuickSort(p + 1, hi);\r\n        }\r\n    }\r\n    runSort(low, high) {\r\n        this.LLQuickSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class MergeSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"MergeSort\"\r\n    }\r\n    merge(low, mid, high) {\r\n        // let leftArray = new Array(mid - low + 1);\r\n        // let rightArray = new Array(high - mid);\r\n\r\n        let leftArrayLen = mid - low + 1\r\n        let rightArrayLen = high - mid\r\n\r\n        let leftArrayIndex = this.createAuxArray(leftArrayLen);\r\n        let rightArrayIndex = this.createAuxArray(rightArrayLen);\r\n\r\n        for (let i = 0; i < leftArrayLen; i++) {\r\n            // leftArray[i] = this.read(low + i)\r\n            this.auxWrite(i, this.read(low + i), leftArrayIndex)\r\n        }\r\n        for (let i = 0; i < rightArrayLen; i++) {\r\n            // rightArray[i] = this.read(mid + i + 1);\r\n            this.auxWrite(i, this.read(mid + i + 1), rightArrayIndex)\r\n        }\r\n\r\n        let leftIndex = 0;\r\n        let rightIndex = 0;\r\n\r\n        for (let i = low; i < high + 1; i++) {\r\n            if (leftIndex < leftArrayLen && rightIndex < rightArrayLen) {\r\n                // if (leftArray[leftIndex] < rightArray[rightIndex]) {\r\n                if (this.auxRead(leftIndex, leftArrayIndex) < this.auxRead(rightIndex, rightArrayIndex)) {\r\n                    this.write(i, this.auxRead(leftIndex, leftArrayIndex))\r\n                    leftIndex++;\r\n                } else {\r\n                    this.write(i, this.auxRead(rightIndex, rightArrayIndex))\r\n                    rightIndex++;\r\n                }\r\n            } else if (leftIndex < leftArrayLen) {\r\n                this.write(i, this.auxRead(leftIndex, leftArrayIndex))\r\n                leftIndex++;\r\n            } else if (rightIndex < rightArrayLen) {\r\n                this.write(i, this.auxRead(rightIndex, rightArrayIndex))\r\n                rightIndex++;\r\n            }\r\n        }\r\n        // console.log(leftArray)\r\n        // console.log(rightArray)\r\n        this.removeAuxArray(rightArrayIndex)\r\n        this.removeAuxArray(leftArrayIndex)\r\n    }\r\n\r\n    MergeSort(low, high) {\r\n        if (high <= low) return;\r\n\r\n        let mid = Math.trunc((low + high) / 2)\r\n        this.MergeSort(low, mid);\r\n        this.MergeSort(mid + 1, high);\r\n        this.merge(low, mid, high);\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.MergeSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class PseudoTimSort extends Sort {\r\n    MIN_MERGE\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"PseudoTimSort\"\r\n        this.MIN_MERGE = 32\r\n    }\r\n\r\n    minRunLength(n) {\r\n        let r = 0;\r\n        while (n >= this.MIN_MERGE)\r\n        {\r\n            r |= (n & 1);\r\n            n >>= 1;\r\n        }\r\n        return n + r;\r\n    }\r\n\r\n    insertionSort(left, right) {\r\n        for (let i = left + 1; i <= right; i++) {\r\n            let temp = this.read(i);\r\n            let j = i - 1;\r\n            while (j >= left && this.read(j) > temp) {\r\n                this.write(j + 1, this.read(j))\r\n                j--;\r\n            }\r\n            this.write(j + 1, temp)\r\n        }\r\n    }\r\n\r\n    merge(l, m, r) {\r\n        let len1 = m - l + 1, len2 = r - m;\r\n        let left = this.createAuxArray(len1);\r\n        let right = this.createAuxArray(len2);\r\n        for(let x = 0; x < len1; x++)\r\n        {\r\n            // left[x] = arr[l + x];\r\n            this.auxWrite(x, this.read(l+x), left)\r\n        }\r\n        for(let x = 0; x < len2; x++)\r\n        {\r\n            // right[x] = arr[m + 1 + x];\r\n            this.auxWrite(x, this.read(m + 1 + x), right)\r\n        }\r\n\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = l;\r\n\r\n        while (i < len1 && j < len2)\r\n        {\r\n            // if (left[i] <= right[j])\r\n            if(this.auxRead(i, left) <= this.auxRead(j, right))\r\n            {\r\n                // arr[k] = left[i];\r\n                this.write(k, this.auxRead(i, left))\r\n                i++;\r\n            }\r\n            else\r\n            {\r\n                // arr[k] = right[j];\r\n                this.write(k, this.auxRead(j, right))\r\n                j++;\r\n            }\r\n            k++;\r\n        }\r\n\r\n        while (i < len1) {\r\n            // arr[k] = left[i];\r\n            this.write(k, this.auxRead(i, left))\r\n            k++;\r\n            i++;\r\n        }\r\n\r\n        while (j < len2) {\r\n            this.write(k, this.auxRead(j, right))\r\n            k++;\r\n            j++;\r\n        }\r\n        this.removeAuxArray(right)\r\n        this.removeAuxArray(left)\r\n    }\r\n\r\n    timSort(n)\r\n    {\r\n        let minRun = this.minRunLength(this.MIN_MERGE);\r\n\r\n        for(let i = 0; i < n; i += minRun)\r\n        {\r\n            this.insertionSort(i, Math.min(\r\n                (i + this.MIN_MERGE - 1), (n - 1)));\r\n        }\r\n\r\n        for(let size = minRun; size < n; size = 2 * size) {\r\n            for(let left = 0; left < n; left += 2 * size) {\r\n                let mid = left + size - 1;\r\n                let right = Math.min((left + 2 * size - 1), (n - 1));\r\n                if(mid < right) {\r\n                    this.merge(left, mid, right);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.timSort(high+1)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class SelectionSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"SelectionSort\"\r\n    }\r\n\r\n    SelectionSort() {\r\n        for (let i=0; i < this.arrLength; i++) {\r\n            let minIndex = i\r\n            for (let j=i; j < this.arrLength; j++) {\r\n                if (this.compare(j, minIndex, \"<\")) {\r\n                    minIndex = j\r\n                }\r\n            }\r\n\r\n            if (this.compare(i, minIndex, \">\")) {\r\n                this.swap(i, minIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.SelectionSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class SlowSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"SlowSort\"\r\n        this.warnLen = 120\r\n    }\r\n\r\n    SlowSort(i, j) {\r\n        if (i >= j) {\r\n            return;\r\n        }\r\n        let m = Math.floor((i + j) / 2);\r\n        this.SlowSort(i, m);\r\n        this.SlowSort(m + 1, j);\r\n        if (this.compare(j, m, \"<\")) {\r\n            this.swap(j, m)\r\n        }\r\n        this.SlowSort(i, j - 1)\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.SlowSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\nexport class StoogeSort extends Sort{\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.sortName = \"StoogeSort\"\r\n    }\r\n\r\n    StoogeSort(i, j) {\r\n        if (this.compare(i, j, \">\")) {\r\n            this.swap(i, j)\r\n        }\r\n        if (j - i > 1) {\r\n            let t = Math.trunc((j - i + 1) / 3)\r\n            this.StoogeSort(i, j - t)\r\n            this.StoogeSort(i + t, j)\r\n            this.StoogeSort(i, j - t)\r\n        }\r\n    }\r\n\r\n    runSort(low, high) {\r\n        this.StoogeSort(low, high)\r\n    }\r\n}","import {Sort} from \"./Sort\";\r\n\r\n/**\r\n * Default minimum size of a run.\r\n */\r\nconst DEFAULT_MIN_MERGE = 32\r\n\r\n/**\r\n * Minimum ordered subsequece required to do galloping.\r\n */\r\nconst DEFAULT_MIN_GALLOPING = 7\r\n\r\n/**\r\n * Default tmp storage length. Can increase depending on the size of the\r\n * smallest run to merge.\r\n */\r\nconst DEFAULT_TMP_STORAGE_LENGTH = 256\r\n\r\n/**\r\n * Pre-computed powers of 10 for efficient lexicographic comparison of\r\n * small integers.\r\n */\r\nconst POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9]\r\n\r\nlet results\r\n\r\n/**\r\n * Estimate the logarithm base 10 of a small integer.\r\n *\r\n * @param {number} x - The integer to estimate the logarithm of.\r\n * @return {number} - The estimated logarithm of the integer.\r\n */\r\nconst log10 = x => x < 1e5\r\n    ? x < 1e2\r\n        ? x < 1e1\r\n            ? 0\r\n            : 1\r\n        : x < 1e4\r\n            ? x < 1e3\r\n                ? 2\r\n                : 3\r\n            : 4\r\n    : x < 1e7\r\n        ? x < 1e6\r\n            ? 5\r\n            : 6\r\n        : x < 1e9\r\n            ? x < 1e8\r\n                ? 7\r\n                : 8\r\n            : 9\r\n\r\n/**\r\n * Default alphabetical comparison of items.\r\n *\r\n * @param {string|object|number} a - First element to compare.\r\n * @param {string|object|number} b - Second element to compare.\r\n * @return {number} - A positive number if a.toString() > b.toString(), a\r\n * negative number if .toString() < b.toString(), 0 otherwise.\r\n */\r\nfunction alphabeticalCompare(a, b) {\r\n    if (a === b) {\r\n        return 0\r\n    }\r\n\r\n    if (~~a === a && ~~b === b) {\r\n        if (a === 0 || b === 0) {\r\n            return a < b ? -1 : 1\r\n        }\r\n\r\n        if (a < 0 || b < 0) {\r\n            if (b >= 0) {\r\n                return -1\r\n            }\r\n\r\n            if (a >= 0) {\r\n                return 1\r\n            }\r\n\r\n            a = -a\r\n            b = -b\r\n        }\r\n\r\n        const al = log10(a)\r\n        const bl = log10(b)\r\n\r\n        let t = 0\r\n\r\n        if (al < bl) {\r\n            a *= POWERS_OF_TEN[bl - al - 1]\r\n            b /= 10\r\n            t = -1\r\n        } else if (al > bl) {\r\n            b *= POWERS_OF_TEN[al - bl - 1]\r\n            a /= 10\r\n            t = 1\r\n        }\r\n\r\n        if (a === b) {\r\n            return t\r\n        }\r\n\r\n        return a < b ? -1 : 1\r\n    }\r\n\r\n    const aStr = String(a)\r\n    const bStr = String(b)\r\n\r\n    if (aStr === bStr) {\r\n        return 0\r\n    }\r\n\r\n    return aStr < bStr ? -1 : 1\r\n}\r\n\r\n/**\r\n * Compute minimum run length for TimSort\r\n *\r\n * @param {number} n - The size of the array to sort.\r\n */\r\nfunction minRunLength(n) {\r\n    let r = 0\r\n\r\n    while (n >= DEFAULT_MIN_MERGE) {\r\n        r |= (n & 1)\r\n        n >>= 1\r\n    }\r\n\r\n    return n + r\r\n}\r\n\r\n/**\r\n * Counts the length of a monotonically ascending or strictly monotonically\r\n * descending sequence (run) starting at array[lo] in the range [lo, hi). If\r\n * the run is descending it is made ascending.\r\n *\r\n * @param {array} array - The array to reverse.\r\n * @param {number} lo - First element in the range (inclusive).\r\n * @param {number} hi - Last element in the range.\r\n * @param {function} compare - Item comparison function.\r\n * @return {number} - The length of the run.\r\n */\r\n\r\nexport class TimSort extends Sort {\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n\r\n        this.minGallop = DEFAULT_MIN_GALLOPING\r\n\r\n        this.tmpStorageLength = this.arrLength < 2 * DEFAULT_TMP_STORAGE_LENGTH\r\n            ? this.arrLength >>> 1\r\n            : DEFAULT_TMP_STORAGE_LENGTH\r\n\r\n        // this.tmp = new Array(this.tmpStorageLength)\r\n        this.tmp = this.createAuxArray(this.tmpStorageLength)\r\n\r\n        this.stackLength = this.arrLength < 120\r\n            ? 5\r\n            : this.arrLength < 1542\r\n                ? 10\r\n                : this.arrLength < 119151\r\n                    ? 19\r\n                    : 40\r\n\r\n        this.runStart = new Array(this.stackLength)\r\n        this.runLength = new Array(this.stackLength)\r\n\r\n        this.stackSize = 0\r\n        this.sortName = \"TimSort\"\r\n    }\r\n\r\n    makeAscendingRun(lo, hi) {\r\n        let runHi = lo + 1\r\n\r\n        if (runHi === hi) {\r\n            return 1\r\n        }\r\n\r\n        // Descending\r\n        // if (compare(array[runHi++], array[lo]) < 0) {\r\n        if (this.compare(runHi++, lo, \"<\")) {\r\n            // while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\r\n            while (runHi < hi && this.compare(runHi, runHi - 1, \"<\")) {\r\n                runHi++\r\n            }\r\n\r\n            // this.reverseRun(array, lo, runHi)\r\n            this.reverseRun(lo, runHi)\r\n            // reverseRun(results, lo, runHi)\r\n            // Ascending\r\n        } else {\r\n            // while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\r\n            while (runHi < hi && this.compare(runHi, runHi - 1, \">=\")) {\r\n                runHi++\r\n            }\r\n        }\r\n\r\n        return runHi - lo\r\n    }\r\n\r\n    /**\r\n     * Reverse an array in the range [lo, hi).\r\n     *\r\n     * @param {array} array - The array to reverse.\r\n     * @param {number} lo - First element in the range (inclusive).\r\n     * @param {number} hi - Last element in the range.\r\n     */\r\n\r\n\r\n    reverseRun(lo, hi) {\r\n        hi--\r\n\r\n        while (lo < hi) {\r\n            // const t = array[lo]\r\n            // array[lo++] = array[hi]\r\n            // array[hi--] = t\r\n            const t = this.read(lo)\r\n            this.write(lo++, this.read(hi))\r\n            this.write(hi--, t)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Perform the binary sort of the array in the range [lo, hi) where start is\r\n     * the first element possibly out of order.\r\n     *\r\n     * @param {array} array - The array to sort.\r\n     * @param {number} lo - First element in the range (inclusive).\r\n     * @param {number} hi - Last element in the range.\r\n     * @param {number} start - First element possibly out of order.\r\n     * @param {} compare - Item comparison function.\r\n     */\r\n\r\n\r\n    binaryInsertionSort(lo, hi, start) {\r\n        if (start === lo) {\r\n            start++\r\n        }\r\n\r\n        for (; start < hi; start++) {\r\n            // const pivot = array[start]\r\n            const pivot = this.read(start)\r\n\r\n            // const pivotIndex = results[start]\r\n\r\n            // Ranges of the array where pivot belongs\r\n            let left = lo\r\n            let right = start\r\n\r\n            /*\r\n             *   pivot >= array[i] for i in [lo, left)\r\n             *   pivot <  array[i] for i in  in [right, start)\r\n             */\r\n            while (left < right) {\r\n                const mid = (left + right) >>> 1\r\n\r\n                // if (compare(pivot, array[mid]) < 0) {\r\n                if (pivot < this.read(mid)) {\r\n                    right = mid\r\n                } else {\r\n                    left = mid + 1\r\n                }\r\n            }\r\n\r\n            /*\r\n             * Move elements right to make room for the pivot. If there are elements\r\n             * equal to pivot, left points to the first slot after them: this is also\r\n             * a reason for which TimSort is stable\r\n             */\r\n            let n = start - left\r\n            // Switch is just an optimization for small arrays\r\n            switch (n) {\r\n                case 3:\r\n                    // array[left + 3] = array[left + 2]\r\n                    this.write(left + 3, this.read(left + 2))\r\n                /* falls through */\r\n                case 2:\r\n                    // array[left + 2] = array[left + 1]\r\n                    this.write(left + 2, this.read(left + 1))\r\n                /* falls through */\r\n                case 1:\r\n                    // array[left + 1] = array[left]\r\n                    this.write(left + 1, this.read(left))\r\n                    break\r\n                default:\r\n                    while (n > 0) {\r\n                        // array[left + n] = array[left + n - 1]\r\n                        this.write(left + n, this.read(left + n - 1))\r\n                        n--\r\n                    }\r\n            }\r\n\r\n            // array[left] = pivot\r\n            this.write(left, pivot)\r\n            // results[left] = pivotIndex\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find the position at which to insert a value in a sorted range. If the range\r\n     * contains elements equal to the value the leftmost element index is returned\r\n     * (for stability).\r\n     *\r\n     * @param {number} value - Value to insert.\r\n     * @param {array} array - The array in which to insert value.\r\n     * @param {number} start - First element in the range.\r\n     * @param {number} length - Length of the range.\r\n     * @param {number} hint - The index at which to begin the search.\r\n     * @param {function} compare - Item comparison function.\r\n     * @return {number} - The index where to insert value.\r\n     */\r\n\r\n\r\n    gallopLeft(value, isAux, start, length, hint) {\r\n        let lastOffset = 0\r\n        let maxOffset = 0\r\n        let offset = 1\r\n        if (!isAux) {\r\n            // if (compare(value, array[start + hint]) > 0) {\r\n            if (value > this.read(start + hint)) {\r\n                maxOffset = length - hint\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint + offset]) > 0\r\n                    && value > this.read(start + hint + offset)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint\r\n                offset += hint\r\n\r\n                // value <= array[start + hint]\r\n            } else {\r\n                maxOffset = hint + 1\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint - offset]) <= 0\r\n                    // && value <= this.read(start + hint + offset)\r\n                    && value <= this.read(start + hint - offset)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                const tmp = lastOffset\r\n                lastOffset = hint - offset\r\n                offset = hint - tmp\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++\r\n            while (lastOffset < offset) {\r\n                const m = lastOffset + ((offset - lastOffset) >>> 1)\r\n\r\n                // if (compare(value, array[start + m]) > 0) {\r\n                if (value > this.read(start + m)) {\r\n                    lastOffset = m + 1\r\n                } else {\r\n                    offset = m\r\n                }\r\n            }\r\n        } else {\r\n            // if (compare(value, array[start + hint]) > 0) {\r\n            if (value > this.auxRead(start + hint, this.tmp)) {\r\n                maxOffset = length - hint\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint + offset]) > 0\r\n                    && value > this.auxRead(start + hint + offset, this.tmp)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint\r\n                offset += hint\r\n\r\n                // value <= array[start + hint]\r\n            } else {\r\n                maxOffset = hint + 1\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint - offset]) <= 0\r\n                    // && value <= this.auxRead(start + hint + offset, this.tmp)\r\n                    && value <= this.auxRead(start + hint - offset, this.tmp)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                const tmp = lastOffset\r\n                lastOffset = hint - offset\r\n                offset = hint - tmp\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++\r\n            while (lastOffset < offset) {\r\n                const m = lastOffset + ((offset - lastOffset) >>> 1)\r\n\r\n                // if (compare(value, array[start + m]) > 0) {\r\n                if (value > this.auxRead(start + m, this.tmp)) {\r\n                    lastOffset = m + 1\r\n                } else {\r\n                    offset = m\r\n                }\r\n            }\r\n        }\r\n        return offset\r\n    }\r\n\r\n    /**\r\n     * Find the position at which to insert a value in a sorted range. If the range\r\n     * contains elements equal to the value the rightmost element index is returned\r\n     * (for stability).\r\n     *\r\n     * @param {number} value - Value to insert.\r\n     * @param {array} array - The array in which to insert value.\r\n     * @param {number} start - First element in the range.\r\n     * @param {number} length - Length of the range.\r\n     * @param {number} hint - The index at which to begin the search.\r\n     * @param {function} compare - Item comparison function.\r\n     * @return {number} - The index where to insert value.\r\n     */\r\n\r\n\r\n    gallopRight(value, isAux, start, length, hint) {\r\n        let lastOffset = 0\r\n        let maxOffset = 0\r\n        let offset = 1\r\n\r\n        if (!isAux) {\r\n            // if (compare(value, array[start + hint]) < 0) {\r\n            if (value < this.read(start + hint)) {\r\n                maxOffset = hint + 1\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint - offset]) < 0\r\n                    && value < this.read(start + hint - offset)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                const tmp = lastOffset\r\n                lastOffset = hint - offset\r\n                offset = hint - tmp\r\n\r\n                // value >= array[start + hint]\r\n            } else {\r\n                maxOffset = length - hint\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint + offset]) >= 0\r\n                    && value >= this.read(start + hint + offset)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint\r\n                offset += hint\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++\r\n\r\n            while (lastOffset < offset) {\r\n                const m = lastOffset + ((offset - lastOffset) >>> 1)\r\n\r\n                // if (compare(value, array[start + m]) < 0) {\r\n                if (value < this.read(start + m)) {\r\n                    offset = m\r\n                } else {\r\n                    lastOffset = m + 1\r\n                }\r\n            }\r\n\r\n        } else {\r\n            //AUX\r\n            // if (compare(value, array[start + hint]) < 0) {\r\n            if (value < this.auxRead(start + hint, this.tmp)) {\r\n                maxOffset = hint + 1\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint - offset]) < 0\r\n                    && value < this.auxRead(start + hint - offset, this.tmp)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                const tmp = lastOffset\r\n                lastOffset = hint - offset\r\n                offset = hint - tmp\r\n\r\n                // value >= array[start + hint]\r\n            } else {\r\n                maxOffset = length - hint\r\n\r\n                while (\r\n                    offset < maxOffset\r\n                    // && compare(value, array[start + hint + offset]) >= 0\r\n                    && value >= this.auxRead(start + hint + offset, this.tmp)\r\n                    ) {\r\n                    lastOffset = offset\r\n                    offset = (offset << 1) + 1\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint\r\n                offset += hint\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++\r\n\r\n            while (lastOffset < offset) {\r\n                const m = lastOffset + ((offset - lastOffset) >>> 1)\r\n\r\n                // if (compare(value, array[start + m]) < 0) {\r\n                if (value < this.auxRead(start + m, this.tmp)) {\r\n                    offset = m\r\n                } else {\r\n                    lastOffset = m + 1\r\n                }\r\n            }\r\n        }\r\n\r\n        return offset\r\n    }\r\n\r\n\r\n    /**\r\n     * Push a new run on TimSort's stack.\r\n     *\r\n     * @param {number} runStart - Start index of the run in the original array.\r\n     * @param {number} runLength - Length of the run;\r\n     */\r\n    pushRun(runStart, runLength) {\r\n        this.runStart[this.stackSize] = runStart\r\n        this.runLength[this.stackSize] = runLength\r\n        this.stackSize += 1\r\n    }\r\n\r\n    /**\r\n     * Merge runs on TimSort's stack so that the following holds for all i:\r\n     * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]\r\n     * 2) runLength[i - 2] > runLength[i - 1]\r\n     */\r\n    mergeRuns() {\r\n        while (this.stackSize > 1) {\r\n            let n = this.stackSize - 2\r\n\r\n            if (\r\n                (\r\n                    n >= 1\r\n                    && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1]\r\n                )\r\n                || (\r\n                    n >= 2\r\n                    && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]\r\n                )\r\n            ) {\r\n                if (this.runLength[n - 1] < this.runLength[n + 1]) {\r\n                    n--\r\n                }\r\n            } else if (this.runLength[n] > this.runLength[n + 1]) {\r\n                break\r\n            }\r\n            this.mergeAt(n)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge all runs on TimSort's stack until only one remains.\r\n     */\r\n    forceMergeRuns() {\r\n        while (this.stackSize > 1) {\r\n            let n = this.stackSize - 2\r\n\r\n            if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {\r\n                n--\r\n            }\r\n\r\n            this.mergeAt(n)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge the runs on the stack at positions i and i+1. Must be always be called\r\n     * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).\r\n     *\r\n     * @param {number} i - Index of the run to merge in TimSort's stack.\r\n     */\r\n    mergeAt(i) {\r\n        let start1 = this.runStart[i]\r\n        let length1 = this.runLength[i]\r\n        const start2 = this.runStart[i + 1]\r\n        let length2 = this.runLength[i + 1]\r\n\r\n        this.runLength[i] = length1 + length2\r\n\r\n        if (i === this.stackSize - 3) {\r\n            this.runStart[i + 1] = this.runStart[i + 2]\r\n            this.runLength[i + 1] = this.runLength[i + 2]\r\n        }\r\n\r\n        this.stackSize--\r\n\r\n        /*\r\n         * Find where the first element in the second run goes in run1. Previous\r\n         * elements in run1 are already in place\r\n         */\r\n        // const k = gallopRight(array[start2], array, start1, length1, 0, compare)\r\n        const k = this.gallopRight(this.read(start2), false, start1, length1, 0)\r\n        start1 += k\r\n        length1 -= k\r\n\r\n        if (length1 === 0) {\r\n            return\r\n        }\r\n\r\n        /*\r\n         * Find where the last element in the first run goes in run2. Next elements\r\n         * in run2 are already in place\r\n         */\r\n        // length2 = gallopLeft(\r\n        //     array[start1 + length1 - 1],\r\n        //     array,\r\n        //     start2,\r\n        //     length2,\r\n        //     length2 - 1,\r\n        //     compare\r\n        // )\r\n        length2 = this.gallopLeft(\r\n            // array[start1 + length1 - 1],\r\n            this.read(start1 + length1 - 1),\r\n            false,\r\n            start2,\r\n            length2,\r\n            length2 - 1,\r\n        )\r\n\r\n        if (length2 === 0) {\r\n            return\r\n        }\r\n\r\n        /*\r\n         * Merge remaining runs. A tmp array with length = min(length1, length2) is\r\n         * used\r\n         */\r\n        if (length1 <= length2) {\r\n            this.mergeLow(start1, length1, start2, length2)\r\n        } else {\r\n            this.mergeHigh(start1, length1, start2, length2)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge two adjacent runs in a stable way. The runs must be such that the\r\n     * first element of run1 is bigger than the first element in run2 and the\r\n     * last element of run1 is greater than all the elements in run2.\r\n     * The method should be called when run1.length <= run2.length as it uses\r\n     * TimSort temporary array to store run1. Use mergeHigh if run1.length >\r\n     * run2.length.\r\n     *\r\n     * @param {number} start1 - First element in run1.\r\n     * @param {number} length1 - Length of run1.\r\n     * @param {number} start2 - First element in run2.\r\n     * @param {number} length2 - Length of run2.\r\n     */\r\n    mergeLow(start1, length1, start2, length2) {\r\n        // const {compare} = this\r\n        // const {array} = this\r\n        // const {tmp} = this\r\n        // const {tmpIndex} = this\r\n        // const {compare} = this\r\n        // const {array} = this\r\n        // const {tmp} = this\r\n        // const {tmpIndex} = this\r\n        let i = 0\r\n\r\n        for (i = 0; i < length1; i++) {\r\n            // tmp[i] = array[start1 + i]\r\n            this.auxWrite(i, this.read(start1 + i), this.tmp)\r\n        }\r\n\r\n        let cursor1 = 0\r\n        let cursor2 = start2\r\n        let dest = start1\r\n\r\n\r\n        // array[dest] = array[cursor2]\r\n        this.write(dest, this.read(cursor2))\r\n\r\n\r\n        dest++\r\n        cursor2++\r\n\r\n        if (--length2 === 0) {\r\n            for (i = 0; i < length1; i++) {\r\n                // array[dest + i] = tmp[cursor1 + i]\r\n                this.write(dest + i, this.auxRead(cursor1 + i, this.tmp))\r\n            }\r\n            return\r\n        }\r\n\r\n        if (length1 === 1) {\r\n            for (i = 0; i < length2; i++) {\r\n                // array[dest + i] = array[cursor2 + i]\r\n\r\n                this.write(dest + i, this.read(cursor2 + i))\r\n            }\r\n            // array[dest + length2] = tmp[cursor1]\r\n            this.write(dest + length2, this.auxRead(cursor1, this.tmp))\r\n            return\r\n        }\r\n\r\n        let {minGallop} = this\r\n\r\n        while (true) {\r\n            let count1 = 0\r\n            let count2 = 0\r\n            let exit = false\r\n\r\n            do {\r\n                // if (compare(array[cursor2], tmp[cursor1]) < 0) {\r\n                if (this.read(cursor2) < this.auxRead(cursor1, this.tmp)) {\r\n                    // array[dest] = array[cursor2]\r\n                    this.write(dest, this.read(cursor2))\r\n                    dest++\r\n                    cursor2++\r\n                    count2++\r\n                    count1 = 0\r\n\r\n                    if (--length2 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                } else {\r\n                    // array[dest] = tmp[cursor1]\r\n                    this.write(dest, this.auxRead(cursor1, this.tmp))\r\n\r\n                    dest++\r\n                    cursor1++\r\n                    count1++\r\n                    count2 = 0\r\n                    if (--length1 === 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n            } while ((count1 | count2) < minGallop)\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            do {\r\n                // count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare)\r\n                count1 = this.gallopRight(this.read(cursor2), true, cursor1, length1, 0)\r\n\r\n                if (count1 !== 0) {\r\n                    for (i = 0; i < count1; i++) {\r\n                        // array[dest + i] = tmp[cursor1 + i]\r\n                        // results[dest + i] = tmpIndex[cursor1 + i]\r\n                        this.write(dest + i, this.auxRead(cursor1 + i, this.tmp))\r\n                    }\r\n\r\n                    dest += count1\r\n                    cursor1 += count1\r\n                    length1 -= count1\r\n                    if (length1 <= 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n\r\n                // array[dest] = array[cursor2]\r\n                // results[dest] = results[cursor2]\r\n                this.write(dest, this.read(cursor2))\r\n\r\n                dest++\r\n                cursor2++\r\n\r\n                if (--length2 === 0) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                // count2 = this.gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare)\r\n                count2 = this.gallopLeft(this.auxRead(cursor1, this.tmp), false, cursor2, length2, 0)\r\n\r\n                if (count2 !== 0) {\r\n                    for (i = 0; i < count2; i++) {\r\n                        // array[dest + i] = array[cursor2 + i]\r\n                        // results[dest + i] = results[cursor2 + i]\r\n                        this.write(dest + i, this.read(cursor2 + i))\r\n                    }\r\n\r\n                    dest += count2\r\n                    cursor2 += count2\r\n                    length2 -= count2\r\n\r\n                    if (length2 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n                // array[dest] = tmp[cursor1]\r\n                // results[dest] = tmpIndex[cursor1]\r\n\r\n                this.write(dest, this.auxRead(cursor1, this.tmp))\r\n\r\n                dest++\r\n                cursor1++\r\n\r\n                if (--length1 === 1) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                minGallop--\r\n            } while (\r\n                count1 >= DEFAULT_MIN_GALLOPING\r\n                || count2 >= DEFAULT_MIN_GALLOPING\r\n                )\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            if (minGallop < 0) {\r\n                minGallop = 0\r\n            }\r\n\r\n            minGallop += 2\r\n        }\r\n\r\n        this.minGallop = minGallop\r\n\r\n        if (minGallop < 1) {\r\n            this.minGallop = 1\r\n        }\r\n\r\n        if (length1 === 1) {\r\n            for (i = 0; i < length2; i++) {\r\n                // array[dest + i] = array[cursor2 + i]\r\n                // results[dest + i] = results[cursor2 + i]\r\n                this.write(dest + i, this.read(cursor2 + i))\r\n            }\r\n            // array[dest + length2] = tmp[cursor1]\r\n            // results[dest + length2] = tmpIndex[cursor1]\r\n            this.write(dest + length2, this.auxRead(cursor1, this.tmp))\r\n        } else if (length1 === 0) {\r\n            throw new Error('mergeLow preconditions were not respected')\r\n        } else {\r\n            for (i = 0; i < length1; i++) {\r\n                // array[dest + i] = tmp[cursor1 + i]\r\n                // results[dest + i] = tmpIndex[cursor1 + i]\r\n                this.write(dest + i, this.auxRead(cursor1 + i, this.tmp))\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge two adjacent runs in a stable way. The runs must be such that the\r\n     * first element of run1 is bigger than the first element in run2 and the\r\n     * last element of run1 is greater than all the elements in run2.\r\n     * The method should be called when run1.length > run2.length as it uses\r\n     * TimSort temporary array to store run2. Use mergeLow if run1.length <=\r\n     * run2.length.\r\n     *\r\n     * @param {number} start1 - First element in run1.\r\n     * @param {number} length1 - Length of run1.\r\n     * @param {number} start2 - First element in run2.\r\n     * @param {number} length2 - Length of run2.\r\n     */\r\n    mergeHigh(start1, length1, start2, length2) {\r\n        // const {compare} = this\r\n        // const {array} = this\r\n        // const {tmp} = this\r\n        // const {tmpIndex} = this\r\n        let i = 0\r\n\r\n        for (i = 0; i < length2; i++) {\r\n            // tmp[i] = array[start2 + i]\r\n            this.auxWrite(i, this.read(start2 + i), this.tmp)\r\n        }\r\n\r\n        let cursor1 = start1 + length1 - 1\r\n        let cursor2 = length2 - 1\r\n        let dest = start2 + length2 - 1\r\n        let customCursor = 0\r\n        let customDest = 0\r\n\r\n        // array[dest] = array[cursor1]\r\n        this.write(dest, this.read(cursor1))\r\n\r\n        dest--\r\n        cursor1--\r\n\r\n        if (--length1 === 0) {\r\n            customCursor = dest - (length2 - 1)\r\n\r\n            for (i = 0; i < length2; i++) {\r\n                // array[customCursor + i] = tmp[i]\r\n                this.write(customCursor + i, this.auxRead(i, this.tmp))\r\n            }\r\n\r\n            return\r\n        }\r\n\r\n        if (length2 === 1) {\r\n            dest -= length1\r\n            cursor1 -= length1\r\n            customDest = dest + 1\r\n            customCursor = cursor1 + 1\r\n\r\n            for (i = length1 - 1; i >= 0; i--) {\r\n                // array[customDest + i] = array[customCursor + i]\r\n                this.write(customDest + i, this.read(customCursor + i))\r\n            }\r\n\r\n            // array[dest] = tmp[cursor2]\r\n            this.write(dest, this.auxRead(cursor2, this.tmp))\r\n            return\r\n        }\r\n\r\n        let {minGallop} = this\r\n\r\n        while (true) {\r\n            let count1 = 0\r\n            let count2 = 0\r\n            let exit = false\r\n\r\n            do {\r\n                // if (compare(tmp[cursor2], array[cursor1]) < 0) {\r\n                if (this.auxRead(cursor2, this.tmp) < this.read(cursor1)) {\r\n                    // array[dest] = array[cursor1]\r\n                    this.write(dest, this.read(cursor1))\r\n                    dest--\r\n                    cursor1--\r\n                    count1++\r\n                    count2 = 0\r\n                    if (--length1 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                } else {\r\n                    // array[dest] = tmp[cursor2]\r\n                    this.write(dest, this.auxRead(cursor2, this.tmp))\r\n                    dest--\r\n                    cursor2--\r\n                    count2++\r\n                    count1 = 0\r\n                    if (--length2 === 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n            } while ((count1 | count2) < minGallop)\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            do {\r\n                // count1 = length1 - gallopRight(\r\n                //     tmp[cursor2],\r\n                //     array,\r\n                //     start1,\r\n                //     length1,\r\n                //     length1 - 1,\r\n                //     compare\r\n                // )\r\n                count1 = length1 - this.gallopRight(\r\n                    this.auxRead(cursor2, this.tmp),\r\n                    false,\r\n                    start1,\r\n                    length1,\r\n                    length1 - 1\r\n                )\r\n\r\n                if (count1 !== 0) {\r\n                    dest -= count1\r\n                    cursor1 -= count1\r\n                    length1 -= count1\r\n                    customDest = dest + 1\r\n                    customCursor = cursor1 + 1\r\n\r\n                    for (i = count1 - 1; i >= 0; i--) {\r\n                        // array[customDest + i] = array[customCursor + i]\r\n                        this.write(customDest + i, this.read(customCursor + i))\r\n                    }\r\n\r\n                    if (length1 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n\r\n                // array[dest] = tmp[cursor2]\r\n                this.write(dest, this.auxRead(cursor2, this.tmp))\r\n\r\n                dest--\r\n                cursor2--\r\n\r\n                if (--length2 === 1) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                // count2 = length2 - gallopLeft(\r\n                //     array[cursor1],\r\n                //     tmp,\r\n                //     0,\r\n                //     length2,\r\n                //     length2 - 1,\r\n                //     compare\r\n                // )\r\n\r\n                count2 = length2 - this.gallopLeft(\r\n                    this.read(cursor1),\r\n                    true,\r\n                    0,\r\n                    length2,\r\n                    length2 - 1\r\n                )\r\n\r\n                if (count2 !== 0) {\r\n                    dest -= count2\r\n                    cursor2 -= count2\r\n                    length2 -= count2\r\n                    customDest = dest + 1\r\n                    customCursor = cursor2 + 1\r\n\r\n                    for (i = 0; i < count2; i++) {\r\n                        // array[customDest + i] = tmp[customCursor + i]\r\n                        this.write(customDest + i, this.auxRead(customCursor + i, this.tmp))\r\n                    }\r\n\r\n                    if (length2 <= 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n\r\n                // array[dest] = array[cursor1]\r\n                this.write(dest, this.read(cursor1))\r\n\r\n                dest--\r\n                cursor1--\r\n\r\n                if (--length1 === 0) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                minGallop--\r\n            } while (\r\n                count1 >= DEFAULT_MIN_GALLOPING\r\n                || count2 >= DEFAULT_MIN_GALLOPING\r\n                )\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            if (minGallop < 0) {\r\n                minGallop = 0\r\n            }\r\n\r\n            minGallop += 2\r\n        }\r\n\r\n        this.minGallop = minGallop\r\n\r\n        if (minGallop < 1) {\r\n            this.minGallop = 1\r\n        }\r\n\r\n        if (length2 === 1) {\r\n            dest -= length1\r\n            cursor1 -= length1\r\n            customDest = dest + 1\r\n            customCursor = cursor1 + 1\r\n\r\n            for (i = length1 - 1; i >= 0; i--) {\r\n                // array[customDest + i] = array[customCursor + i]\r\n                this.write(customDest + i, this.read(customCursor + i))\r\n            }\r\n\r\n            // array[dest] = tmp[cursor2]\r\n            // results[dest] = tmpIndex[cursor2]\r\n\r\n            this.write(dest, this.auxRead(cursor2, this.tmp))\r\n\r\n\r\n        } else if (length2 === 0) {\r\n            throw new Error('mergeHigh preconditions were not respected')\r\n        } else {\r\n            customCursor = dest - (length2 - 1)\r\n            for (i = 0; i < length2; i++) {\r\n                // array[customCursor + i] = tmp[i]\r\n                this.write(customCursor + i, this.auxRead(i, this.tmp))\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Sort an array in the range [lo, hi) using TimSort.\r\n     *\r\n     * @param {array} array - The array to sort.\r\n     * @param {function=} compare - Item comparison function. Default is\r\n     *     alphabetical\r\n     * @param {number} lo - First element in the range (inclusive).\r\n     * @param {number} hi - Last element in the range.\r\n     *     comparator.\r\n     */\r\n    runSort(low, high) {\r\n        this.sort(low, high+1)\r\n    }\r\n\r\n    sort(lo, hi) {\r\n\r\n        let i = 0\r\n\r\n        let remaining = hi - lo\r\n\r\n        // The array is already sorted\r\n        if (remaining < 2) {\r\n            return results\r\n        }\r\n\r\n        let runLength = 0\r\n        // On small arrays binary sort can be used directly\r\n        if (remaining < DEFAULT_MIN_MERGE) {\r\n            runLength = this.makeAscendingRun(lo, hi)\r\n            this.binaryInsertionSort(lo, hi, lo + runLength)\r\n        }\r\n\r\n\r\n        const minRun = minRunLength(remaining)\r\n\r\n        do {\r\n            runLength = this.makeAscendingRun(lo, hi)\r\n            if (runLength < minRun) {\r\n                let force = remaining\r\n                if (force > minRun) {\r\n                    force = minRun\r\n                }\r\n\r\n                this.binaryInsertionSort(lo, lo + force, lo + runLength)\r\n                runLength = force\r\n            }\r\n            // Push new run and merge if necessary\r\n            this.pushRun(lo, runLength)\r\n            this.mergeRuns()\r\n\r\n            // Go find next run\r\n            remaining -= runLength\r\n            lo += runLength\r\n        } while (remaining !== 0)\r\n\r\n        // Force merging of remaining runs\r\n        this.forceMergeRuns()\r\n        this.removeAuxArray(this.tmp)\r\n    }\r\n}","/**\r\n * Default minimum size of a run.\r\n */\r\nconst DEFAULT_MIN_MERGE = 32\r\n\r\n/**\r\n * Minimum ordered subsequece required to do galloping.\r\n */\r\nconst DEFAULT_MIN_GALLOPING = 7\r\n\r\n/**\r\n * Default tmp storage length. Can increase depending on the size of the\r\n * smallest run to merge.\r\n */\r\nconst DEFAULT_TMP_STORAGE_LENGTH = 256\r\n\r\n/**\r\n * Pre-computed powers of 10 for efficient lexicographic comparison of\r\n * small integers.\r\n */\r\nconst POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9]\r\n\r\nlet results\r\n\r\n/**\r\n * Estimate the logarithm base 10 of a small integer.\r\n *\r\n * @param {number} x - The integer to estimate the logarithm of.\r\n * @return {number} - The estimated logarithm of the integer.\r\n */\r\nconst log10 = x => x < 1e5\r\n    ? x < 1e2\r\n        ? x < 1e1\r\n            ? 0\r\n            : 1\r\n        : x < 1e4\r\n            ? x < 1e3\r\n                ? 2\r\n                : 3\r\n            : 4\r\n    : x < 1e7\r\n        ? x < 1e6\r\n            ? 5\r\n            : 6\r\n        : x < 1e9\r\n            ? x < 1e8\r\n                ? 7\r\n                : 8\r\n            : 9\r\n\r\n/**\r\n * Default alphabetical comparison of items.\r\n *\r\n * @param {string|object|number} a - First element to compare.\r\n * @param {string|object|number} b - Second element to compare.\r\n * @return {number} - A positive number if a.toString() > b.toString(), a\r\n * negative number if .toString() < b.toString(), 0 otherwise.\r\n */\r\nfunction alphabeticalCompare (a, b) {\r\n    if (a === b) {\r\n        return 0\r\n    }\r\n\r\n    if (~ ~ a === a && ~ ~ b === b) {\r\n        if (a === 0 || b === 0) {\r\n            return a < b ? - 1 : 1\r\n        }\r\n\r\n        if (a < 0 || b < 0) {\r\n            if (b >= 0) {\r\n                return - 1\r\n            }\r\n\r\n            if (a >= 0) {\r\n                return 1\r\n            }\r\n\r\n            a = - a\r\n            b = - b\r\n        }\r\n\r\n        const al = log10(a)\r\n        const bl = log10(b)\r\n\r\n        let t = 0\r\n\r\n        if (al < bl) {\r\n            a *= POWERS_OF_TEN[bl - al - 1]\r\n            b /= 10\r\n            t = - 1\r\n        } else if (al > bl) {\r\n            b *= POWERS_OF_TEN[al - bl - 1]\r\n            a /= 10\r\n            t = 1\r\n        }\r\n\r\n        if (a === b) {\r\n            return t\r\n        }\r\n\r\n        return a < b ? - 1 : 1\r\n    }\r\n\r\n    const aStr = String(a)\r\n    const bStr = String(b)\r\n\r\n    if (aStr === bStr) {\r\n        return 0\r\n    }\r\n\r\n    return aStr < bStr ? - 1 : 1\r\n}\r\n\r\n/**\r\n * Compute minimum run length for TimSort\r\n *\r\n * @param {number} n - The size of the array to sort.\r\n */\r\nfunction minRunLength (n) {\r\n    let r = 0\r\n\r\n    while (n >= DEFAULT_MIN_MERGE) {\r\n        r |= (n & 1)\r\n        n >>= 1\r\n    }\r\n\r\n    return n + r\r\n}\r\n\r\n/**\r\n * Counts the length of a monotonically ascending or strictly monotonically\r\n * descending sequence (run) starting at array[lo] in the range [lo, hi). If\r\n * the run is descending it is made ascending.\r\n *\r\n * @param {array} array - The array to reverse.\r\n * @param {number} lo - First element in the range (inclusive).\r\n * @param {number} hi - Last element in the range.\r\n * @param {function} compare - Item comparison function.\r\n * @return {number} - The length of the run.\r\n */\r\nfunction makeAscendingRun (array, lo, hi, compare) {\r\n    let runHi = lo + 1\r\n\r\n    if (runHi === hi) {\r\n        return 1\r\n    }\r\n\r\n    // Descending\r\n    if (compare(array[runHi ++], array[lo]) < 0) {\r\n        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\r\n            runHi ++\r\n        }\r\n\r\n        reverseRun(array, lo, runHi)\r\n        reverseRun(results, lo, runHi)\r\n        // Ascending\r\n    } else {\r\n        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\r\n            runHi ++\r\n        }\r\n    }\r\n\r\n    return runHi - lo\r\n}\r\n\r\n/**\r\n * Reverse an array in the range [lo, hi).\r\n *\r\n * @param {array} array - The array to reverse.\r\n * @param {number} lo - First element in the range (inclusive).\r\n * @param {number} hi - Last element in the range.\r\n */\r\nfunction reverseRun (array, lo, hi) {\r\n    hi --\r\n\r\n    while (lo < hi) {\r\n        const t = array[lo]\r\n        array[lo ++] = array[hi]\r\n        array[hi --] = t\r\n    }\r\n}\r\n\r\n/**\r\n * Perform the binary sort of the array in the range [lo, hi) where start is\r\n * the first element possibly out of order.\r\n *\r\n * @param {array} array - The array to sort.\r\n * @param {number} lo - First element in the range (inclusive).\r\n * @param {number} hi - Last element in the range.\r\n * @param {number} start - First element possibly out of order.\r\n * @param {function} compare - Item comparison function.\r\n */\r\nfunction binaryInsertionSort (array, lo, hi, start, compare) {\r\n    if (start === lo) {\r\n        start ++\r\n    }\r\n\r\n    for (; start < hi; start ++) {\r\n        const pivot = array[start]\r\n        const pivotIndex = results[start]\r\n\r\n        // Ranges of the array where pivot belongs\r\n        let left = lo\r\n        let right = start\r\n\r\n        /*\r\n         *   pivot >= array[i] for i in [lo, left)\r\n         *   pivot <  array[i] for i in  in [right, start)\r\n         */\r\n        while (left < right) {\r\n            const mid = (left + right) >>> 1\r\n\r\n            if (compare(pivot, array[mid]) < 0) {\r\n                right = mid\r\n            } else {\r\n                left = mid + 1\r\n            }\r\n        }\r\n\r\n        /*\r\n         * Move elements right to make room for the pivot. If there are elements\r\n         * equal to pivot, left points to the first slot after them: this is also\r\n         * a reason for which TimSort is stable\r\n         */\r\n        let n = start - left\r\n        // Switch is just an optimization for small arrays\r\n        switch (n) {\r\n            case 3:\r\n                array[left + 3] = array[left + 2]\r\n                results[left + 3] = results[left + 2]\r\n            /* falls through */\r\n            case 2:\r\n                array[left + 2] = array[left + 1]\r\n                results[left + 2] = results[left + 1]\r\n            /* falls through */\r\n            case 1:\r\n                array[left + 1] = array[left]\r\n                results[left + 1] = results[left]\r\n                break\r\n            default:\r\n                while (n > 0) {\r\n                    array[left + n] = array[left + n - 1]\r\n                    results[left + n] = results[left + n - 1]\r\n                    n --\r\n                }\r\n        }\r\n\r\n        array[left] = pivot\r\n        results[left] = pivotIndex\r\n    }\r\n}\r\n\r\n/**\r\n * Find the position at which to insert a value in a sorted range. If the range\r\n * contains elements equal to the value the leftmost element index is returned\r\n * (for stability).\r\n *\r\n * @param {number} value - Value to insert.\r\n * @param {array} array - The array in which to insert value.\r\n * @param {number} start - First element in the range.\r\n * @param {number} length - Length of the range.\r\n * @param {number} hint - The index at which to begin the search.\r\n * @param {function} compare - Item comparison function.\r\n * @return {number} - The index where to insert value.\r\n */\r\nfunction gallopLeft (value, array, start, length, hint, compare) {\r\n    let lastOffset = 0\r\n    let maxOffset = 0\r\n    let offset = 1\r\n\r\n    if (compare(value, array[start + hint]) > 0) {\r\n        maxOffset = length - hint\r\n\r\n        while (\r\n            offset < maxOffset\r\n            && compare(value, array[start + hint + offset]) > 0\r\n            ) {\r\n            lastOffset = offset\r\n            offset = (offset << 1) + 1\r\n\r\n            if (offset <= 0) {\r\n                offset = maxOffset\r\n            }\r\n        }\r\n\r\n        if (offset > maxOffset) {\r\n            offset = maxOffset\r\n        }\r\n\r\n        // Make offsets relative to start\r\n        lastOffset += hint\r\n        offset += hint\r\n\r\n        // value <= array[start + hint]\r\n    } else {\r\n        maxOffset = hint + 1\r\n        while (\r\n            offset < maxOffset\r\n            && compare(value, array[start + hint - offset]) <= 0\r\n            ) {\r\n            lastOffset = offset\r\n            offset = (offset << 1) + 1\r\n\r\n            if (offset <= 0) {\r\n                offset = maxOffset\r\n            }\r\n        }\r\n        if (offset > maxOffset) {\r\n            offset = maxOffset\r\n        }\r\n\r\n        // Make offsets relative to start\r\n        const tmp = lastOffset\r\n        lastOffset = hint - offset\r\n        offset = hint - tmp\r\n    }\r\n\r\n    /*\r\n     * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n     * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n     * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n     * array[start + offset].\r\n     */\r\n    lastOffset ++\r\n    while (lastOffset < offset) {\r\n        const m = lastOffset + ((offset - lastOffset) >>> 1)\r\n\r\n        if (compare(value, array[start + m]) > 0) {\r\n            lastOffset = m + 1\r\n        } else {\r\n            offset = m\r\n        }\r\n    }\r\n    return offset\r\n}\r\n\r\n/**\r\n * Find the position at which to insert a value in a sorted range. If the range\r\n * contains elements equal to the value the rightmost element index is returned\r\n * (for stability).\r\n *\r\n * @param {number} value - Value to insert.\r\n * @param {array} array - The array in which to insert value.\r\n * @param {number} start - First element in the range.\r\n * @param {number} length - Length of the range.\r\n * @param {number} hint - The index at which to begin the search.\r\n * @param {function} compare - Item comparison function.\r\n * @return {number} - The index where to insert value.\r\n */\r\nfunction gallopRight (value, array, start, length, hint, compare) {\r\n    let lastOffset = 0\r\n    let maxOffset = 0\r\n    let offset = 1\r\n\r\n    if (compare(value, array[start + hint]) < 0) {\r\n        maxOffset = hint + 1\r\n\r\n        while (\r\n            offset < maxOffset\r\n            && compare(value, array[start + hint - offset]) < 0\r\n            ) {\r\n            lastOffset = offset\r\n            offset = (offset << 1) + 1\r\n\r\n            if (offset <= 0) {\r\n                offset = maxOffset\r\n            }\r\n        }\r\n\r\n        if (offset > maxOffset) {\r\n            offset = maxOffset\r\n        }\r\n\r\n        // Make offsets relative to start\r\n        const tmp = lastOffset\r\n        lastOffset = hint - offset\r\n        offset = hint - tmp\r\n\r\n        // value >= array[start + hint]\r\n    } else {\r\n        maxOffset = length - hint\r\n\r\n        while (\r\n            offset < maxOffset\r\n            && compare(value, array[start + hint + offset]) >= 0\r\n            ) {\r\n            lastOffset = offset\r\n            offset = (offset << 1) + 1\r\n\r\n            if (offset <= 0) {\r\n                offset = maxOffset\r\n            }\r\n        }\r\n\r\n        if (offset > maxOffset) {\r\n            offset = maxOffset\r\n        }\r\n\r\n        // Make offsets relative to start\r\n        lastOffset += hint\r\n        offset += hint\r\n    }\r\n\r\n    /*\r\n     * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n     * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n     * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n     * array[start + offset].\r\n     */\r\n    lastOffset ++\r\n\r\n    while (lastOffset < offset) {\r\n        const m = lastOffset + ((offset - lastOffset) >>> 1)\r\n\r\n        if (compare(value, array[start + m]) < 0) {\r\n            offset = m\r\n        } else {\r\n            lastOffset = m + 1\r\n        }\r\n    }\r\n\r\n    return offset\r\n}\r\n\r\nclass TimSort {\r\n    constructor (array, compare) {\r\n        this.array = array\r\n        this.compare = compare\r\n\r\n        const {length} = array\r\n\r\n        this.length = length\r\n        this.minGallop = DEFAULT_MIN_GALLOPING\r\n\r\n        this.tmpStorageLength = length < 2 * DEFAULT_TMP_STORAGE_LENGTH\r\n            ? length >>> 1\r\n            : DEFAULT_TMP_STORAGE_LENGTH\r\n\r\n        this.tmp = new Array(this.tmpStorageLength)\r\n        this.tmpIndex = new Array(this.tmpStorageLength)\r\n\r\n        this.stackLength = length < 120\r\n            ? 5\r\n            : length < 1542\r\n                ? 10\r\n                : length < 119151\r\n                    ? 19\r\n                    : 40\r\n\r\n        this.runStart = new Array(this.stackLength)\r\n        this.runLength = new Array(this.stackLength)\r\n\r\n        this.stackSize = 0\r\n    }\r\n\r\n    /**\r\n     * Push a new run on TimSort's stack.\r\n     *\r\n     * @param {number} runStart - Start index of the run in the original array.\r\n     * @param {number} runLength - Length of the run;\r\n     */\r\n    pushRun (runStart, runLength) {\r\n        this.runStart[this.stackSize] = runStart\r\n        this.runLength[this.stackSize] = runLength\r\n        this.stackSize += 1\r\n    }\r\n\r\n    /**\r\n     * Merge runs on TimSort's stack so that the following holds for all i:\r\n     * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]\r\n     * 2) runLength[i - 2] > runLength[i - 1]\r\n     */\r\n    mergeRuns () {\r\n        while (this.stackSize > 1) {\r\n            let n = this.stackSize - 2\r\n\r\n            if (\r\n                (\r\n                    n >= 1\r\n                    && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1]\r\n                )\r\n                || (\r\n                    n >= 2\r\n                    && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]\r\n                )\r\n            ) {\r\n                if (this.runLength[n - 1] < this.runLength[n + 1]) {\r\n                    n --\r\n                }\r\n            } else if (this.runLength[n] > this.runLength[n + 1]) {\r\n                break\r\n            }\r\n            this.mergeAt(n)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge all runs on TimSort's stack until only one remains.\r\n     */\r\n    forceMergeRuns () {\r\n        while (this.stackSize > 1) {\r\n            let n = this.stackSize - 2\r\n\r\n            if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {\r\n                n --\r\n            }\r\n\r\n            this.mergeAt(n)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge the runs on the stack at positions i and i+1. Must be always be called\r\n     * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).\r\n     *\r\n     * @param {number} i - Index of the run to merge in TimSort's stack.\r\n     */\r\n    mergeAt (i) {\r\n        const {compare} = this\r\n        const {array} = this\r\n\r\n        let start1 = this.runStart[i]\r\n        let length1 = this.runLength[i]\r\n        const start2 = this.runStart[i + 1]\r\n        let length2 = this.runLength[i + 1]\r\n\r\n        this.runLength[i] = length1 + length2\r\n\r\n        if (i === this.stackSize - 3) {\r\n            this.runStart[i + 1] = this.runStart[i + 2]\r\n            this.runLength[i + 1] = this.runLength[i + 2]\r\n        }\r\n\r\n        this.stackSize --\r\n\r\n        /*\r\n         * Find where the first element in the second run goes in run1. Previous\r\n         * elements in run1 are already in place\r\n         */\r\n        const k = gallopRight(array[start2], array, start1, length1, 0, compare)\r\n        start1 += k\r\n        length1 -= k\r\n\r\n        if (length1 === 0) {\r\n            return\r\n        }\r\n\r\n        /*\r\n         * Find where the last element in the first run goes in run2. Next elements\r\n         * in run2 are already in place\r\n         */\r\n        length2 = gallopLeft(\r\n            array[start1 + length1 - 1],\r\n            array,\r\n            start2,\r\n            length2,\r\n            length2 - 1,\r\n            compare\r\n        )\r\n\r\n        if (length2 === 0) {\r\n            return\r\n        }\r\n\r\n        /*\r\n         * Merge remaining runs. A tmp array with length = min(length1, length2) is\r\n         * used\r\n         */\r\n        if (length1 <= length2) {\r\n            this.mergeLow(start1, length1, start2, length2)\r\n        } else {\r\n            this.mergeHigh(start1, length1, start2, length2)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge two adjacent runs in a stable way. The runs must be such that the\r\n     * first element of run1 is bigger than the first element in run2 and the\r\n     * last element of run1 is greater than all the elements in run2.\r\n     * The method should be called when run1.length <= run2.length as it uses\r\n     * TimSort temporary array to store run1. Use mergeHigh if run1.length >\r\n     * run2.length.\r\n     *\r\n     * @param {number} start1 - First element in run1.\r\n     * @param {number} length1 - Length of run1.\r\n     * @param {number} start2 - First element in run2.\r\n     * @param {number} length2 - Length of run2.\r\n     */\r\n    mergeLow (start1, length1, start2, length2) {\r\n        const {compare} = this\r\n        const {array} = this\r\n        const {tmp} = this\r\n        const {tmpIndex} = this\r\n        let i = 0\r\n\r\n        for (i = 0; i < length1; i ++) {\r\n            tmp[i] = array[start1 + i]\r\n            tmpIndex[i] = results[start1 + i]\r\n        }\r\n\r\n        let cursor1 = 0\r\n        let cursor2 = start2\r\n        let dest = start1\r\n\r\n        array[dest] = array[cursor2]\r\n        results[dest] = results[cursor2]\r\n\r\n        dest ++\r\n        cursor2 ++\r\n\r\n        if (-- length2 === 0) {\r\n            for (i = 0; i < length1; i ++) {\r\n                array[dest + i] = tmp[cursor1 + i]\r\n                results[dest + i] = tmpIndex[cursor1 + i]\r\n            }\r\n            return\r\n        }\r\n\r\n        if (length1 === 1) {\r\n            for (i = 0; i < length2; i ++) {\r\n                array[dest + i] = array[cursor2 + i]\r\n                results[dest + i] = results[cursor2 + i]\r\n            }\r\n            array[dest + length2] = tmp[cursor1]\r\n            results[dest + length2] = tmpIndex[cursor1]\r\n            return\r\n        }\r\n\r\n        let {minGallop} = this\r\n\r\n        while (true) {\r\n            let count1 = 0\r\n            let count2 = 0\r\n            let exit = false\r\n\r\n            do {\r\n                if (compare(array[cursor2], tmp[cursor1]) < 0) {\r\n                    array[dest] = array[cursor2]\r\n                    results[dest] = results[cursor2]\r\n                    dest ++\r\n                    cursor2 ++\r\n                    count2 ++\r\n                    count1 = 0\r\n\r\n                    if (-- length2 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                } else {\r\n                    array[dest] = tmp[cursor1]\r\n                    results[dest] = tmpIndex[cursor1]\r\n                    dest ++\r\n                    cursor1 ++\r\n                    count1 ++\r\n                    count2 = 0\r\n                    if (-- length1 === 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n            } while ((count1 | count2) < minGallop)\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            do {\r\n                count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare)\r\n\r\n                if (count1 !== 0) {\r\n                    for (i = 0; i < count1; i ++) {\r\n                        array[dest + i] = tmp[cursor1 + i]\r\n                        results[dest + i] = tmpIndex[cursor1 + i]\r\n                    }\r\n\r\n                    dest += count1\r\n                    cursor1 += count1\r\n                    length1 -= count1\r\n                    if (length1 <= 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n\r\n                array[dest] = array[cursor2]\r\n                results[dest] = results[cursor2]\r\n\r\n                dest ++\r\n                cursor2 ++\r\n\r\n                if (-- length2 === 0) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare)\r\n\r\n                if (count2 !== 0) {\r\n                    for (i = 0; i < count2; i ++) {\r\n                        array[dest + i] = array[cursor2 + i]\r\n                        results[dest + i] = results[cursor2 + i]\r\n                    }\r\n\r\n                    dest += count2\r\n                    cursor2 += count2\r\n                    length2 -= count2\r\n\r\n                    if (length2 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n                array[dest] = tmp[cursor1]\r\n                results[dest] = tmpIndex[cursor1]\r\n                dest ++\r\n                cursor1 ++\r\n\r\n                if (-- length1 === 1) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                minGallop --\r\n            } while (\r\n                count1 >= DEFAULT_MIN_GALLOPING\r\n                || count2 >= DEFAULT_MIN_GALLOPING\r\n                )\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            if (minGallop < 0) {\r\n                minGallop = 0\r\n            }\r\n\r\n            minGallop += 2\r\n        }\r\n\r\n        this.minGallop = minGallop\r\n\r\n        if (minGallop < 1) {\r\n            this.minGallop = 1\r\n        }\r\n\r\n        if (length1 === 1) {\r\n            for (i = 0; i < length2; i ++) {\r\n                array[dest + i] = array[cursor2 + i]\r\n                results[dest + i] = results[cursor2 + i]\r\n            }\r\n            array[dest + length2] = tmp[cursor1]\r\n            results[dest + length2] = tmpIndex[cursor1]\r\n        } else if (length1 === 0) {\r\n            throw new Error('mergeLow preconditions were not respected')\r\n        } else {\r\n            for (i = 0; i < length1; i ++) {\r\n                array[dest + i] = tmp[cursor1 + i]\r\n                results[dest + i] = tmpIndex[cursor1 + i]\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge two adjacent runs in a stable way. The runs must be such that the\r\n     * first element of run1 is bigger than the first element in run2 and the\r\n     * last element of run1 is greater than all the elements in run2.\r\n     * The method should be called when run1.length > run2.length as it uses\r\n     * TimSort temporary array to store run2. Use mergeLow if run1.length <=\r\n     * run2.length.\r\n     *\r\n     * @param {number} start1 - First element in run1.\r\n     * @param {number} length1 - Length of run1.\r\n     * @param {number} start2 - First element in run2.\r\n     * @param {number} length2 - Length of run2.\r\n     */\r\n    mergeHigh (start1, length1, start2, length2) {\r\n        const {compare} = this\r\n        const {array} = this\r\n        const {tmp} = this\r\n        const {tmpIndex} = this\r\n        let i = 0\r\n\r\n        for (i = 0; i < length2; i ++) {\r\n            tmp[i] = array[start2 + i]\r\n            tmpIndex[i] = results[start2 + i]\r\n        }\r\n\r\n        let cursor1 = start1 + length1 - 1\r\n        let cursor2 = length2 - 1\r\n        let dest = start2 + length2 - 1\r\n        let customCursor = 0\r\n        let customDest = 0\r\n\r\n        array[dest] = array[cursor1]\r\n        results[dest] = results[cursor1]\r\n\r\n        dest --\r\n        cursor1 --\r\n\r\n        if (-- length1 === 0) {\r\n            customCursor = dest - (length2 - 1)\r\n\r\n            for (i = 0; i < length2; i ++) {\r\n                array[customCursor + i] = tmp[i]\r\n                results[customCursor + i] = tmpIndex[i]\r\n            }\r\n\r\n            return\r\n        }\r\n\r\n        if (length2 === 1) {\r\n            dest -= length1\r\n            cursor1 -= length1\r\n            customDest = dest + 1\r\n            customCursor = cursor1 + 1\r\n\r\n            for (i = length1 - 1; i >= 0; i --) {\r\n                array[customDest + i] = array[customCursor + i]\r\n                results[customDest + i] = results[customCursor + i]\r\n            }\r\n\r\n            array[dest] = tmp[cursor2]\r\n            results[dest] = tmpIndex[cursor2]\r\n            return\r\n        }\r\n\r\n        let {minGallop} = this\r\n\r\n        while (true) {\r\n            let count1 = 0\r\n            let count2 = 0\r\n            let exit = false\r\n\r\n            do {\r\n                if (compare(tmp[cursor2], array[cursor1]) < 0) {\r\n                    array[dest] = array[cursor1]\r\n                    results[dest] = results[cursor1]\r\n                    dest --\r\n                    cursor1 --\r\n                    count1 ++\r\n                    count2 = 0\r\n                    if (-- length1 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                } else {\r\n                    array[dest] = tmp[cursor2]\r\n                    results[dest] = tmpIndex[cursor2]\r\n                    dest --\r\n                    cursor2 --\r\n                    count2 ++\r\n                    count1 = 0\r\n                    if (-- length2 === 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n            } while ((count1 | count2) < minGallop)\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            do {\r\n                count1 = length1 - gallopRight(\r\n                    tmp[cursor2],\r\n                    array,\r\n                    start1,\r\n                    length1,\r\n                    length1 - 1,\r\n                    compare\r\n                )\r\n\r\n                if (count1 !== 0) {\r\n                    dest -= count1\r\n                    cursor1 -= count1\r\n                    length1 -= count1\r\n                    customDest = dest + 1\r\n                    customCursor = cursor1 + 1\r\n\r\n                    for (i = count1 - 1; i >= 0; i --) {\r\n                        array[customDest + i] = array[customCursor + i]\r\n                        results[customDest + i] = results[customCursor + i]\r\n                    }\r\n\r\n                    if (length1 === 0) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n\r\n                array[dest] = tmp[cursor2]\r\n                results[dest] = tmpIndex[cursor2]\r\n                dest --\r\n                cursor2 --\r\n\r\n                if (-- length2 === 1) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                count2 = length2 - gallopLeft(\r\n                    array[cursor1],\r\n                    tmp,\r\n                    0,\r\n                    length2,\r\n                    length2 - 1,\r\n                    compare\r\n                )\r\n\r\n                if (count2 !== 0) {\r\n                    dest -= count2\r\n                    cursor2 -= count2\r\n                    length2 -= count2\r\n                    customDest = dest + 1\r\n                    customCursor = cursor2 + 1\r\n\r\n                    for (i = 0; i < count2; i ++) {\r\n                        array[customDest + i] = tmp[customCursor + i]\r\n                        results[customDest + i] = tmpIndex[customCursor + i]\r\n                    }\r\n\r\n                    if (length2 <= 1) {\r\n                        exit = true\r\n                        break\r\n                    }\r\n                }\r\n\r\n                array[dest] = array[cursor1]\r\n                results[dest] = results[cursor1]\r\n                dest --\r\n                cursor1 --\r\n\r\n                if (-- length1 === 0) {\r\n                    exit = true\r\n                    break\r\n                }\r\n\r\n                minGallop --\r\n            } while (\r\n                count1 >= DEFAULT_MIN_GALLOPING\r\n                || count2 >= DEFAULT_MIN_GALLOPING\r\n                )\r\n\r\n            if (exit) {\r\n                break\r\n            }\r\n\r\n            if (minGallop < 0) {\r\n                minGallop = 0\r\n            }\r\n\r\n            minGallop += 2\r\n        }\r\n\r\n        this.minGallop = minGallop\r\n\r\n        if (minGallop < 1) {\r\n            this.minGallop = 1\r\n        }\r\n\r\n        if (length2 === 1) {\r\n            dest -= length1\r\n            cursor1 -= length1\r\n            customDest = dest + 1\r\n            customCursor = cursor1 + 1\r\n\r\n            for (i = length1 - 1; i >= 0; i --) {\r\n                array[customDest + i] = array[customCursor + i]\r\n                results[customDest + i] = results[customCursor + i]\r\n            }\r\n\r\n            array[dest] = tmp[cursor2]\r\n            results[dest] = tmpIndex[cursor2]\r\n        } else if (length2 === 0) {\r\n            throw new Error('mergeHigh preconditions were not respected')\r\n        } else {\r\n            customCursor = dest - (length2 - 1)\r\n            for (i = 0; i < length2; i ++) {\r\n                array[customCursor + i] = tmp[i]\r\n                results[customCursor + i] = tmpIndex[i]\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Sort an array in the range [lo, hi) using TimSort.\r\n *\r\n * @param {array} array - The array to sort.\r\n * @param {function=} compare - Item comparison function. Default is\r\n *     alphabetical\r\n * @param {number} lo - First element in the range (inclusive).\r\n * @param {number} hi - Last element in the range.\r\n *     comparator.\r\n */\r\nfunction sort (array, compare, lo, hi) {\r\n    if (!Array.isArray(array)) {\r\n        throw new TypeError(\r\n            `The \"array\" argument must be an array. Received ${array}`\r\n        )\r\n    }\r\n\r\n    results = []\r\n\r\n    const {length} = array\r\n\r\n    let i = 0\r\n\r\n    while (i < length) {\r\n        results[i] = i ++\r\n    }\r\n\r\n    /*\r\n     * Handle the case where a comparison function is not provided. We do\r\n     * lexicographic sorting\r\n     */\r\n    if (!compare) {\r\n        compare = alphabeticalCompare\r\n    } else if (typeof compare !== 'function') {\r\n        hi = lo\r\n        lo = compare\r\n        compare = alphabeticalCompare\r\n    }\r\n\r\n    if (!lo) {\r\n        lo = 0\r\n    }\r\n    if (!hi) {\r\n        hi = length\r\n    }\r\n\r\n    let remaining = hi - lo\r\n\r\n    // The array is already sorted\r\n    if (remaining < 2) {\r\n        return results\r\n    }\r\n\r\n    let runLength = 0\r\n    // On small arrays binary sort can be used directly\r\n    if (remaining < DEFAULT_MIN_MERGE) {\r\n        runLength = makeAscendingRun(array, lo, hi, compare)\r\n        binaryInsertionSort(array, lo, hi, lo + runLength, compare)\r\n        return results\r\n    }\r\n\r\n    const ts = new TimSort(array, compare)\r\n\r\n    const minRun = minRunLength(remaining)\r\n\r\n    do {\r\n        runLength = makeAscendingRun(array, lo, hi, compare)\r\n        if (runLength < minRun) {\r\n            let force = remaining\r\n            if (force > minRun) {\r\n                force = minRun\r\n            }\r\n\r\n            binaryInsertionSort(array, lo, lo + force, lo + runLength, compare)\r\n            runLength = force\r\n        }\r\n        // Push new run and merge if necessary\r\n        ts.pushRun(lo, runLength)\r\n        ts.mergeRuns()\r\n\r\n        // Go find next run\r\n        remaining -= runLength\r\n        lo += runLength\r\n    } while (remaining !== 0)\r\n\r\n    // Force merging of remaining runs\r\n    ts.forceMergeRuns()\r\n\r\n    return results\r\n}\r\n\r\nmodule.exports = {\r\n    sort\r\n}\r\n","import {Sort} from \"./Sort\";\r\n\r\nexport class TimSort extends Sort {\r\n    stackSize\r\n    runBase\r\n    runLen\r\n\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n        this.MIN_MERGE = 32;\r\n        this.MIN_GALLOP = 7\r\n        this.runBase = [];\r\n        this.runLen = [];\r\n        this.stackSize = 0;\r\n        this.sortName = \"TimSort\"\r\n    }\r\n\r\n\r\n    /*\r\n         * The next two methods (which are package private and static) constitute the entire API of this class. Each of these methods\r\n         * obeys the contract of the public method with the same signature in java.util.Arrays.\r\n         */\r\n\r\n    runSort(lo, hi) {\r\n\r\n        // if (typeof compare != \"function\") {\r\n        //     throw new Error(\"Compare is not a function.\");\r\n        //     return;\r\n        // }\r\n\r\n        this.stackSize = 0;\r\n        this.runBase = [];\r\n        this.runLen = [];\r\n\r\n        this.rangeCheck(this.arrLength, lo, hi);\r\n        let nRemaining = hi - lo;\r\n        if (nRemaining < 2) return; // Arrays of size 0 and 1 are always sorted\r\n\r\n        // If array is small, do a \"mini-TimSort\" with no merges\r\n        if (nRemaining < this.MIN_MERGE) {\r\n            let initRunLen = this.countRunAndMakeAscending(lo, hi);\r\n            this.binarySort(lo, hi, lo + initRunLen);\r\n            return;\r\n        }\r\n\r\n        /**\r\n         * March over the array once, left to right, finding natural runs, extending short natural runs to minRun elements, and\r\n         * merging runs to maintain stack invariant.\r\n         */\r\n        let minRun = this.minRunLength(nRemaining);\r\n        do {\r\n            // Identify next run\r\n            let runLenVar = this.countRunAndMakeAscending(lo, hi);\r\n\r\n            // If run is short, extend to min(minRun, nRemaining)\r\n            if (runLenVar < minRun) {\r\n                let force = nRemaining <= minRun ? nRemaining : minRun;\r\n                this.binarySort(lo, lo + force, lo + runLenVar);\r\n                runLenVar = force;\r\n            }\r\n\r\n            // Push run onto pending-run stack, and maybe merge\r\n            this.pushRun(lo, runLenVar);\r\n            this.mergeCollapse();\r\n\r\n            // Advance to find next run\r\n            lo += runLenVar;\r\n            nRemaining -= runLenVar;\r\n        } while (nRemaining !== 0);\r\n\r\n        // Merge all remaining runs to complete sort\r\n        this.mergeForceCollapse();\r\n    }\r\n\r\n\r\n    /**\r\n     * Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for sorting small\r\n     * numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case).\r\n     *\r\n     * If the initial part of the specified range is already sorted, this method can take advantage of it: the method assumes that\r\n     * the elements from index {@code lo}, inclusive, to {@code start}, exclusive are already sorted.\r\n     *\r\n     * @param a the array in which a range is to be sorted\r\n     * @param lo the index of the first element in the range to be sorted\r\n     * @param hi the index after the last element in the range to be sorted\r\n     * @param start the index of the first element in the range that is not already known to be sorted (@code lo <= start <= hi}\r\n     * @param c comparator to used for the sort\r\n     */\r\n    // binarySort (a, lo, hi, start) {\r\n    binarySort(lo, hi, start) {\r\n        if (start === lo) start++;\r\n        for (; start < hi; start++) {\r\n            // let pivot = a[start];\r\n            let pivot = this.read(start);\r\n\r\n            // Set left (and right) to the index where a[start] (pivot) belongs\r\n            let left = lo;\r\n            let right = start;\r\n            /*\r\n            * Invariants: pivot >= all in [lo, left). pivot < all in [right, start).\r\n            */\r\n            while (left < right) {\r\n                let mid = (left + right) >>> 1;\r\n                // if (compare(pivot, a[mid]) < 0)\r\n                if (pivot < this.read(mid))\r\n                    right = mid;\r\n                else\r\n                    left = mid + 1;\r\n            }\r\n            /*\r\n            * The invariants still hold: pivot >= all in [lo, left) and pivot < all in [left, start), so pivot belongs at left. Note\r\n            * that if there are elements equal to pivot, left points to the first slot after them -- that's why this sort is stable.\r\n            * Slide elements over to make room to make room for pivot.\r\n            */\r\n            let n = start - left; // The number of elements to move\r\n            // Switch is just an optimization for arraycopy in default case\r\n            switch (n) {\r\n                case 2:\r\n                    // a[left + 2] = a[left + 1];\r\n                    this.write(left + 2, this.read(left + 1));\r\n                    break;//WARNING!!!\r\n                case 1:\r\n                    // a[left + 1] = a[left];\r\n                    this.write(left + 1, this.read(left))\r\n                    break;\r\n                default:\r\n                    // arraycopy(a, left, a, left + 1, n);\r\n                    while (n > 0) {\r\n                        // array[left + n] = array[left + n - 1];\r\n                        this.write(left + n, this.read(left + n - 1));\r\n                        n--;\r\n                    }\r\n            }\r\n            // a[left] = pivot;\r\n            this.write(left, pivot)\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the length of the run beginning at the specified position in the specified array and reverses the run if it is\r\n     * descending (ensuring that the run will always be ascending when the method returns).\r\n     *\r\n     * A run is the longest ascending sequence with:\r\n     *\r\n     * a[lo] <= a[lo + 1] <= a[lo + 2] <= ...\r\n     *\r\n     * or the longest descending sequence with:\r\n     *\r\n     * a[lo] > a[lo + 1] > a[lo + 2] > ...\r\n     *\r\n     * For its intended use in a stable mergesort, the strictness of the definition of \"descending\" is needed so that the call can\r\n     * safely reverse a descending sequence without violating stability.\r\n     *\r\n     * @param a the array in which a run is to be counted and possibly reversed\r\n     * @param lo index of the first element in the run\r\n     * @param hi index after the last element that may be contained in the run. It is required that @code{lo < hi}.\r\n     * @param c the comparator to used for the sort\r\n     * @return the length of the run beginning at the specified position in the specified array\r\n     */\r\n    countRunAndMakeAscending(lo, hi) {\r\n        let runHi = lo + 1;\r\n        if (runHi === hi) {\r\n            return 1;\r\n        }\r\n\r\n        // Find end of run, and reverse range if descending\r\n        // if (compare(a[runHi++], a[lo]) < 0) { // Descending\r\n        if (this.compare(runHi, lo, \"<\")) { // Descending\r\n            // while (runHi < hi && compare(a[runHi], a[runHi - 1]) < 0){\r\n            while (runHi < hi && this.compare(runHi, runHi - 1, \"<\")) {\r\n                runHi++;\r\n            }\r\n            this.reverseRange(lo, runHi);\r\n        } else { // Ascending\r\n            // while (runHi < hi && compare(a[runHi], a[runHi - 1]) >= 0){\r\n            while (runHi < hi && this.compare(runHi, runHi - 1, \">=\")) {\r\n                runHi++;\r\n            }\r\n        }\r\n\r\n        return runHi - lo;\r\n    }\r\n\r\n    /**\r\n     * Reverse the specified range of the specified array.\r\n     *\r\n     * @param a the array in which a range is to be reversed\r\n     * @param lo the index of the first element in the range to be reversed\r\n     * @param hi the index after the last element in the range to be reversed\r\n     */\r\n\r\n    /*private static void*/\r\n    reverseRange(/*Object[]*/  /*int*/ lo, /*int*/ hi) {\r\n        hi--;\r\n        while (lo < hi) {\r\n            // let t = a[lo];\r\n            // a[lo++] = a[hi];\r\n            // a[hi--] = t;\r\n            let t = this.read(lo);\r\n            this.write(lo++, hi);\r\n            this.write(hi--, t);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the minimum acceptable run length for an array of the specified length. Natural runs shorter than this will be\r\n     * extended with {@link #binarySort}.\r\n     *\r\n     * Roughly speaking, the computation is:\r\n     *\r\n     * If n < MIN_MERGE, return n (it's too small to bother with fancy stuff). Else if n is an exact power of 2, return\r\n     * MIN_MERGE/2. Else return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k is close to, but strictly less than, an\r\n     * exact power of 2.\r\n     *\r\n     * For the rationale, see listsort.txt.\r\n     *\r\n     * @param n the length of the array to be sorted\r\n     * @return the length of the minimum run to be merged\r\n     */\r\n\r\n    /*private static int*/\r\n    minRunLength(/*int*/ n) {\r\n        // //let v=0;\r\n        // let r = 0; // Becomes 1 if any 1 bits are shifted off\r\n        // /*while (n >= MIN_MERGE) { v++;\r\n        //     r |= (n & 1);\r\n        //     n >>= 1;\r\n        // }*/\r\n        // //console.log(\"minRunLength(\"+n+\") \"+v+\" vueltas, result=\"+(n+r));\r\n        // //return n + r;\r\n        // return n + 1;\r\n        let r = 0;\r\n\r\n        while (n >= this.MIN_MERGE) {\r\n            r |= (n & 1);\r\n            n >>= 1;\r\n        }\r\n\r\n        return n + r;\r\n    }\r\n\r\n    /**\r\n     * Pushes the specified run onto the pending-run stack.\r\n     *\r\n     * @param runBase index of the first element in the run\r\n     * @param runLen the number of elements in the run\r\n     */\r\n    pushRun(runBaseArg, runLenArg) {\r\n        //console.log(\"pushRun(\"+runBaseArg+\",\"+runLenArg+\")\");\r\n        //this.runBase[stackSize] = runBase;\r\n        //runBase.push(runBaseArg);\r\n        this.runBase[this.stackSize] = runBaseArg;\r\n\r\n        //this.runLen[stackSize] = runLen;\r\n        //runLen.push(runLenArg);\r\n        this.runLen[this.stackSize] = runLenArg;\r\n        this.stackSize++;\r\n    }\r\n\r\n    /**\r\n     * Examines the stack of runs waiting to be merged and merges adjacent runs until the stack invariants are reestablished:\r\n     *\r\n     * 1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1] 2. runLen[i - 2] > runLen[i - 1]\r\n     *\r\n     * This method is called each time a new run is pushed onto the stack, so the invariants are guaranteed to hold for i <\r\n     * stackSize upon entry to the method.\r\n     */\r\n    mergeCollapse() {\r\n        while (this.stackSize > 1) {\r\n            let n = this.stackSize - 2;\r\n            if (n > 0 && this.runLen[n - 1] <= this.runLen[n] + this.runLen[n + 1]) {\r\n                if (this.runLen[n - 1] < this.runLen[n + 1]) n--;\r\n                this.mergeAt(n);\r\n            } else if (this.runLen[n] <= this.runLen[n + 1]) {\r\n                this.mergeAt(n);\r\n            } else {\r\n                break; // Invariant is established\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merges all runs on the stack until only one remains. This method is called once, to complete the sort.\r\n     */\r\n    mergeForceCollapse() {\r\n        while (this.stackSize > 1) {\r\n            let n = this.stackSize - 2;\r\n            if (n > 0 && this.runLen[n - 1] < this.runLen[n + 1]) n--;\r\n            this.mergeAt(n);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Merges the two runs at stack indices i and i+1. Run i must be the penultimate or antepenultimate run on the stack. In other\r\n     * words, i must be equal to stackSize-2 or stackSize-3.\r\n     *\r\n     * @param i stack index of the first of the two runs to merge\r\n     */\r\n    mergeAt(i) {\r\n\r\n        let base1 = this.runBase[i];\r\n        let len1 = this.runLen[i];\r\n        let base2 = this.runBase[i + 1];\r\n        let len2 = this.runLen[i + 1];\r\n\r\n        /*\r\n        * Record the length of the combined runs; if i is the 3rd-last run now, also slide over the last run (which isn't involved\r\n        * in this merge). The current run (i+1) goes away in any case.\r\n        */\r\n        //let stackSize = runLen.length;\r\n        this.runLen[i] = len1 + len2;\r\n        if (i === this.stackSize - 3) {\r\n            this.runBase[i + 1] = this.runBase[i + 2];\r\n            this.runLen[i + 1] = this.runLen[i + 2];\r\n        }\r\n        this.stackSize--;\r\n\r\n        /*\r\n        * Find where the first element of run2 goes in run1. Prior elements in run1 can be ignored (because they're already in\r\n        * place).\r\n        */\r\n\r\n        // let k = this.gallopRight(global_a[base2], base1, len1, 0);\r\n        let k = this.gallopRight(this.read(base2), false,base1, len1, 0);\r\n        base1 += k;\r\n        len1 -= k;\r\n        if (len1 === 0) return;\r\n\r\n        /*\r\n        * Find where the last element of run1 goes in run2. Subsequent elements in run2 can be ignored (because they're already in\r\n        * place).\r\n        */\r\n        // len2 = gallopLeft(global_a[base1 + len1 - 1], global_a, base2, len2, len2 - 1, compare);\r\n        len2 = this.gallopLeft(this.read(base1 + len1 - 1), false,base2, len2, len2 - 1);\r\n\r\n        if (len2 === 0) return;\r\n\r\n        // Merge remaining runs, using tmp array with min(len1, len2) elements\r\n        if (len1 <= len2)\r\n            this.mergeLo(base1, len1, base2, len2);\r\n        else\r\n            this.mergeHi(base1, len1, base2, len2);\r\n    }\r\n\r\n\r\n    /**\r\n     * Locates the position at which to insert the specified key into the specified sorted range; if the range contains an element\r\n     * equal to key, returns the index of the leftmost equal element.\r\n     *\r\n     * @param key the key whose insertion point to search for\r\n     * @param a the array in which to search\r\n     * @param base the index of the first element in the range\r\n     * @param len the length of the range; must be > 0\r\n     * @param hint the index at which to begin the search, 0 <= hint < n. The closer hint is to the result, the faster this method\r\n     *           will run.\r\n     * @param c the comparator used to order the range, and to search\r\n     * @return the int k, 0 <= k <= n such that a[b + k - 1] < key <= a[b + k], pretending that a[b - 1] is minus infinity and a[b\r\n     *         + n] is infinity. In other words, key belongs at index b + k; or in other words, the first k elements of a should\r\n     *         precede key, and the last n - k should follow it.\r\n     */\r\n    gallopLeft(key, isAux, base, len, hint) {\r\n        let lastOfs = 0;\r\n        let ofs = 1;\r\n        if (!isAux) {\r\n            // if (compare(key, a[base + hint]) > 0) {\r\n            if (key > this.read(base + hint)) {\r\n                // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]\r\n                let maxOfs = len - hint;\r\n                // while (ofs < maxOfs && compare(key, a[base + hint + ofs]) > 0) {\r\n                while (ofs < maxOfs && key > this.read(base + hint + ofs)) {\r\n                    lastOfs = ofs;\r\n                    ofs = (ofs << 1) + 1;\r\n                    if (ofs <= 0) // int overflow\r\n                        ofs = maxOfs;\r\n                }\r\n                if (ofs > maxOfs) ofs = maxOfs;\r\n\r\n                // Make offsets relative to base\r\n                lastOfs += hint;\r\n                ofs += hint;\r\n            } else { // key <= a[base + hint]\r\n                // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]\r\n                let maxOfs = hint + 1;\r\n                // while (ofs < maxOfs && compare(key, a[base + hint - ofs]) <= 0) {\r\n                while (ofs < maxOfs && key <= this.read(base + hint - ofs)) {\r\n                    lastOfs = ofs;\r\n                    ofs = (ofs << 1) + 1;\r\n                    if (ofs <= 0) // int overflow\r\n                        ofs = maxOfs;\r\n                }\r\n                if (ofs > maxOfs) ofs = maxOfs;\r\n\r\n                // Make offsets relative to base\r\n                let tmp = lastOfs;\r\n                lastOfs = hint - ofs;\r\n                ofs = hint - tmp;\r\n            }\r\n\r\n            /*\r\n            * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere to the right of lastOfs but no farther right than ofs.\r\n            * Do a binary search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].\r\n            */\r\n            lastOfs++;\r\n            while (lastOfs < ofs) {\r\n                let m = lastOfs + ((ofs - lastOfs) >>> 1);\r\n\r\n                // if (compare(key, a[base + m]) > 0)\r\n                if (key > this.read(base + m))\r\n                    lastOfs = m + 1; // a[base + m] < key\r\n                else\r\n                    ofs = m; // key <= a[base + m]\r\n            }\r\n        } else {\r\n            // if (compare(key, a[base + hint]) > 0) {\r\n            if (key > this.auxRead(base + hint, 0)) {\r\n                // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]\r\n                let maxOfs = len - hint;\r\n                // while (ofs < maxOfs && compare(key, a[base + hint + ofs]) > 0) {\r\n                while (ofs < maxOfs && key > this.auxRead(base + hint + ofs, 0)) {\r\n                    lastOfs = ofs;\r\n                    ofs = (ofs << 1) + 1;\r\n                    if (ofs <= 0) // int overflow\r\n                        ofs = maxOfs;\r\n                }\r\n                if (ofs > maxOfs) ofs = maxOfs;\r\n\r\n                // Make offsets relative to base\r\n                lastOfs += hint;\r\n                ofs += hint;\r\n            } else { // key <= a[base + hint]\r\n                // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]\r\n                let maxOfs = hint + 1;\r\n                // while (ofs < maxOfs && compare(key, a[base + hint - ofs]) <= 0) {\r\n                while (ofs < maxOfs && key <= this.auxRead(base + hint - ofs, 0)) {\r\n                    lastOfs = ofs;\r\n                    ofs = (ofs << 1) + 1;\r\n                    if (ofs <= 0) // int overflow\r\n                        ofs = maxOfs;\r\n                }\r\n                if (ofs > maxOfs) ofs = maxOfs;\r\n\r\n                // Make offsets relative to base\r\n                let tmp = lastOfs;\r\n                lastOfs = hint - ofs;\r\n                ofs = hint - tmp;\r\n            }\r\n\r\n            /*\r\n            * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere to the right of lastOfs but no farther right than ofs.\r\n            * Do a binary search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].\r\n            */\r\n            lastOfs++;\r\n            while (lastOfs < ofs) {\r\n                let m = lastOfs + ((ofs - lastOfs) >>> 1);\r\n\r\n                // if (compare(key, a[base + m]) > 0)\r\n                if (key > this.auxRead(base + m, 0))\r\n                    lastOfs = m + 1; // a[base + m] < key\r\n                else\r\n                    ofs = m; // key <= a[base + m]\r\n            }\r\n        }\r\n        return ofs;\r\n    }\r\n\r\n    /**\r\n     * Like gallopLeft, except that if the range contains an element equal to key, gallopRight returns the index after the\r\n     * rightmost equal element.\r\n     *\r\n     * @param key the key whose insertion point to search for\r\n     * @param a the array [] in which to search\r\n     * @param base the index of the first element in the range\r\n     * @param len the length of the range; must be > 0\r\n     * @param hint the index at which to begin the search, 0 <= hint < n. The closer hint is to the result, the faster this method\r\n     *           will run.\r\n     * @param c the comparator used to order the range, and to search\r\n     * @return the int k, 0 <= k <= n such that a[b + k - 1] <= key < a[b + k]\r\n     */\r\n    gallopRight(key, isAux, base, len, hint) {\r\n        let ofs = 1;\r\n        let lastOfs = 0;\r\n        if (!isAux) {\r\n            // if (compare(key, a[base + hint]) < 0) {\r\n            if (key < this.read(base + hint)) {\r\n                // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]\r\n                let maxOfs = hint + 1;\r\n                // while (ofs < maxOfs && compare(key, a[base + hint - ofs]) < 0) {\r\n                while (ofs < maxOfs && key < this.read(base + hint - ofs)) {\r\n                    lastOfs = ofs;\r\n                    ofs = (ofs << 1) + 1;\r\n                    if (ofs <= 0) // int overflow\r\n                        ofs = maxOfs;\r\n                }\r\n                if (ofs > maxOfs) ofs = maxOfs;\r\n\r\n                // Make offsets relative to b\r\n                let tmp = lastOfs;\r\n                lastOfs = hint - ofs;\r\n                ofs = hint - tmp;\r\n            } else { // a[b + hint] <= key\r\n                // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]\r\n                let maxOfs = len - hint;\r\n                // while (ofs < maxOfs && compare(key, a[base + hint + ofs]) >= 0) {\r\n                while (ofs < maxOfs && key >= this.read(base + hint + ofs)) {\r\n                    lastOfs = ofs;\r\n                    ofs = (ofs << 1) + 1;\r\n                    if (ofs <= 0) // int overflow\r\n                        ofs = maxOfs;\r\n                }\r\n                if (ofs > maxOfs) ofs = maxOfs;\r\n\r\n                // Make offsets relative to b\r\n                lastOfs += hint;\r\n                ofs += hint;\r\n            }\r\n\r\n            /*\r\n            * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to the right of lastOfs but no farther right than ofs.\r\n            * Do a binary search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].\r\n            */\r\n            lastOfs++;\r\n            while (lastOfs < ofs) {\r\n                let m = lastOfs + ((ofs - lastOfs) >>> 1);\r\n\r\n                // if (compare(key, a[base + m]) < 0)\r\n                if (key < this.read(base + m))\r\n                    ofs = m; // key < a[b + m]\r\n                else\r\n                    lastOfs = m + 1; // a[b + m] <= key\r\n            }\r\n        } else {\r\n            // if (compare(key, a[base + hint]) < 0) {\r\n            if (key < this.auxRead(base + hint, 0)) {\r\n                // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]\r\n                let maxOfs = hint + 1;\r\n                // while (ofs < maxOfs && compare(key, a[base + hint - ofs]) < 0) {\r\n                while (ofs < maxOfs && key < this.auxRead(base + hint - ofs, 0)) {\r\n                    lastOfs = ofs;\r\n                    ofs = (ofs << 1) + 1;\r\n                    if (ofs <= 0) // int overflow\r\n                        ofs = maxOfs;\r\n                }\r\n                if (ofs > maxOfs) ofs = maxOfs;\r\n\r\n                // Make offsets relative to b\r\n                let tmp = lastOfs;\r\n                lastOfs = hint - ofs;\r\n                ofs = hint - tmp;\r\n            } else { // a[b + hint] <= key\r\n                // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]\r\n                let maxOfs = len - hint;\r\n                // while (ofs < maxOfs && compare(key, a[base + hint + ofs]) >= 0) {\r\n                while (ofs < maxOfs && key >= this.auxRead(base + hint + ofs, 0)) {\r\n                    lastOfs = ofs;\r\n                    ofs = (ofs << 1) + 1;\r\n                    if (ofs <= 0) // int overflow\r\n                        ofs = maxOfs;\r\n                }\r\n                if (ofs > maxOfs) ofs = maxOfs;\r\n\r\n                // Make offsets relative to b\r\n                lastOfs += hint;\r\n                ofs += hint;\r\n            }\r\n\r\n            /*\r\n            * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to the right of lastOfs but no farther right than ofs.\r\n            * Do a binary search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].\r\n            */\r\n            lastOfs++;\r\n            while (lastOfs < ofs) {\r\n                let m = lastOfs + ((ofs - lastOfs) >>> 1);\r\n\r\n                // if (compare(key, a[base + m]) < 0)\r\n                if (key < this.auxRead(base + m, 0))\r\n                    ofs = m; // key < a[b + m]\r\n                else\r\n                    lastOfs = m + 1; // a[b + m] <= key\r\n            }\r\n        }\r\n        return ofs;\r\n    }\r\n\r\n    /**\r\n     * Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than the first\r\n     * element of the second run (a[base1] > a[base2]), and the last element of the first run (a[base1 + length1-1]) must be greater\r\n     * than all elements of the second run.\r\n     *\r\n     * For performance, this method should be called only when length1 <= length2; its twin, mergeHi should be called if length1 >= length2.\r\n     * (Either method may be called if length1 == length2.)\r\n     *\r\n     * @param base1 index of first element in first run to be merged\r\n     * @param length1 length of first run to be merged (must be > 0)\r\n     * @param base2 index of first element in second run to be merged (must be aBase + aLen)\r\n     * @param length2 length of second run to be merged (must be > 0)\r\n     */\r\n    mergeLo(base1, length1, base2, length2) {\r\n\r\n        // Copy first run into temp array// For performance\r\n        // let tmp=a.slice(base1,base1+length1);\r\n\r\n        let tmp = this.createAuxArray(base1 + length1)\r\n\r\n        for (let i = 0; i < length1; i++) {\r\n            // tmp[i] = array[start1 + i];\r\n            this.auxWrite(i, this.read(base1+i), tmp);\r\n        }\r\n\r\n\r\n        let cursor1 = 0; // Indexes into tmp array\r\n        let cursor2 = base2; // Indexes int a\r\n        let dest = base1; // Indexes int a\r\n\r\n        // Move first element of second run and deal with degenerate cases\r\n        // a[dest++] = a[cursor2++];\r\n        this.write(dest++, this.read(cursor2++))\r\n        if (--length2 === 0) {\r\n            // arraycopy(tmp, cursor1, a, dest, length1);\r\n            for (let i = 0; i < length1; i++) {\r\n                // array[dest + i] = tmp[cursor1 + i];\r\n                this.write(dest + i, this.auxRead(cursor1 + i, tmp));\r\n            }\r\n            return;\r\n        }\r\n        if (length1 === 1) {\r\n            // arraycopy(a, cursor2, a, dest, length2);\r\n            // a[dest + length2] = tmp[cursor1]; // Last elt of run 1 to end of merge\r\n            // return;\r\n            for (let i = 0; i < length2; i++) {\r\n                // array[dest + i] = array[cursor2 + i];\r\n                this.write(dest + i, this.read(cursor2 + i));\r\n            }\r\n            // array[dest + length2] = tmp[cursor1];\r\n            this.write(dest + length2, this.auxRead(cursor1, tmp));\r\n            return;\r\n        }\r\n\r\n        // let c = compare;// Use local variable for performance\r\n\r\n        let minGallop = this.MIN_GALLOP; // \"    \" \"     \" \"\r\n        outer:\r\n            while (true) {\r\n                let count1 = 0; // Number of times in a row that first run won\r\n                let count2 = 0; // Number of times in a row that second run won\r\n\r\n                /*\r\n                * Do the straightforward thing until (if ever) one run starts winning consistently.\r\n                */\r\n                do {\r\n                    // if (compare(a[cursor2], tmp[cursor1]) < 0) {\r\n                    if (this.read(cursor2) < this.auxRead(cursor1, tmp)) {\r\n                        // a[dest++] = a[cursor2++];\r\n                        this.write(dest++, this.read(cursor2++))\r\n                        count2++;\r\n                        count1 = 0;\r\n                        if (--length2 === 0) break outer;\r\n                    } else {\r\n                        // a[dest++] = tmp[cursor1++];\r\n                        this.write(dest++, this.read(cursor1++))\r\n                        count1++;\r\n                        count2 = 0;\r\n                        if (--length1 === 1) break outer;\r\n                    }\r\n                } while ((count1 | count2) < minGallop);\r\n\r\n                /*\r\n                * One run is winning so consistently that galloping may be a huge win. So try that, and continue galloping until (if\r\n                * ever) neither run appears to be winning consistently anymore.\r\n                */\r\n                do {\r\n                    // count1 = this.gallopRight(a[cursor2], tmp, cursor1, length1, 0, c);\r\n                    count1 = this.gallopRight(this.read(cursor2), true, cursor1, length1, 0);\r\n                    if (count1 !== 0) {\r\n                        // arraycopy(tmp, cursor1, a, dest, count1);\r\n                        for (let i = 0; i < count1; i++) {\r\n                            this.write(dest + i, this.auxRead(cursor1 + i, tmp))\r\n                        }\r\n                        dest += count1;\r\n                        cursor1 += count1;\r\n                        length1 -= count1;\r\n                        if (length1 <= 1) // length1 == 1 || length1 == 0\r\n                            break outer;\r\n                    }\r\n                    // a[dest++] = a[cursor2++];\r\n                    this.write(dest++, this.read(cursor2++))\r\n                    if (--length2 === 0) break outer;\r\n                    //count2 = gallopLeft(tmp[cursor1], a, cursor2, len2, 0, c);\r\n                    count2 = this.gallopLeft(tmp[cursor1], false, cursor2, length2, 0);\r\n                    if (count2 !== 0) {\r\n                        // arraycopy(a, cursor2, a, dest, count2);\r\n                        for (let i = 0; i < count2; i++) {\r\n                            // array[dest + i] = array[cursor2 + i];\r\n                            this.write(dest + i, this.read(cursor2 + i))\r\n                        }\r\n                        dest += count2;\r\n                        cursor2 += count2;\r\n                        length2 -= count2;\r\n                        if (length2 === 0) break outer;\r\n                    }\r\n                    // a[dest++] = tmp[cursor1++];\r\n                    this.write(dest++, this.auxRead(cursor1++, tmp))\r\n                    if (--length1 === 1) break outer;\r\n                    minGallop--;\r\n                } while (count1 >= this.MIN_GALLOP || count2 >= this.MIN_GALLOP);\r\n                if (minGallop < 0) minGallop = 0;\r\n                minGallop += 2; // Penalize for leaving gallop mode\r\n            } // End of \"outer\" loop\r\n        this.minGallop = minGallop < 1 ? 1 : minGallop; // Write back to field\r\n\r\n        if (length1 === 1) {\r\n            // arraycopy(a, cursor2, a, dest, length2);\r\n            // a[dest + length2] = tmp[cursor1]; // Last elt of run 1 to end of merge\r\n            for (let i = 0; i < length2; i++) {\r\n                this.write(dest + i, this.read(cursor2 + i))\r\n            }\r\n            this.write(dest + length2, this.auxRead(cursor1, tmp))\r\n        } else if (length1 === 0) {\r\n            throw new Error(\"IllegalArgumentException. Comparison method violates its general contract!\");\r\n        } else {\r\n            // arraycopy(tmp, cursor1, a, dest, length1);\r\n            for (let i = 0; i < length1; i++) {\r\n                this.write(dest + i, this.auxRead(cursor1 + i, tmp))\r\n            }\r\n        }\r\n        this.removeAuxArray(tmp)\r\n    }\r\n\r\n\r\n    /**\r\n     * Like mergeLo, except that this method should be called only if len1 >= len2; mergeLo should be called if len1 <= len2.\r\n     * (Either method may be called if len1 == len2.)\r\n     *\r\n     * @param base1 index of first element in first run to be merged\r\n     * @param len1 length of first run to be merged (must be > 0)\r\n     * @param base2 index of first element in second run to be merged (must be aBase + aLen)\r\n     * @param len2 length of second run to be merged (must be > 0)\r\n     */\r\n    //WARN!!!\r\n    mergeHi(base1, len1, base2, len2) {\r\n\r\n        // Copy second run into temp array\r\n        // let a = global_a;// For performance\r\n        // let tmp = a.slice(base2, base2 + len2);\r\n\r\n        let tmp = this.createAuxArray(base2 + len2)\r\n\r\n        for (let i = 0; i < base2; i++) {\r\n            console.log(base2+1)\r\n            this.auxWrite(i, this.read(base2+i), tmp)\r\n        }\r\n\r\n\r\n        let cursor1 = base1 + len1 - 1; // Indexes into a\r\n        let cursor2 = len2 - 1; // Indexes into tmp array\r\n        let dest = base2 + len2 - 1; // Indexes into a\r\n\r\n        // Move last element of first run and deal with degenerate cases\r\n        // a[dest--] = a[cursor1--];\r\n        this.write(dest--, this.read(cursor1--))\r\n        if (--len1 === 0) {\r\n            // arraycopy(tmp, 0, a, dest - (len2 - 1), len2);\r\n\r\n            let customCursor = dest - (base2 - 1);\r\n\r\n            for (let i = 0; i < base2; i++) {\r\n                this.write(customCursor + i, this.auxRead(i, tmp));\r\n            }\r\n\r\n            return;\r\n        }\r\n        if (len2 === 1) {\r\n            dest -= len1;\r\n            cursor1 -= len1;\r\n            // arraycopy(a, cursor1 + 1, a, dest + 1, len1);\r\n            // a[dest] = tmp[cursor2];\r\n            let customDest = dest + 1;\r\n            let customCursor = cursor1 + 1;\r\n\r\n            for (let i = len1 - 1; i >= 0; i--) {\r\n                // array[customDest + i] = array[customCursor + i];\r\n                this.write(customDest + i, this.read(customCursor + i));\r\n            }\r\n\r\n            // array[dest] = tmp[cursor2];\r\n            this.write(dest, this.auxRead(cursor2, tmp));\r\n            return;\r\n        }\r\n\r\n\r\n        let minGallop = this.MIN_GALLOP; // \"    \" \"     \" \"\r\n        outer:\r\n            while (true) {\r\n                let count1 = 0; // Number of times in a row that first run won\r\n                let count2 = 0; // Number of times in a row that second run won\r\n\r\n                /*\r\n                * Do the straightforward thing until (if ever) one run appears to win consistently.\r\n                */\r\n                do {\r\n                    // if (compare(tmp[cursor2], a[cursor1]) < 0) {\r\n                    if (this.auxRead(cursor2, tmp) < this.read(cursor1)) {\r\n                        // a[dest--] = a[cursor1--];\r\n                        this.write(dest--, this.read(cursor1--));\r\n                        count1++;\r\n                        count2 = 0;\r\n                        if (--len1 === 0) break outer;\r\n                    } else {\r\n                        // a[dest--] = tmp[cursor2--];\r\n                        this.write(dest--, this.auxRead(cursor2--, tmp));\r\n                        count2++;\r\n                        count1 = 0;\r\n                        if (--len2 === 1) break outer;\r\n                    }\r\n                } while ((count1 | count2) < minGallop);\r\n\r\n                /*\r\n                * One run is winning so consistently that galloping may be a huge win. So try that, and continue galloping until (if\r\n                * ever) neither run appears to be winning consistently anymore.\r\n                */\r\n                do {\r\n                    // count1 = len1 - this.gallopRight(tmp[cursor2], a, base1, len1, len1 - 1, c);\r\n                    count1 = len1 - this.gallopRight(tmp[cursor2], false, base1, len1, len1 - 1);\r\n                    if (count1 !== 0) {\r\n                        dest -= count1;\r\n                        cursor1 -= count1;\r\n                        len1 -= count1;\r\n                        let customDest = dest + 1;\r\n                        let customCursor = cursor1 + 1;\r\n                        // arraycopy(a, cursor1 + 1, a, dest + 1, count1);\r\n                        for (let i = count1 - 1; i >= 0; i--) {\r\n                            this.write(customDest + i, this.read(customCursor + i));\r\n                        }\r\n\r\n                        if (len1 === 0) break outer;\r\n                    }\r\n                    // a[dest--] = tmp[cursor2--];\r\n                    this.write(dest--, this.auxRead(cursor2--, tmp));\r\n                    if (--len2 === 1) break outer;\r\n\r\n                    // count2 = len2 - gallopLeft(a[cursor1], tmp, 0, len2, len2 - 1, c);\r\n                    count2 = len2 - this.gallopLeft(this.read(cursor1), true, 0, len2, len2 - 1);\r\n                    if (count2 !== 0) {\r\n                        dest -= count2;\r\n                        cursor2 -= count2;\r\n                        len2 -= count2;\r\n                        let customDest = dest + 1;\r\n                        let customCursor = cursor2 + 1;\r\n                        // arraycopy(tmp, cursor2 + 1, a, dest + 1, count2);\r\n                        for (let i = 0; i < count2; i++) {\r\n                            this.write(customDest + i, this.auxRead(customCursor + i, tmp));\r\n                        }\r\n                        if (len2 <= 1) // len2 == 1 || len2 == 0\r\n                            break outer;\r\n                    }\r\n                    // a[dest--] = a[cursor1--];\r\n                    this.write(dest--, this.read(cursor1--));\r\n                    if (--len1 === 0) break outer;\r\n                    minGallop--;\r\n                } while (count1 >= this.MIN_GALLOP || count2 >= this.MIN_GALLOP);\r\n                if (minGallop < 0) minGallop = 0;\r\n                minGallop += 2; // Penalize for leaving gallop mode\r\n            } // End of \"outer\" loop\r\n        this.minGallop = minGallop < 1 ? 1 : minGallop; // Write back to field\r\n\r\n        if (len2 === 1) {\r\n            dest -= len1;\r\n            cursor1 -= len1;\r\n            // arraycopy(a, cursor1 + 1, a, dest + 1, len1);\r\n            // a[dest] = tmp[cursor2]; // Move first elt of run2 to front of merge\r\n\r\n            let customDest = dest + 1;\r\n            let customCursor = cursor1 + 1;\r\n\r\n            for (let i = len1 - 1; i >= 0; i--) {\r\n                // array[customDest + i] = array[customCursor + i];\r\n                this.write(customDest + i, this.read(customCursor + i));\r\n\r\n            }\r\n\r\n            // array[dest] = tmp[cursor2];\r\n            this.write(dest, this.auxRead(cursor2, tmp));\r\n\r\n        } else if (len2 === 0) {\r\n            throw new Error(\"IllegalArgumentException. Comparison method violates its general contract!\");\r\n        } else {\r\n            // arraycopy(tmp, 0, a, dest - (len2 - 1), len2);\r\n            let customCursor = dest - (len2 - 1);\r\n            for (let i = 0; i < len2; i++) {\r\n                // array[customCursor + i] = tmp[i];\r\n                this.write(customCursor + i, this.auxRead(i, tmp));\r\n            }\r\n        }\r\n        this.removeAuxArray(tmp)\r\n    }\r\n\r\n\r\n    /**\r\n     * Checks that fromIndex and toIndex are in range, and throws an appropriate exception if they aren't.\r\n     *\r\n     * @param arrayLen the length of the array\r\n     * @param fromIndex the index of the first element of the range\r\n     * @param toIndex the index after the last element of the range\r\n     * @throws IllegalArgumentException if fromIndex > toIndex\r\n     * @throws ArrayIndexOutOfBoundsException if fromIndex < 0 or toIndex > arrayLen\r\n     */\r\n    rangeCheck(arrayLen, fromIndex, toIndex) {\r\n        if (fromIndex > toIndex) throw new Error(\"IllegalArgument fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\r\n        if (fromIndex < 0) throw new Error(\"ArrayIndexOutOfBounds \" + fromIndex);\r\n        if (toIndex > arrayLen) throw new Error(\"ArrayIndexOutOfBounds \" + toIndex);\r\n    }\r\n}\r\n\r\n// java System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)\r\nfunction arraycopy(src, spos, dest, dpos, len) {\r\n    let a = src.slice(spos, spos + len);\r\n    while (len--) {\r\n        dest[dpos + len] = a[len];\r\n    }\r\n}\r\n","/**\r\n * Default minimum size of a run.\r\n */\r\nimport {Sort} from \"./Sort\";\r\n\r\nconst DEFAULT_MIN_MERGE = 32;\r\n\r\n/**\r\n * Minimum ordered subsequece required to do galloping.\r\n */\r\nconst DEFAULT_MIN_GALLOPING = 7;\r\n\r\n/**\r\n * Default tmp storage length. Can increase depending on the size of the\r\n * smallest run to merge.\r\n */\r\nconst DEFAULT_TMP_STORAGE_LENGTH = 256;\r\n\r\n/**\r\n * Pre-computed powers of 10 for efficient lexicographic comparison of\r\n * small integers.\r\n */\r\nconst POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9]\r\n\r\n/**\r\n * Estimate the logarithm base 10 of a small integer.\r\n *\r\n * @param {number} x - The integer to estimate the logarithm of.\r\n * @return {number} - The estimated logarithm of the integer.\r\n */\r\n\r\n\r\nexport class TimSort extends Sort{\r\n    // array = null;\r\n    // compare = null;\r\n    minGallop = DEFAULT_MIN_GALLOPING;\r\n    length;\r\n    tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\r\n    stackLength = 0;\r\n    runStart = null;\r\n    runLength = null;\r\n    stackSize = 0;\r\n\r\n    constructor(arrayVisualizer) {\r\n        super(arrayVisualizer);\r\n\r\n        this.length = this.arrLength;\r\n\r\n        if (this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\r\n            this.tmpStorageLength = this.length >>> 1;\r\n        }\r\n        // this.tmp = new Array(this.tmpStorageLength);\r\n        this.tmp = this.createAuxArray(this.tmpStorageLength);\r\n        // this.tmp = this.createAuxArray(256);\r\n\r\n\r\n        this.stackLength =\r\n            (this.length < 120 ? 5 :\r\n                this.length < 1542 ? 10 :\r\n                    this.length < 119151 ? 19 : 40);\r\n\r\n        this.runStart = new Array(this.stackLength);\r\n        this.runLength = new Array(this.stackLength);\r\n    }\r\n\r\n    log10(x) {\r\n        if (x < 1e5) {\r\n            if (x < 1e2) {\r\n                return x < 1e1 ? 0 : 1;\r\n            }\r\n\r\n            if (x < 1e4) {\r\n                return x < 1e3 ? 2 : 3;\r\n            }\r\n\r\n            return 4;\r\n        }\r\n\r\n        if (x < 1e7) {\r\n            return x < 1e6 ? 5 : 6;\r\n        }\r\n\r\n        if (x < 1e9) {\r\n            return x < 1e8 ? 7 : 8;\r\n        }\r\n\r\n        return 9;\r\n    }\r\n\r\n    /**\r\n     * Default alphabetical comparison of items.\r\n     *\r\n     * @param {string|object|number} a - First element to compare.\r\n     * @param {string|object|number} b - Second element to compare.\r\n     * @return {number} - A positive number if a.toString() > b.toString(), a\r\n     * negative number if .toString() < b.toString(), 0 otherwise.\r\n     */\r\n    alphabeticalCompare(a, b) {\r\n        if (a === b) {\r\n            return 0;\r\n        }\r\n\r\n        if (~~a === a && ~~b === b) {\r\n            if (a === 0 || b === 0) {\r\n                return a < b ? -1 : 1;\r\n            }\r\n\r\n            if (a < 0 || b < 0) {\r\n                if (b >= 0) {\r\n                    return -1;\r\n                }\r\n\r\n                if (a >= 0) {\r\n                    return 1;\r\n                }\r\n\r\n                a = -a;\r\n                b = -b;\r\n            }\r\n\r\n            const al = this.log10(a);\r\n            const bl = this.log10(b);\r\n\r\n            let t = 0;\r\n\r\n            if (al < bl) {\r\n                a *= POWERS_OF_TEN[bl - al - 1];\r\n                b /= 10;\r\n                t = -1;\r\n            } else if (al > bl) {\r\n                b *= POWERS_OF_TEN[al - bl - 1];\r\n                a /= 10;\r\n                t = 1;\r\n            }\r\n\r\n            if (a === b) {\r\n                return t;\r\n            }\r\n\r\n            return a < b ? -1 : 1;\r\n        }\r\n\r\n        let aStr = String(a);\r\n        let bStr = String(b);\r\n\r\n        if (aStr === bStr) {\r\n            return 0;\r\n        }\r\n\r\n        return aStr < bStr ? -1 : 1;\r\n    }\r\n\r\n    /**\r\n     * Compute minimum run length for TimSort\r\n     *\r\n     * @param {number} n - The size of the array to sort.\r\n     */\r\n    minRunLength(n) {\r\n        let r = 0;\r\n\r\n        while (n >= DEFAULT_MIN_MERGE) {\r\n            r |= (n & 1);\r\n            n >>= 1;\r\n        }\r\n\r\n        return n + r;\r\n    }\r\n\r\n    /**\r\n     * Counts the length of a monotonically ascending or strictly monotonically\r\n     * descending sequence (run) starting at array[lo] in the range [lo, hi). If\r\n     * the run is descending it is made ascending.\r\n     *\r\n     * @param {array} array - The array to reverse.\r\n     * @param {number} lo - First element in the range (inclusive).\r\n     * @param {number} hi - Last element in the range.\r\n     * @param {function} compare - Item comparison function.\r\n     * @return {number} - The length of the run.\r\n     */\r\n    makeAscendingRun(lo, hi) {\r\n        let runHi = lo + 1;\r\n\r\n        if (runHi === hi) {\r\n            return 1;\r\n        }\r\n\r\n        // Descending\r\n        // if (compare(array[runHi++], array[lo]) < 0) {\r\n        if (this.compare(runHi++, lo, \"<\")) {\r\n            // while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\r\n            while (runHi < hi && this.compare(runHi, runHi - 1, \"<\")) {\r\n                runHi++;\r\n            }\r\n\r\n            this.reverseRun(lo, runHi);\r\n            // Ascending\r\n        } else {\r\n            // while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\r\n            while (runHi < hi && this.compare(runHi, runHi - 1, \">=\")) {\r\n                runHi++;\r\n            }\r\n        }\r\n\r\n        return runHi - lo;\r\n    }\r\n\r\n    /**\r\n     * Reverse an array in the range [lo, hi).\r\n     *\r\n     * @param {array} array - The array to reverse.\r\n     * @param {number} lo - First element in the range (inclusive).\r\n     * @param {number} hi - Last element in the range.\r\n     */\r\n    reverseRun(lo, hi) {\r\n        hi--;\r\n\r\n        while (lo < hi) {\r\n            // let t = array[lo];\r\n            let t = this.read(lo);\r\n            // array[lo++] = array[hi];\r\n            this.write(lo++, this.read(hi));\r\n            // array[hi--] = t;\r\n            this.write(hi--, t);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Perform the binary sort of the array in the range [lo, hi) where start is\r\n     * the first element possibly out of order.\r\n     *\r\n     * @param {array} array - The array to sort.\r\n     * @param {number} lo - First element in the range (inclusive).\r\n     * @param {number} hi - Last element in the range.\r\n     * @param {number} start - First element possibly out of order.\r\n     * @param {function} compare - Item comparison function.\r\n     */\r\n    binaryInsertionSort( lo, hi, start) {\r\n        if (start === lo) {\r\n            start++;\r\n        }\r\n\r\n        for (; start < hi; start++) {\r\n            // let pivot = array[start];\r\n            let pivot = this.read(start);\r\n\r\n            // Ranges of the array where pivot belongs\r\n            let left = lo;\r\n            let right = start;\r\n\r\n            /*\r\n             *   pivot >= array[i] for i in [lo, left)\r\n             *   pivot <  array[i] for i in  in [right, start)\r\n             */\r\n            while (left < right) {\r\n                let mid = (left + right) >>> 1;\r\n\r\n                // if (compare(pivot, array[mid]) < 0) {\r\n                if (pivot < this.read(mid) < 0) {\r\n                    right = mid;\r\n                } else {\r\n                    left = mid + 1;\r\n                }\r\n            }\r\n\r\n            /*\r\n             * Move elements right to make room for the pivot. If there are elements\r\n             * equal to pivot, left points to the first slot after them: this is also\r\n             * a reason for which TimSort is stable\r\n             */\r\n            let n = start - left;\r\n            // Switch is just an optimization for small arrays\r\n            switch (n) {\r\n                case 3:\r\n                    // array[left + 3] = array[left + 2];\r\n                    this.write(left+3, this.read(left+2));\r\n                /* falls through */\r\n                case 2:\r\n                    // array[left + 2] = array[left + 1];\r\n                    this.write(left+2, this.read(left+1));\r\n                /* falls through */\r\n                case 1:\r\n                    // array[left + 1] = array[left];\r\n                    this.write(left+1, this.read(left));\r\n                    break;\r\n                default:\r\n                    while (n > 0) {\r\n                        // array[left + n] = array[left + n - 1];\r\n                        this.write(left+n, this.read(left+n-1));\r\n                        n--;\r\n                    }\r\n            }\r\n\r\n            // array[left] = pivot;\r\n            this.write(left, pivot)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find the position at which to insert a value in a sorted range. If the range\r\n     * contains elements equal to the value the leftmost element index is returned\r\n     * (for stability).\r\n     *\r\n     * @param {number} value - Value to insert.\r\n     * @param {array} array - The array in which to insert value.\r\n     * @param {number} start - First element in the range.\r\n     * @param {number} length - Length of the range.\r\n     * @param {number} hint - The index at which to begin the search.\r\n     * @param {function} compare - Item comparison function.\r\n     * @return {number} - The index where to insert value.\r\n     */\r\n    gallopLeft(value, isAux, start, length, hint) {\r\n        let lastOffset = 0;\r\n        let maxOffset = 0;\r\n        let offset = 1;\r\n        if (!isAux) {\r\n            // if (compare(value, array[start + hint]) > 0) {\r\n            if (value > this.read(start + hint)) {\r\n                maxOffset = length - hint;\r\n\r\n                // while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\r\n                while (offset < maxOffset && value > this.read(start + hint + offset)) {\r\n                    lastOffset = offset;\r\n                    offset = (offset << 1) + 1;\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset;\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset;\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint;\r\n                offset += hint;\r\n\r\n                // value <= array[start + hint]\r\n            } else {\r\n                maxOffset = hint + 1;\r\n                // while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\r\n                while (offset < maxOffset && value <= this.read(start + hint - offset)) {\r\n                    lastOffset = offset;\r\n                    offset = (offset << 1) + 1;\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset;\r\n                    }\r\n                }\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset;\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                let tmp = lastOffset;\r\n                lastOffset = hint - offset;\r\n                offset = hint - tmp;\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++;\r\n            while (lastOffset < offset) {\r\n                let m = lastOffset + ((offset - lastOffset) >>> 1);\r\n\r\n                // if (compare(value, array[start + m]) > 0) {\r\n                if (value > this.read(start + m)) {\r\n                    lastOffset = m + 1;\r\n\r\n                } else {\r\n                    offset = m;\r\n                }\r\n            }\r\n            return offset;\r\n        }else{\r\n            // if (compare(value, array[start + hint]) > 0) {\r\n            if (value > this.auxRead(start + hint, 0)) {\r\n                maxOffset = length - hint;\r\n\r\n                // while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\r\n                while (offset < maxOffset && value > this.auxRead(start + hint + offset, 0)) {\r\n                    lastOffset = offset;\r\n                    offset = (offset << 1) + 1;\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset;\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset;\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint;\r\n                offset += hint;\r\n\r\n                // value <= array[start + hint]\r\n            } else {\r\n                maxOffset = hint + 1;\r\n                // while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\r\n                while (offset < maxOffset && value <= this.auxRead(start + hint - offset, 0)) {\r\n                    lastOffset = offset;\r\n                    offset = (offset << 1) + 1;\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset;\r\n                    }\r\n                }\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset;\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                let tmp = lastOffset;\r\n                lastOffset = hint - offset;\r\n                offset = hint - tmp;\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++;\r\n            while (lastOffset < offset) {\r\n                let m = lastOffset + ((offset - lastOffset) >>> 1);\r\n\r\n                // if (compare(value, array[start + m]) > 0) {\r\n                if (value > this.auxRead(start + m, 0)) {\r\n                    lastOffset = m + 1;\r\n\r\n                } else {\r\n                    offset = m;\r\n                }\r\n            }\r\n        }\r\n        return offset;\r\n    }\r\n    /**\r\n     * Find the position at which to insert a value in a sorted range. If the range\r\n     * contains elements equal to the value the rightmost element index is returned\r\n     * (for stability).\r\n     *\r\n     * @param {number} value - Value to insert.\r\n     * @param {array} array - The array in which to insert value.\r\n     * @param {number} start - First element in the range.\r\n     * @param {number} length - Length of the range.\r\n     * @param {number} hint - The index at which to begin the search.\r\n     * @param {function} compare - Item comparison function.\r\n     * @return {number} - The index where to insert value.\r\n     */\r\n    gallopRight(value,isAux, start, length, hint) {\r\n        let lastOffset = 0;\r\n        let maxOffset = 0;\r\n        let offset = 1;\r\n        if(!isAux) {\r\n            if (value < this.read(start + hint)) {\r\n                maxOffset = hint + 1;\r\n\r\n                // while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\r\n                while (offset < maxOffset && value < this.read(start + hint - offset)) {\r\n                    lastOffset = offset;\r\n                    offset = (offset << 1) + 1;\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset;\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset;\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                let tmp = lastOffset;\r\n                lastOffset = hint - offset;\r\n                offset = hint - tmp;\r\n\r\n                // value >= array[start + hint]\r\n            } else {\r\n                maxOffset = length - hint;\r\n\r\n                // while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\r\n                while (offset < maxOffset && value >= this.read(start + hint + offset)) {\r\n                    lastOffset = offset;\r\n                    offset = (offset << 1) + 1;\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset;\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset;\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint;\r\n                offset += hint;\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++;\r\n\r\n            while (lastOffset < offset) {\r\n                let m = lastOffset + ((offset - lastOffset) >>> 1);\r\n\r\n                // if (compare(value, array[start + m]) < 0) {\r\n                if (value < this.read(start + m)) {\r\n                    offset = m;\r\n\r\n                } else {\r\n                    lastOffset = m + 1;\r\n                }\r\n            }\r\n        }else{\r\n            if (value < this.auxRead(start + hint, 0)) {\r\n                maxOffset = hint + 1;\r\n\r\n                // while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\r\n                while (offset < maxOffset && value < this.auxRead(start + hint - offset, 0)) {\r\n                    lastOffset = offset;\r\n                    offset = (offset << 1) + 1;\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset;\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset;\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                let tmp = lastOffset;\r\n                lastOffset = hint - offset;\r\n                offset = hint - tmp;\r\n\r\n                // value >= array[start + hint]\r\n            } else {\r\n                //if AUX\r\n                maxOffset = length - hint;\r\n\r\n                // while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\r\n                while (offset < maxOffset && value >= this.auxRead(start + hint + offset, 0)) {\r\n                    lastOffset = offset;\r\n                    offset = (offset << 1) + 1;\r\n\r\n                    if (offset <= 0) {\r\n                        offset = maxOffset;\r\n                    }\r\n                }\r\n\r\n                if (offset > maxOffset) {\r\n                    offset = maxOffset;\r\n                }\r\n\r\n                // Make offsets relative to start\r\n                lastOffset += hint;\r\n                offset += hint;\r\n            }\r\n\r\n            /*\r\n             * Now array[start+lastOffset] < value <= array[start+offset], so value\r\n             * belongs somewhere in the range (start + lastOffset, start + offset]. Do a\r\n             * binary search, with invariant array[start + lastOffset - 1] < value <=\r\n             * array[start + offset].\r\n             */\r\n            lastOffset++;\r\n\r\n            while (lastOffset < offset) {\r\n                let m = lastOffset + ((offset - lastOffset) >>> 1);\r\n\r\n                // if (compare(value, array[start + m]) < 0) {\r\n                if (value < this.auxRead(start + m, 0)) {\r\n                    offset = m;\r\n\r\n                } else {\r\n                    lastOffset = m + 1;\r\n                }\r\n            }\r\n        }\r\n        return offset;\r\n    }\r\n\r\n    /**\r\n     * Push a new run on TimSort's stack.\r\n     *\r\n     * @param {number} runStart - Start index of the run in the original array.\r\n     * @param {number} runLength - Length of the run;\r\n     */\r\n    pushRun(runStart, runLength) {\r\n        this.runStart[this.stackSize] = runStart;\r\n        this.runLength[this.stackSize] = runLength;\r\n        this.stackSize += 1;\r\n    }\r\n\r\n    /**\r\n     * Merge runs on TimSort's stack so that the following holds for all i:\r\n     * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]\r\n     * 2) runLength[i - 2] > runLength[i - 1]\r\n     */\r\n    mergeRuns() {\r\n        while (this.stackSize > 1) {\r\n            let n = this.stackSize - 2;\r\n\r\n            if ((n >= 1 &&\r\n                this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1]) ||\r\n                (n >= 2 &&\r\n                    this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1])) {\r\n\r\n                if (this.runLength[n - 1] < this.runLength[n + 1]) {\r\n                    n--;\r\n                }\r\n\r\n            } else if (this.runLength[n] > this.runLength[n + 1]) {\r\n                break;\r\n            }\r\n            this.mergeAt(n);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge all runs on TimSort's stack until only one remains.\r\n     */\r\n    forceMergeRuns() {\r\n        while (this.stackSize > 1) {\r\n            let n = this.stackSize - 2;\r\n\r\n            if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {\r\n                n--;\r\n            }\r\n\r\n            this.mergeAt(n);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge the runs on the stack at positions i and i+1. Must be always be called\r\n     * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).\r\n     *\r\n     * @param {number} i - Index of the run to merge in TimSort's stack.\r\n     */\r\n    mergeAt(i) {\r\n        let start1 = this.runStart[i];\r\n        let length1 = this.runLength[i];\r\n        let start2 = this.runStart[i + 1];\r\n        let length2 = this.runLength[i + 1];\r\n\r\n        this.runLength[i] = length1 + length2;\r\n\r\n        if (i === this.stackSize - 3) {\r\n            this.runStart[i + 1] = this.runStart[i + 2];\r\n            this.runLength[i + 1] = this.runLength[i + 2];\r\n        }\r\n\r\n        this.stackSize--;\r\n\r\n        /*\r\n         * Find where the first element in the second run goes in run1. Previous\r\n         * elements in run1 are already in place\r\n         */\r\n\r\n        // let k = gallopRight(array[start2], array, start1, length1, 0, compare);\r\n        let k = this.gallopRight(this.read(start2), false, start1, length1, 0);\r\n        start1 += k;\r\n        length1 -= k;\r\n\r\n        if (length1 === 0) {\r\n            return;\r\n        }\r\n\r\n        /*\r\n         * Find where the last element in the first run goes in run2. Next elements\r\n         * in run2 are already in place\r\n         */\r\n\r\n        // length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\r\n        length2 = this.gallopLeft(this.read(start1 + length1 - 1), false, start2, length2, length2 - 1);\r\n\r\n        if (length2 === 0) {\r\n            return;\r\n        }\r\n\r\n        /*\r\n         * Merge remaining runs. A tmp array with length = min(length1, length2) is\r\n         * used\r\n         */\r\n        if (length1 <= length2) {\r\n            this.mergeLow(start1, length1, start2, length2);\r\n\r\n        } else {\r\n            this.mergeHigh(start1, length1, start2, length2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge two adjacent runs in a stable way. The runs must be such that the\r\n     * first element of run1 is bigger than the first element in run2 and the\r\n     * last element of run1 is greater than all the elements in run2.\r\n     * The method should be called when run1.length <= run2.length as it uses\r\n     * TimSort temporary array to store run1. Use mergeHigh if run1.length >\r\n     * run2.length.\r\n     *\r\n     * @param {number} start1 - First element in run1.\r\n     * @param {number} length1 - Length of run1.\r\n     * @param {number} start2 - First element in run2.\r\n     * @param {number} length2 - Length of run2.\r\n     */\r\n    mergeLow(start1, length1, start2, length2) {\r\n\r\n        let tmp = this.tmp;\r\n        let i = 0;\r\n\r\n        for (i = 0; i < length1; i++) {\r\n            // tmp[i] = array[start1 + i];\r\n            this.auxWrite(i, this.read(start1+i), tmp);\r\n        }\r\n\r\n        let cursor1 = 0;\r\n        let cursor2 = start2;\r\n        let dest = start1;\r\n\r\n        // array[dest++] = array[cursor2++];\r\n        this.write(dest, this.read(cursor2++));\r\n\r\n        if (--length2 === 0) {\r\n            for (i = 0; i < length1; i++) {\r\n                // array[dest + i] = tmp[cursor1 + i];\r\n                this.write(dest+i, this.auxRead(cursor1+i, tmp));\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (length1 === 1) {\r\n            for (i = 0; i < length2; i++) {\r\n                // array[dest + i] = array[cursor2 + i];\r\n                this.write(dest+i, this.read(cursor2+i));\r\n            }\r\n            // array[dest + length2] = tmp[cursor1];\r\n            this.write(dest+length2, this.auxRead(cursor1, tmp));\r\n            return;\r\n        }\r\n\r\n        let minGallop = this.minGallop;\r\n\r\n        while (true) {\r\n            let count1 = 0;\r\n            let count2 = 0;\r\n            let exit = false;\r\n\r\n            do {\r\n                // if (compare(array[cursor2], tmp[cursor1]) < 0) {\r\n                if (this.read(cursor2) < this.auxRead(cursor1, tmp)) {\r\n                    // array[dest++] = array[cursor2++];\r\n                    this.write(dest++, this.read(cursor2++));\r\n                    count2++;\r\n                    count1 = 0;\r\n\r\n                    if (--length2 === 0) {\r\n                        exit = true;\r\n                        break;\r\n                    }\r\n\r\n                } else {\r\n                    // array[dest++] = tmp[cursor1++];\r\n                    this.write(dest++, this.auxRead(cursor1++, tmp));\r\n                    count1++;\r\n                    count2 = 0;\r\n                    if (--length1 === 1) {\r\n                        exit = true;\r\n                        break;\r\n                    }\r\n                }\r\n            } while ((count1 | count2) < minGallop);\r\n\r\n            if (exit) {\r\n                break;\r\n            }\r\n\r\n            do {\r\n                // count1 = this.gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\r\n                count1 = this.gallopRight(this.read(cursor2), true, cursor1, length1, 0);\r\n\r\n                if (count1 !== 0) {\r\n                    for (i = 0; i < count1; i++) {\r\n                        // array[dest + i] = tmp[cursor1 + i];\r\n                        this.write(dest+i, this.auxRead(cursor1+i, tmp))\r\n                    }\r\n\r\n                    dest += count1;\r\n                    cursor1 += count1;\r\n                    length1 -= count1;\r\n                    if (length1 <= 1) {\r\n                        exit = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // array[dest++] = array[cursor2++];\r\n                this.write(dest++, this.read(cursor2++))\r\n\r\n                if (--length2 === 0) {\r\n                    exit = true;\r\n                    break;\r\n                }\r\n\r\n                // count2 = this.gallopLeft(tmp[cursor1], array, cursor2, length2, 0);\r\n                count2 = this.gallopLeft(this.auxRead(cursor1, tmp), false, cursor2, length2, 0);\r\n\r\n                if (count2 !== 0) {\r\n                    for (i = 0; i < count2; i++) {\r\n                        // array[dest + i] = array[cursor2 + i];\r\n                        this.write(dest+i, this.read(cursor2+i))\r\n                    }\r\n\r\n                    dest += count2;\r\n                    cursor2 += count2;\r\n                    length2 -= count2;\r\n\r\n                    if (length2 === 0) {\r\n                        exit = true;\r\n                        break;\r\n                    }\r\n                }\r\n                // array[dest++] = tmp[cursor1++];\r\n                this.write(dest++, this.auxRead(cursor1++, tmp))\r\n\r\n                if (--length1 === 1) {\r\n                    exit = true;\r\n                    break;\r\n                }\r\n\r\n                minGallop--;\r\n\r\n            } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\r\n\r\n            if (exit) {\r\n                break;\r\n            }\r\n\r\n            if (minGallop < 0) {\r\n                minGallop = 0;\r\n            }\r\n\r\n            minGallop += 2;\r\n        }\r\n\r\n        this.minGallop = minGallop;\r\n\r\n        if (minGallop < 1) {\r\n            this.minGallop = 1;\r\n        }\r\n\r\n        if (length1 === 1) {\r\n            for (i = 0; i < length2; i++) {\r\n                // array[dest + i] = array[cursor2 + i];\r\n                this.write(dest+i, this.read(cursor2+i))\r\n            }\r\n            // array[dest + length2] = tmp[cursor1];\r\n            this.write(dest + length2, this.auxRead(cursor1, tmp))\r\n\r\n\r\n        } else if (length1 === 0) {\r\n            throw new Error('mergeLow preconditions were not respected');\r\n\r\n        } else {\r\n            for (i = 0; i < length1; i++) {\r\n                // array[dest + i] = tmp[cursor1 + i];\r\n                this.write(dest+i, this.auxRead(cursor1+i, tmp))\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Merge two adjacent runs in a stable way. The runs must be such that the\r\n     * first element of run1 is bigger than the first element in run2 and the\r\n     * last element of run1 is greater than all the elements in run2.\r\n     * The method should be called when run1.length > run2.length as it uses\r\n     * TimSort temporary array to store run2. Use mergeLow if run1.length <=\r\n     * run2.length.\r\n     *\r\n     * @param {number} start1 - First element in run1.\r\n     * @param {number} length1 - Length of run1.\r\n     * @param {number} start2 - First element in run2.\r\n     * @param {number} length2 - Length of run2.\r\n     */\r\n    mergeHigh(start1, length1, start2, length2) {\r\n        let tmp = this.tmp;\r\n        let i = 0;\r\n\r\n        for (i = 0; i < length2; i++) {\r\n            // tmp[i] = array[start2 + i];\r\n            console.log(start2+i)\r\n            this.auxWrite(i, this.read(start2+i), tmp)\r\n        }\r\n\r\n        let cursor1 = start1 + length1 - 1;\r\n        let cursor2 = length2 - 1;\r\n        let dest = start2 + length2 - 1;\r\n        let customCursor = 0;\r\n        let customDest = 0;\r\n\r\n        // array[dest--] = array[cursor1--];\r\n        this.write(dest--, this.read(cursor1--))\r\n\r\n        if (--length1 === 0) {\r\n            customCursor = dest - (length2 - 1);\r\n\r\n            for (i = 0; i < length2; i++) {\r\n                // array[customCursor + i] = tmp[i];\r\n                this.write(customCursor + i, this.auxRead(i, tmp));\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (length2 === 1) {\r\n            dest -= length1;\r\n            cursor1 -= length1;\r\n            customDest = dest + 1;\r\n            customCursor = cursor1 + 1;\r\n\r\n            for (i = length1 - 1; i >= 0; i--) {\r\n                // array[customDest + i] = array[customCursor + i];\r\n                this.write(customDest + i, this.read(customCursor + i));\r\n            }\r\n\r\n            // array[dest] = tmp[cursor2];\r\n            this.write(dest, this.auxRead(cursor2, tmp));\r\n            return;\r\n        }\r\n\r\n        let minGallop = this.minGallop;\r\n\r\n        while (true) {\r\n            let count1 = 0;\r\n            let count2 = 0;\r\n            let exit = false;\r\n\r\n            do {\r\n                // if (compare(tmp[cursor2], array[cursor1]) < 0) {\r\n                if (this.auxRead(cursor2, tmp) < this.read(cursor1)) {\r\n                    // array[dest--] = array[cursor1--];\r\n                    this.write(dest--, this.read(cursor1--));\r\n                    count1++;\r\n                    count2 = 0;\r\n                    if (--length1 === 0) {\r\n                        exit = true;\r\n                        break;\r\n                    }\r\n\r\n                } else {\r\n                    // array[dest--] = tmp[cursor2--];\r\n                    this.write(dest--, this.auxRead(cursor2--, tmp));\r\n                    count2++;\r\n                    count1 = 0;\r\n                    if (--length2 === 1) {\r\n                        exit = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n            } while ((count1 | count2) < minGallop);\r\n\r\n            if (exit) {\r\n                break;\r\n            }\r\n\r\n            do {\r\n                // count1 = length1 - this.gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\r\n                count1 = length1 - this.gallopRight(this.auxRead(cursor2, tmp), false, start1, length1, length1 - 1);\r\n\r\n                if (count1 !== 0) {\r\n                    dest -= count1;\r\n                    cursor1 -= count1;\r\n                    length1 -= count1;\r\n                    customDest = dest + 1;\r\n                    customCursor = cursor1 + 1;\r\n\r\n                    for (i = count1 - 1; i >= 0; i--) {\r\n                        // array[customDest + i] = array[customCursor + i];\r\n                        this.write(customDest + i, this.read(customCursor + i));\r\n                    }\r\n\r\n                    if (length1 === 0) {\r\n                        exit = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // array[dest--] = tmp[cursor2--];\r\n                this.write(dest--, this.auxRead(cursor2--, tmp));\r\n\r\n                if (--length2 === 1) {\r\n                    exit = true;\r\n                    break;\r\n                }\r\n\r\n                // count2 = length2 - this.gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\r\n                count2 = length2 - this.gallopLeft(this.read(cursor1), true, 0, length2, length2 - 1);\r\n\r\n                if (count2 !== 0) {\r\n                    dest -= count2;\r\n                    cursor2 -= count2;\r\n                    length2 -= count2;\r\n                    customDest = dest + 1;\r\n                    customCursor = cursor2 + 1;\r\n\r\n                    for (i = 0; i < count2; i++) {\r\n                        // array[customDest + i] = tmp[customCursor + i];\r\n                        this.write(customDest + i, this.auxRead(customCursor + i, tmp));\r\n                    }\r\n\r\n                    if (length2 <= 1) {\r\n                        exit = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // array[dest--] = array[cursor1--];\r\n                this.write(dest--, this.read(cursor1--));\r\n\r\n                if (--length1 === 0) {\r\n                    exit = true;\r\n                    break;\r\n                }\r\n\r\n                minGallop--;\r\n\r\n            } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\r\n\r\n            if (exit) {\r\n                break;\r\n            }\r\n\r\n            if (minGallop < 0) {\r\n                minGallop = 0;\r\n            }\r\n\r\n            minGallop += 2;\r\n        }\r\n\r\n        this.minGallop = minGallop;\r\n\r\n        if (minGallop < 1) {\r\n            this.minGallop = 1;\r\n        }\r\n\r\n        if (length2 === 1) {\r\n            dest -= length1;\r\n            cursor1 -= length1;\r\n            customDest = dest + 1;\r\n            customCursor = cursor1 + 1;\r\n\r\n            for (i = length1 - 1; i >= 0; i--) {\r\n                // array[customDest + i] = array[customCursor + i];\r\n                this.write(customDest + i, this.read(customCursor + i));\r\n\r\n            }\r\n\r\n            // array[dest] = tmp[cursor2];\r\n            this.write(dest, this.auxRead(cursor2, tmp));\r\n\r\n        } else if (length2 === 0) {\r\n            throw new Error('mergeHigh preconditions were not respected');\r\n\r\n        } else {\r\n            customCursor = dest - (length2 - 1);\r\n            for (i = 0; i < length2; i++) {\r\n                // array[customCursor + i] = tmp[i];\r\n                this.write(customCursor + i, this.auxRead(i, tmp));\r\n            }\r\n        }\r\n    }\r\n    runSort(low, high, bucketsNum) {\r\n\r\n        let remaining = high - low;\r\n\r\n        // The array is already sorted\r\n        if (remaining < 2) {\r\n            return;\r\n        }\r\n\r\n        let runLength = 0;\r\n        // On small arrays binary sort can be used directly\r\n        if (remaining < DEFAULT_MIN_MERGE) {\r\n            runLength = this.makeAscendingRun(low, high);\r\n            this.binaryInsertionSort(low, high, low + runLength);\r\n            return;\r\n        }\r\n\r\n\r\n        let minRun = this.minRunLength(remaining);\r\n\r\n        do {\r\n            runLength = this.makeAscendingRun(low, high);\r\n            if (runLength < minRun) {\r\n                let force = remaining;\r\n                if (force > minRun) {\r\n                    force = minRun;\r\n                }\r\n\r\n                this.binaryInsertionSort(low, low + force, low + runLength);\r\n                runLength = force;\r\n            }\r\n            // Push new run and merge if necessary\r\n            this.pushRun(low, runLength);\r\n            this.mergeRuns();\r\n\r\n            // Go find next run\r\n            remaining -= runLength;\r\n            low += runLength;\r\n\r\n        } while (remaining !== 0);\r\n\r\n        // Force merging of remaining runs\r\n        this.forceMergeRuns();\r\n    }\r\n}\r\n\r\n/**\r\n * Sort an array in the range [lo, hi) using TimSort.\r\n *\r\n * @param {array} array - The array to sort.\r\n * @param {function=} compare - Item comparison function. Default is\r\n *     alphabetical\r\n * @param {number} lo - First element in the range (inclusive).\r\n * @param {number} hi - Last element in the range.\r\n *     comparator.\r\n */\r\n// export sort(array, compare, lo, hi) {\r\n//     if (!Array.isArray(array)) {\r\n//         throw new TypeError('Can only sort arrays');\r\n//     }\r\n//\r\n//     /*\r\n//      * Handle the case where a comparison is not provided. We do\r\n//      * lexicographic sorting\r\n//      */\r\n//     if (!compare) {\r\n//         compare = alphabeticalCompare;\r\n//\r\n//     } else if (typeof compare !== 'function') {\r\n//         hi = lo;\r\n//         lo = compare;\r\n//         compare = alphabeticalCompare;\r\n//     }\r\n//\r\n//     if (!lo) {\r\n//         lo = 0;\r\n//     }\r\n//     if (!hi) {\r\n//         hi = array.length;\r\n//     }\r\n//\r\n//     let remaining = hi - lo;\r\n//\r\n//     // The array is already sorted\r\n//     if (remaining < 2) {\r\n//         return;\r\n//     }\r\n//\r\n//     let runLength = 0;\r\n//     // On small arrays binary sort can be used directly\r\n//     if (remaining < DEFAULT_MIN_MERGE) {\r\n//         runLength = makeAscendingRun(array, lo, hi, compare);\r\n//         binaryInsertionSort(array, lo, hi, lo + runLength, compare);\r\n//         return;\r\n//     }\r\n//\r\n//     let ts = new TimSort(array, compare);\r\n//\r\n//     let minRun = minRunLength(remaining);\r\n//\r\n//     do {\r\n//         runLength = makeAscendingRun(array, lo, hi, compare);\r\n//         if (runLength < minRun) {\r\n//             let force = remaining;\r\n//             if (force > minRun) {\r\n//                 force = minRun;\r\n//             }\r\n//\r\n//             binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\r\n//             runLength = force;\r\n//         }\r\n//         // Push new run and merge if necessary\r\n//         ts.pushRun(lo, runLength);\r\n//         ts.mergeRuns();\r\n//\r\n//         // Go find next run\r\n//         remaining -= runLength;\r\n//         lo += runLength;\r\n//\r\n//     } while (remaining !== 0);\r\n//\r\n//     // Force merging of remaining runs\r\n//     ts.forceMergeRuns();\r\n// }","const types = {\r\n\r\n}\r\n\r\nconst colors = {\r\n\r\n}\r\n\r\nexport class Element{\r\n\r\n    value;\r\n    color;\r\n    type;\r\n\r\n    // constructor(args){\r\n    //     this.value = args.value;\r\n    //     this.type = args.type;\r\n    //     this.color = args.color || colors[args.type];\r\n    // }\r\n\r\n    constructor(value, type, color) {\r\n            this.value = value;\r\n            this.type = type;\r\n            this.color = color;\r\n    }\r\n\r\n    getValue(){\r\n        return this.value;\r\n    }\r\n    setValue(value){\r\n        this.value = value;\r\n    }\r\n\r\n    getColor(){\r\n        return this.color;\r\n    }\r\n    setColor(color){\r\n        this.color = color;\r\n    }\r\n\r\n    getType(){\r\n        return this.type;\r\n    }\r\n    setType(type){\r\n        this.type = type;\r\n    }\r\n}","import {Element} from \"../classes/Element\";\r\nexport function random(a, b) {\r\n    return Math.random() * (b - a) + a;\r\n}\r\n\r\nexport function randomInt(a, b) {\r\n    return Math.trunc(random(a, b))\r\n}\r\n\r\nexport function swapObj(json) {\r\n    let ret = {};\r\n    for (let key in json) {\r\n        ret[json[key]] = key;\r\n    }\r\n    return ret;\r\n}\r\n\r\nexport function sleep(ms) {\r\n    ms += new Date().getTime();\r\n    while (new Date() < ms) {\r\n    }\r\n}\r\n\r\nexport function getAllMethods(toCheck) {\r\n    const props = [];\r\n    let obj = toCheck;\r\n    do {\r\n        props.push(...Object.getOwnPropertyNames(obj));\r\n    } while (obj = Object.getPrototypeOf(obj));\r\n\r\n    return props.sort().filter((e, i, arr) => {\r\n        if (e!=arr[i+1] && typeof toCheck[e] == 'function') return true;\r\n    });\r\n}\r\n\r\nexport function deepArrayCopy(arr){\r\n    let out = [];\r\n    for(let i of arr){\r\n        let value = i.getValue();\r\n        let type = i.getType();\r\n        let color = i.getColor();\r\n        out.push(new Element(value, type, color))\r\n    }\r\n    return out;\r\n}\r\n\r\nexport function arraysEquals(a, b){\r\n    return a.length === b.length &&\r\n    a.every((v, i) => v === b[i]);\r\n}","import React from 'react';\r\nimport styles from \"./ArrayWindow.module.scss\";\r\n\r\nexport function ArrayWindow(props){\r\n    let array = props.array\r\n    let mainArray = props.mainArray\r\n    let height = props.height\r\n    // let style = props.style\r\n    // console.log(array)\r\n    let arr = []\r\n\r\n    for (let i = 0; i < array.length; ++i) {\r\n        let styleSheet = {\r\n            height: array[i].getValue() / mainArray.length * 100 + \"%\",\r\n            backgroundColor: \"rgb(\" + array[i].getColor() + \")\"\r\n        }\r\n        arr.push(<div key={i} style={styleSheet} className={styles.bar}/>);\r\n    }\r\n    for(let i = array.length;i < mainArray.length;++i){\r\n        let styleSheet = {\r\n            height: \"0%\",\r\n            backgroundColor: \"rgb(255,255,255)\"\r\n        }\r\n        arr.push(<div key={i} style={styleSheet} className={styles.bar}/>);\r\n    }\r\n    if(array.length===0){\r\n        return <div/>\r\n    }\r\n    return (\r\n        <div style={{width: \"100%\", height: height+\"%\"}}>\r\n            <div className={styles.arrayContainer}>\r\n                {arr}\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","import React from 'react';\r\nimport styles from \"./Stats.module.scss\";\r\n\r\nexport function Stats(props){\r\n    return(\r\n        <div className={styles.statsContainer}>\r\n            <div><b>Sort: {props.sortName}</b></div>\r\n            <div>Length: {props.arrLength}</div>\r\n            {/*<div>Comparisons: {props.comparisons}</div>*/}\r\n            <div>Writes: {props.writes}</div>\r\n        </div>\r\n    )\r\n}","export let initFunctions = {\r\n    linear: function linear(x, length) {\r\n        return x;\r\n    },\r\n    reverse: function reverse(x, length) {\r\n        return length - x;\r\n    },\r\n    pipeOrgan: function pipeOrgan(x, length) {\r\n        if (x < length / 2) {\r\n            return 2 * x;\r\n        } else {\r\n            return 2 * (length - x) - 1;\r\n        }\r\n    },\r\n    inversedPipeOrgan: function inversedPipeOrgan(x, length){\r\n        if (x < length / 2) {\r\n            return (length - 2*x) - 1;\r\n        } else {\r\n            return x*2-length;\r\n        }\r\n    }\r\n}","import {randomInt} from \"./utils\";\r\n\r\nexport let shuffles = {\r\n    fullShuffle: function (len) {\r\n        let instructions = []\r\n        for (let i = 0; i < len; ++i) {\r\n            let randomIndex = randomInt(i, len)\r\n            instructions.push(\r\n                {\r\n                    cmd: \"swap\",\r\n                    a: i,\r\n                    b:randomIndex\r\n                }\r\n            )\r\n        }\r\n        return instructions\r\n    },\r\n\r\n    almostSorted: function (len) {\r\n        let instructions = []\r\n        const amount = 0.1\r\n        for (let i = 0; i < len * amount; ++i) {\r\n            let randomIndexA = randomInt(i, len)\r\n            let randomIndexB = randomInt(i, len)\r\n            instructions.push(\r\n                {\r\n                    cmd: \"swap\",\r\n                    a: randomIndexA,\r\n                    b:randomIndexB\r\n                }\r\n            )\r\n        }\r\n        return instructions\r\n    }\r\n\r\n\r\n}","import React from 'react';\r\nimport styles from \"./Controls.module.scss\";\r\nimport {initFunctions} from \"../utils/initFunctions\";\r\nimport {getAllMethods} from \"../utils/utils\";\r\nimport {shuffles} from \"../utils/shuffles\";\r\n\r\n\r\nexport class Controls extends React.Component {\r\n    isControlShow\r\n    arrayVisualizer\r\n    sorts\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.DEFAULT_ARR_LEN = 100\r\n        this.isControlShow = true;\r\n        this.arrayVisualizer = props.arrayVisualizer\r\n        this.sorts = props.sorts\r\n        this.arrayVisualizer.updateArrLength(this.DEFAULT_ARR_LEN)\r\n        this.arrayVisualizer.initArray(initFunctions.linear)\r\n    }\r\n\r\n    updateArrLength() {\r\n        let slider = document.getElementById(styles.slider)\r\n\r\n        if (slider !== null) {\r\n            let len = slider.value\r\n            this.arrayVisualizer.updateArrLength(len)\r\n        }\r\n    }\r\n\r\n    toggleControlShow() {\r\n        // console.log(styles.controls)\r\n        let controlsContainer = document.getElementById(styles.controlsContainer)\r\n        let controls = document.getElementById(styles.controls)\r\n        let btn = document.getElementById(styles.showToggleBtn)\r\n        if (this.isControlShow) {\r\n            controls.style.display = \"none\"\r\n            controlsContainer.style.width = \"0\"\r\n            btn.innerHTML = \"&gt;&gt;\";\r\n        } else {\r\n            controls.style.display = \"block\"\r\n            controlsContainer.style.width = \"20rem\"\r\n            btn.innerHTML = \"&lt;&lt\";\r\n        }\r\n        this.isControlShow = !this.isControlShow\r\n    }\r\n\r\n    initArray(func){\r\n        this.arrayVisualizer.initArray(func, this.arrayVisualizer.arrLength, true)\r\n    }\r\n\r\n    shuffleArray(func){\r\n        this.arrayVisualizer.shuffleArray(func)\r\n    }\r\n\r\n    sortArray(sortName){\r\n        this.sorts.runSort(sortName, 0, this.arrayVisualizer.getArrLength()-1, 10)\r\n    }\r\n\r\n    stopSort(){\r\n        this.arrayVisualizer.stopSort()\r\n    }\r\n\r\n    abortSort(){\r\n        this.stopSort()\r\n        this.initArray(initFunctions.linear)\r\n    }\r\n\r\n    genInitFunctions(){\r\n        // console.log(initFunctions)\r\n        let tmp = []\r\n        for (let i in initFunctions) {\r\n            tmp.push(\r\n                <button key={i} onClick={this.initArray.bind(this, initFunctions[i])}>{i}</button>\r\n            )\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    getSorts(){\r\n        let tmp = []\r\n        let sortsNames = this.sorts.getSortsPaths()\r\n        for (let i of sortsNames) {\r\n                tmp.push(\r\n                    <button key={i} onClick={this.sortArray.bind(this, i)}>{i}</button>)\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    getShuffles(){\r\n        let tmp = []\r\n        for(let i in shuffles){\r\n            tmp.push(\r\n                <button key={i} onClick={this.shuffleArray.bind(this, shuffles[i])}>{i}</button>\r\n            )\r\n        }\r\n        return tmp;\r\n    }\r\n\r\n    toggleShowAuxArrays(){\r\n        let element = document.getElementById(\"auxArrShowCB\")\r\n        this.arrayVisualizer.setShowAuxArrays(element.checked)\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div id={styles.controlsContainer}>\r\n                {/*<div onClick={this.toggleControlShow.bind(this)} id={styles.showToggleBtn}>&lt;&lt;</div>*/}\r\n                <div id={styles.controls}>\r\n                    <div>\r\n                        <div className={styles.textCenter}>Array Size</div>\r\n                        <input id={styles.slider} type=\"range\" min=\"10\" max=\"300\" defaultValue={this.DEFAULT_ARR_LEN}\r\n                               step=\"10\"\r\n                               onChange={this.updateArrLength.bind(this)}/>\r\n                        <div className={styles.textCenter}>\r\n                            <div>Visuals</div>\r\n                            <div>\r\n                                <input onChange={this.toggleShowAuxArrays.bind(this)} type=\"checkbox\" id=\"auxArrShowCB\" name=\"auxArrShowCB\" defaultChecked={true}/>\r\n                                    <label htmlFor=\"auxArrShowCB\">Show Aux Arrays</label>\r\n                            </div>\r\n                        </div>\r\n                        <div className={styles.textCenter}>\r\n                            <div>Init Array</div>\r\n                            <div>{this.genInitFunctions()}</div>\r\n                        </div>\r\n\r\n                        <div className={styles.textCenter}>\r\n                            <div>Shuffle Array</div>\r\n                            <div>\r\n                                {/*<button onClick={this.shuffleArray.bind(this)}>Random</button>*/}\r\n                                <div>{this.getShuffles()}</div>\r\n                            </div>\r\n                        </div>\r\n                        <div className={styles.textCenter}>\r\n                            <div>Sort control</div>\r\n                            <div>\r\n                                <button onClick={this.abortSort.bind(this)}>Abort Sort(Recommended)</button>\r\n                                <button onClick={this.stopSort.bind(this)}>Stop Sort(Not Recommended)</button>\r\n                            </div>\r\n                        </div>\r\n                        <div className={styles.textCenter}>\r\n                            <div>Sort Array</div>\r\n                            <div>\r\n                                {this.getSorts()}\r\n                            </div>\r\n                        </div>\r\n                    </div>\r\n\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}","import React from 'react';\r\nimport {arraysEquals, deepArrayCopy, getAllMethods, randomInt} from \"../utils/utils\";\r\nimport {Sorts} from \"../Sorts/Sorts\"\r\nimport {ArrayWindow} from \"../ArrayWindow/ArrayWindow\";\r\nimport {Element} from \"../classes/Element\";\r\nimport {Stats} from \"../Stats/Stats\";\r\nimport {Controls} from \"../Controls/Controls\";\r\nimport {initFunctions} from \"../utils/initFunctions\";\r\n\r\nconst colors = {\r\n    \"Unmarked\": [255, 255, 255],\r\n    \"Default\": [255, 0, 0],\r\n    \"Additional\": [randomInt(0, 256), randomInt(0, 256), randomInt(0, 256)],\r\n    \"Sorted\": [0, 255, 0],\r\n    \"Analysis\": [0, 0, 255]\r\n}\r\n\r\nexport class ArrayVisualizer extends React.Component {\r\n    delays;\r\n    delayInc;\r\n    pseudoArray;\r\n    pseudoAuxArrays;\r\n    arrLength\r\n    ctx\r\n    timeoutArray\r\n    sorts\r\n    delayIncConst\r\n    showAuxArrays\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        // this.arrLength = 100\r\n        this.state = {\r\n            array: this.initArray(initFunctions.linear, this.arrLength),\r\n            sortName: \"\",\r\n            comparisons: 0,\r\n            writes: 0,\r\n            auxArrays: []\r\n        }\r\n        this.delays = {\r\n            Swap: 0,\r\n            Write: 0,\r\n            Comp: 0,\r\n            Unmark: 0,\r\n            CreateAuxArray: 0,\r\n            RemoveAuxArray: 0\r\n        }\r\n        this.delayIncConst = 3000\r\n        this.instructions = [];\r\n        this.timeoutArray = [];\r\n        this.pseudoArray = deepArrayCopy(this.state.array)\r\n        this.pseudoAuxArrays = []\r\n        this.sorts = new Sorts(this);\r\n        this.arrLength = this.state.length\r\n        this.delayInc = this.delayIncConst/this.arrLength;\r\n        this.showAuxArrays = true\r\n        this.ctx = new (window.AudioContext || window.webkitAudioContext)();\r\n        // this.updateArrLength(this.arrLength);\r\n    }\r\n\r\n    playSound(value) {\r\n        let osc = this.ctx.createOscillator();\r\n        osc.type = 'sine';\r\n\r\n        let k = value / this.arrLength\r\n        osc.frequency.value = 2000 * k + 200;\r\n\r\n\r\n        let addTime = 50\r\n\r\n        let gainNode = this.ctx.createGain()\r\n        gainNode.gain.value = 0;\r\n        osc.connect(gainNode)\r\n        gainNode.connect(this.ctx.destination)\r\n\r\n        gainNode.gain.linearRampToValueAtTime(0.05, this.ctx.currentTime + (this.delayInc + addTime) / 1000 / 2)\r\n        gainNode.gain.linearRampToValueAtTime(0, this.ctx.currentTime + (this.delayInc + addTime) / 1000)\r\n\r\n        osc.start();\r\n        osc.stop(this.ctx.currentTime + (this.delayInc + addTime) / 1000);\r\n\r\n    }\r\n    resetDelay() {\r\n        this.delays = {\r\n            Swap: 0,\r\n            Write: 0,\r\n            Comp: 0,\r\n            Unmark: 0,\r\n            CreateAuxArray: 0,\r\n            RemoveAuxArray: 0\r\n        }\r\n        for(let i of this.timeoutArray){\r\n            clearTimeout(i);\r\n        }\r\n        this.timeoutArray = []\r\n    }\r\n\r\n    nullify() {\r\n        this.resetDelay()\r\n        this.setState(\r\n            {\r\n                comparisons: 0,\r\n                writes: 0\r\n            }\r\n        )\r\n        // eslint-disable-next-line react/no-direct-mutation-state\r\n        this.state.writes = 0;\r\n        // eslint-disable-next-line react/no-direct-mutation-state\r\n        this.state.comparisons = 0;\r\n    }\r\n\r\n    mark(index, args, saveArr = true) {\r\n        let type = \"Default\"\r\n        let color = colors[\"Default\"]\r\n        let tmpArr = this.state.array\r\n        // Additional\r\n        if (args.type === \"Additional\") {\r\n            type = \"Additional\"\r\n            color = args.color\r\n            // console.log(color)\r\n        }\r\n        //Default\r\n        else if (!args.type || args.type === \"Default\") {\r\n            type = \"Default\"\r\n            color = colors[\"Default\"]\r\n        } else {\r\n            type = args.type\r\n            color = args.color\r\n        }\r\n\r\n        tmpArr[index].setType(type)\r\n        tmpArr[index].setColor(color)\r\n        if (saveArr) {\r\n            this.setState({\r\n                array: tmpArr\r\n            })\r\n        } else {\r\n            return tmpArr\r\n        }\r\n        // console.log(color);\r\n    }\r\n\r\n    markMany(indexes, args, saveArr) {\r\n        let tmpArr = this.state.array\r\n        for (let i of indexes) {\r\n            if (saveArr) {\r\n                this.mark(i, args, saveArr)\r\n            } else {\r\n                tmpArr = this.mark(i, args, saveArr)\r\n            }\r\n        }\r\n        if (!saveArr) {\r\n            return tmpArr\r\n        }\r\n    }\r\n\r\n    unmark(index, saveArr = true) {\r\n        let tmpArr = this.state.array\r\n        tmpArr[index].setColor(colors[\"Unmarked\"])\r\n        tmpArr[index].setType(\"Unmarked\")\r\n        if (saveArr) {\r\n            this.setState({\r\n                array: tmpArr\r\n            })\r\n        } else {\r\n            return tmpArr\r\n        }\r\n    }\r\n\r\n    unmarkMany(indexes, saveArr, saveOnce) {\r\n        let tmpArr = this.state.array\r\n        for (let i of indexes) {\r\n            if (saveArr) {\r\n                this.unmark(i, saveArr)\r\n            } else {\r\n                tmpArr = this.unmark(i, saveArr)\r\n            }\r\n        }\r\n        if (saveOnce) {\r\n            this.setState({\r\n                array: tmpArr\r\n            })\r\n        }\r\n        if (!saveArr) {\r\n            return tmpArr\r\n        }\r\n    }\r\n\r\n\r\n    markUnmarkMany(markIndexes, markArgs) {\r\n        this.markMany(markIndexes, markArgs, true)\r\n        this.timeoutArray.push(setTimeout(this.unmarkMany.bind(this), this.delays.Unmark += this.delayInc / 100, markIndexes, false, true))\r\n    }\r\n\r\n    swapWithDelay(a, b, arr = this.pseudoArray, mark, delay = this.delayInc, playSound) {\r\n        this.timeoutArray.push(setTimeout(this.swapInArr.bind(this), this.delays.Swap += delay, a, b, arr, mark, playSound))\r\n    }\r\n\r\n\r\n    swapInArr(a, b, arr = this.pseudoArray, mark = true, playSound = false) {\r\n        if(playSound) {\r\n            this.playSound(arr[b].getValue());\r\n        }\r\n        let tmpArr = arr\r\n        // console.log(\"SWAPPING:\" + tmpArr[a].getValue()+\"<->\"+tmpArr[b].getValue())\r\n        let tmp = tmpArr[a]\r\n        tmpArr[a] = tmpArr[b]\r\n        tmpArr[b] = tmp\r\n        if (mark) {\r\n            this.markUnmarkMany([a, b], {type: \"Default\"})\r\n        }\r\n        let curWrites = this.state.writes;\r\n        this.setState({\r\n            writes: curWrites + 2\r\n        })\r\n    }\r\n\r\n    swap(a, b, arr = this.pseudoArray) {\r\n        this.swapInArr(a, b, arr, false, false)\r\n        // console.log(getVarName(this.state.array.name))\r\n        this.instructions.push(\r\n        {\r\n            cmd: \"swap\",\r\n            arr: arr,\r\n            a: a,\r\n            b: b\r\n        }\r\n        )\r\n        // this.swapWithDelay(a, b, this.state.array, true, this.delayInc, true)\r\n    }\r\n\r\n    writeInArr(index, value, arr = this.pseudoArray, mark = true, playSound = false) {\r\n        // console.log(\"WRITING IN \")\r\n        // console.log(this.getNameByArray(arr))\r\n        // console.log(\"INDEX: \"+index)\r\n        // console.log(\"VALUE: \"+value)\r\n        if(playSound) {\r\n            this.playSound(value)\r\n        }\r\n        arr[index].setValue(value)\r\n        if (mark) {\r\n            this.markUnmarkMany([index], {type: \"Default\"})\r\n        }\r\n        let curWrites = this.state.writes;\r\n        this.setState({\r\n            writes: curWrites + 1\r\n        })\r\n    }\r\n\r\n    writeWithDelay(index, value, arr = this.pseudoArray, mark, delay = this.delayInc, playSound = true) {\r\n        this.timeoutArray.push(setTimeout(this.writeInArr.bind(this), this.delays.Write += delay, index, value, arr, mark, playSound))\r\n    }\r\n\r\n    write(index, value, arr = this.pseudoArray) {\r\n        this.writeInArr(index, value, arr, false, false)\r\n        this.instructions.push(\r\n            {\r\n                cmd: \"write\",\r\n                arr: arr,\r\n                index: index,\r\n                value: value\r\n            }\r\n        )\r\n        // this.writeWithDelay(index, value, this.state.array, true, this.delayInc, true)\r\n    }\r\n\r\n    read(index, arr = this.pseudoArray) {\r\n        // this.markUnmarkMany([index], {type: \"Default\"})\r\n        this.instructions.push(\r\n            {\r\n             cmd: \"read\",\r\n             arr: arr,\r\n             index: index\r\n            }\r\n        )\r\n        return arr[index].getValue()\r\n    }\r\n\r\n    compare(a, b, sign = \"<\", arr = this.pseudoArray) {\r\n        // this.compMainArrWithDelay(a, b, false)\r\n        if (sign === \"<\") {\r\n            return arr[a].getValue() < arr[b].getValue()\r\n        } else if (sign === \"<=\") {\r\n            return arr[a].getValue() <= arr[b].getValue()\r\n        } else if (sign === \">\") {\r\n            return arr[a].getValue() > arr[b].getValue()\r\n        } else if (sign === \">=\") {\r\n            return arr[a].getValue() >= arr[b].getValue()\r\n        } else {\r\n            return arr[a].getValue() === arr[b].getValue()\r\n        }\r\n    }\r\n\r\n    compMainArr(a, b, mark = false) {\r\n        let curComparisons = this.state.comparisons;\r\n        this.setState({\r\n            comparisons: curComparisons + 1\r\n        })\r\n        console.log(\"Comparisons: \" + this.state.comparisons + \" \" + a + \" \" + b)\r\n        if (mark) {\r\n            this.markUnmarkMany([a, b], {type: \"Additional\", color: [0, 0, 255]})\r\n        }\r\n    }\r\n\r\n    compMainArrWithDelay(a, b, mark = false) {\r\n        // setTimeout(this.compMainArr.bind(this), this.delays.Comp += this.delayInc, a, b, mark)\r\n    }\r\n\r\n    createAuxArray(len, isPseudo = true){\r\n        if(isPseudo) {\r\n            let auxArrIndex = this.pseudoAuxArrays.length\r\n            this.pseudoAuxArrays.push(this.initArray(() => 0, len, false))\r\n            this.instructions.push(\r\n                {\r\n                    cmd: \"createAuxArray\",\r\n                    len: len\r\n                }\r\n            )\r\n            return auxArrIndex\r\n        }else{\r\n            let tmpArr = this.state.auxArrays\r\n            tmpArr.push(this.initArray(() => 0, len, false))\r\n            this.setState({\r\n                auxArrays: tmpArr\r\n                }\r\n            )\r\n        }\r\n    }\r\n\r\n    createAuxArrayWithDelay(len, delay, isPseudo = false){\r\n        this.timeoutArray.push(setTimeout(this.createAuxArray.bind(this), this.delays.Write += delay, len, isPseudo))\r\n    }\r\n\r\n    removeAuxArray(index, isPseudo = true){\r\n        if(isPseudo) {\r\n            this.pseudoAuxArrays.splice(index, 1)\r\n            this.instructions.push(\r\n                {\r\n                    cmd: \"removeAuxArray\",\r\n                    index: index\r\n                }\r\n            )\r\n        }else{\r\n            let tmp = this.state.auxArrays\r\n            tmp.splice(index, 1)\r\n            this.setState({\r\n                auxArrays: tmp\r\n            })\r\n            // this.state.auxArrays.splice(index, 1)\r\n        }\r\n    }\r\n\r\n    removeAuxArrayWithDelay(index, delay, isPseudo = false){\r\n        this.timeoutArray.push(setTimeout(this.removeAuxArray.bind(this), this.delays.Write += delay, index, isPseudo))\r\n    }\r\n\r\n    auxRead(index, arrIndex, isPseudo = true){\r\n        if(isPseudo){\r\n            return this.pseudoAuxArrays[arrIndex][index].getValue()\r\n        }else {\r\n            return this.state.auxArrays[arrIndex][index].getValue()\r\n        }\r\n    }\r\n\r\n    auxWrite(index, value, arrIndex, isPseudo = true, playSound = false){\r\n        if(playSound){\r\n            this.playSound(value)\r\n        }\r\n        if(isPseudo){\r\n            this.pseudoAuxArrays[arrIndex][index].setValue(value)\r\n            this.instructions.push(\r\n                {\r\n                    cmd: \"auxWrite\",\r\n                    index: index,\r\n                    value: value,\r\n                    arrIndex: arrIndex\r\n                }\r\n            )\r\n        }else{\r\n            this.state.auxArrays[arrIndex][index].setValue(value)\r\n            let tmp = this.state.auxArrays\r\n            this.setState({\r\n                auxArrays: tmp\r\n            })\r\n        }\r\n    }\r\n\r\n    auxWriteWithDelay(index, value, arrIndex, delay, isPseudo = false, playSound = true, ){\r\n        this.timeoutArray.push(setTimeout(this.auxWrite.bind(this), this.delays.Write += delay, index, value, arrIndex, isPseudo, playSound))\r\n    }\r\n\r\n    getNameByArray(arr){\r\n        // console.log(arr)\r\n        if(arraysEquals(arr, this.state.array)){\r\n            return {name:\"mainArray\"}\r\n        }\r\n        if(arraysEquals(arr, this.pseudoArray)){\r\n            return {name:\"pseudoArray\"}\r\n        }\r\n        for(let i = 0; i < this.pseudoAuxArrays.length;++i){\r\n            if (arraysEquals(arr, this.pseudoAuxArrays[i])){\r\n                return {name:\"pseudoAuxArray\", index:i}\r\n            }\r\n        }\r\n        for(let i = 0; i < this.state.auxArrays.length;++i){\r\n            if (arraysEquals(arr, this.state.auxArrays[i])){\r\n                return {name:\"auxArray\", index:i}\r\n            }\r\n        }\r\n        return \"NotFound\"\r\n    }\r\n\r\n    getArrayByName(args){\r\n        let name = args.name\r\n        let index = args.index\r\n        if (name===\"mainArray\"){\r\n            return this.state.array\r\n        }\r\n        if(name===\"pseudoArray\"){\r\n            return this.pseudoArray\r\n        }\r\n        if(name===\"auxArray\"){\r\n            console.log(args)\r\n            return this.state.auxArrays[index]\r\n        }\r\n        if(name===\"pseudoAuxArray\"){\r\n            console.log(args)\r\n            return this.pseudoAuxArrays[index]\r\n        }\r\n        return []\r\n    }\r\n\r\n    inverseArrayName(args){\r\n        let name = args.name\r\n        let index = args.index\r\n        if(name===\"pseudoArray\") {\r\n            return {name:\"mainArray\"}\r\n        }else if(name===\"pseudoAuxArray\"){\r\n            return {name: \"auxArray\", index: index}\r\n        }\r\n        return args\r\n    }\r\n\r\n\r\n    getArrayVisualizer() {\r\n        return this;\r\n    }\r\n\r\n    getPseudoArray() {\r\n        return this.pseudoArray;\r\n    }\r\n\r\n    getState(){\r\n        return this.state\r\n    }\r\n\r\n    getArrLength(){\r\n        return this.arrLength;\r\n    }\r\n\r\n    setShowAuxArrays(val){\r\n        this.showAuxArrays = val\r\n    }\r\n\r\n    stopSort(){\r\n        this.resetDelay()\r\n        this.unmarkMany(Array.from(Array(this.arrLength).keys()), false, true)\r\n        this.setState({\r\n                auxArrays: []\r\n            }\r\n        )\r\n    }\r\n\r\n    initArray(func, length, setToState=false) {\r\n        let arr = []\r\n        for (let i = 0; i < length; ++i) {\r\n            let element = new Element(func(i, length), 0, [255, 255, 255])\r\n            arr.push(element)\r\n        }\r\n        if(setToState){\r\n            this.setState({\r\n                array: arr\r\n            })\r\n        }else {\r\n            return arr;\r\n        }\r\n    }\r\n\r\n    shuffleArray(func) {\r\n        this.nullify()\r\n        this.setState({\r\n            sortName: \"Shuffle\"\r\n        })\r\n\r\n        let instructions = func(this.arrLength);\r\n        for(let i of instructions){\r\n            if(i.cmd === \"swap\"){\r\n                setTimeout(this.swapInArr.bind(this), this.delays.Swap += this.delayInc / 5, i.a, i.b, this.state.array, true, true)\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    shuffleClickEvent() {\r\n        this.shuffleArray()\r\n    }\r\n\r\n    setSortName(sortName){\r\n        this.setState({\r\n            sortName: sortName\r\n        })\r\n    }\r\n\r\n    initPseudoArray(){\r\n        this.pseudoArray = deepArrayCopy(this.state.array)\r\n    }\r\n\r\n    // sortClickEvent(sortName, low, high, bucketsNum) {\r\n    sortClickEvent() {\r\n        this.nullify()\r\n\r\n        // let sortBind = sort.bind(this.sorts, 0, this.arrLength - 1)\r\n        // sortBind()\r\n        // console.log(sort)\r\n        // let sort = this.sorts.getSortObject(sortName)\r\n        //\r\n        // this.setState({\r\n        //     sortName: sort.getSortName()\r\n        // })\r\n\r\n        // let warnLen = sort.getWarnLen()\r\n        // if(warnLen!==-1 && this.arrLength > warnLen && !window.confirm(\"WARNING!!!\\nThe array size(\"+this.arrLength+\") \" +\r\n        //     \"more than recommended(\"+warnLen+\")\\nApplication may freeze\\nDo you want continue?\")){\r\n        //     return\r\n        // }\r\n\r\n        // sort.runSort(low, high, bucketsNum)\r\n\r\n        console.log(\"SORTED ARRAY:\")\r\n        console.log(this.pseudoArray)\r\n\r\n        console.log(\"START INTERPRETATION!!\")\r\n        for(let i of this.instructions){\r\n            let cmd = i.cmd\r\n            if([\"swap\", \"read\", \"write\"].includes(cmd)) {\r\n                let arrName = this.getNameByArray(i.arr)\r\n                let arrNameInv = this.inverseArrayName(arrName)\r\n                let arr = this.getArrayByName(arrNameInv)\r\n                // console.log(arrName)\r\n                if (cmd === \"swap\") {\r\n                    this.swapWithDelay(i.a, i.b, arr, true, this.delayInc, true)\r\n                } else if (cmd === \"write\") {\r\n                    // console.log(arrName)\r\n                    // console.log(\"WRITE FROM INTERPRETER!\")\r\n                    // console.log(arr)\r\n                    // console.log(this.getNameByArray(arr))\r\n                    this.writeWithDelay(i.index, i.value, arr, true, this.delayInc, true)\r\n                } else {}\r\n            }\r\n            if(cmd===\"auxWrite\"){\r\n                this.auxWriteWithDelay(i.index, i.value, i.arrIndex, this.delayInc, false, true)\r\n            }\r\n            if(cmd===\"createAuxArray\"){\r\n                this.createAuxArrayWithDelay(i.len, this.delayInc, false)\r\n            }\r\n            if(cmd===\"removeAuxArray\"){\r\n                this.removeAuxArrayWithDelay(i.index, this.delayInc, false)\r\n            }\r\n        }\r\n        this.pseudoAuxArrays = []\r\n        this.instructions = []\r\n    }\r\n\r\n\r\n    updateDelayInc(val){\r\n        this.delayInc = val/this.arrLength;\r\n    }\r\n\r\n    updateArrLength(len){\r\n        this.arrLength = len\r\n        this.setState({\r\n            array: this.initArray(initFunctions.linear, this.arrLength)\r\n        })\r\n        this.pseudoArray = deepArrayCopy(this.state.array)\r\n\r\n        this.sorts.arrLength = this.getArrLength()\r\n        this.updateDelayInc(this.delayIncConst)\r\n    }\r\n\r\n    genArrayWindows(){\r\n        let tmp = []\r\n        if(this.showAuxArrays) {\r\n            for (let i = this.state.auxArrays.length - 1; i >= 0; i--) {\r\n                tmp.push(\r\n                    <ArrayWindow key={this.state.auxArrays.length - i} array={this.state.auxArrays[i]}\r\n                                 mainArray={this.state.array} height={100 / (1 + this.state.auxArrays.length)}/>\r\n                )\r\n            }\r\n        }\r\n        return tmp\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <Stats sortName={this.state.sortName} comparisons={this.state.comparisons} writes={this.state.writes} arrLength={this.arrLength}/>\r\n                <div style={{height: \"100vh\"}}>\r\n                {/*<div>*/}\r\n                    {this.genArrayWindows()}\r\n                    <ArrayWindow array={this.state.array} mainArray={this.state.array} height={this.showAuxArrays ? 100/(1+this.state.auxArrays.length) : 100}/>\r\n                </div>\r\n                <div>\r\n                    <Controls arrayVisualizer={this} sorts={this.sorts}/>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport {ArrayVisualizer} from \"./components/ArrayVisualizer/ArrayVisualizer\";\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\n\r\n\r\n\r\n\r\n\r\nReactDOM.render(\r\n    <ArrayVisualizer></ArrayVisualizer>,\r\n  document.getElementById('root')\r\n);\r\n\r\n\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}